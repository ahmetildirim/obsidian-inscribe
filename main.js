/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Inscribe
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// node_modules/codemirror-companion-extension/dist/extension.js
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");

// node_modules/codemirror-companion-extension/dist/lib/utils.js
function a(n, i, t = void 0) {
  const c2 = {
    force: () => {
    }
  };
  let e = null;
  async function* f(...u2) {
    e && clearTimeout(e);
    let r2 = null;
    try {
      await new Promise((o) => {
        r2 = e = setTimeout(() => o(), i), c2.force = () => {
          e && clearTimeout(e), o();
        };
      });
    } catch (e2) {
      if (t !== void 0)
        throw t;
    }
    for await (const o of n(...u2)) {
      if (r2 !== e)
        break;
      yield o;
    }
  }
  return { debounced: f, force: () => c2.force() };
}

// node_modules/codemirror-companion-extension/dist/extension.js
var F = Object.defineProperty;
var I = (n, t, e) => t in n ? F(n, t, { enumerable: true, configurable: true, writable: true, value: e }) : n[t] = e;
var c = (n, t, e) => (I(n, typeof t != "symbol" ? t + "" : t, e), e);
var r = import_state.StateField.define({
  create() {
    return { suggestion: null };
  },
  update(n, t) {
    const e = t.effects.find(
      (s) => s.is(d)
    );
    return t.state.doc && e && (e.value.doc == null || t.state.doc == e.value.doc) ? { suggestion: e.value.suggestion } : { suggestion: null };
  }
});
var d = import_state.StateEffect.define();
function E(n, t) {
  const e = n.state.selection.main.head, s = [], o = import_view.Decoration.widget({
    widget: new P(t),
    side: 1
  });
  return s.push(o.range(e)), import_view.Decoration.set(s);
}
var P = class extends import_view.WidgetType {
  constructor(e) {
    super();
    c(this, "suggestion");
    this.suggestion = e;
  }
  toDOM() {
    const e = document.createElement("span");
    return e.style.opacity = "0.4", e.className = "cm-inline-suggestion", e.textContent = this.suggestion, e;
  }
};
var g = (n) => {
  let t = 0;
  return import_view.ViewPlugin.fromClass(
    class {
      async update(s) {
        const o = s.state.doc;
        if (!s.docChanged)
          return;
        const i = ++t;
        for await (const a2 of n(s.state)) {
          if (i != t)
            return;
          s.view.dispatch({
            effects: d.of({
              suggestion: a2,
              doc: o
            })
          });
        }
      }
    }
  );
};
var T = class {
  constructor() {
    c(this, "decorations");
    this.decorations = import_view.Decoration.none;
  }
  update(t) {
    var s;
    const e = (s = t.state.field(
      r
    )) == null ? void 0 : s.suggestion;
    if (!e) {
      this.decorations = import_view.Decoration.none;
      return;
    }
    this.decorations = E(
      t.view,
      e.display_suggestion
    );
  }
};
var l = import_view.ViewPlugin.fromClass(T, {
  decorations: (n) => n.decorations
});
var _ = class {
  constructor(t, e) {
    c(this, "suggestFn");
    c(this, "keymap");
    c(this, "completionId");
    c(this, "run", (t2) => {
      var o, i;
      const e2 = (o = t2.state.field(
        r
      )) == null ? void 0 : o.suggestion;
      return e2 ? (t2.dispatch({
        ...x(
          t2.state,
          e2.complete_suggestion,
          t2.state.selection.main.head,
          t2.state.selection.main.head
        )
      }), (i = e2.accept_hook) == null || i.call(e2), (async () => {
        if (this.suggestFn == null)
          return;
        const a2 = ++this.completionId;
        for await (const f of this.suggestFn(t2.state)) {
          if (a2 != this.completionId)
            return;
          t2.dispatch({
            effects: d.of({
              suggestion: {
                complete_suggestion: f.complete_suggestion,
                display_suggestion: f.display_suggestion,
                accept_hook: f.accept_hook
              },
              doc: null
            })
          });
        }
      })(), true) : false;
    });
    this.suggestFn = t, this.keymap = import_state.Prec.highest(
      import_view.keymap.of([
        {
          key: e,
          run: (s) => this.run(s)
        }
      ])
    ), this.completionId = 0;
  }
};
function x(n, t, e, s) {
  return {
    ...n.changeByRange((o) => {
      if (o == n.selection.main)
        return {
          changes: { from: e, to: s, insert: t },
          range: import_state.EditorSelection.cursor(e + t.length)
        };
      const i = s - e;
      return !o.empty || i && n.sliceDoc(o.from - i, o.from) != n.sliceDoc(e, s) ? { range: o } : {
        changes: { from: o.from - i, to: o.from, insert: t },
        range: import_state.EditorSelection.cursor(o.from - i + t.length)
      };
    }),
    userEvent: "input.complete"
  };
}
function p(n) {
  return typeof n == "string" ? {
    complete_suggestion: n,
    display_suggestion: n
  } : n;
}
function S(n) {
  return async function* (t) {
    const e = await n(t);
    if (typeof e == "string" || "complete_suggestion" in e) {
      yield p(e);
      return;
    }
    for await (const s of e)
      yield p(s);
  };
}
function G(n) {
  const { delay: t = 500, accept_shortcut: e = "Tab" } = n, s = S(n.fetchFn), { debounced: o } = a(
    s,
    t
  );
  return e ? [
    r,
    g(o),
    l,
    new _(
      n.continue_suggesting ? s : null,
      e
    ).keymap
  ] : [
    r,
    g(o),
    l
  ];
}

// src/settings/settings.ts
var import_obsidian2 = require("obsidian");

// src/completion/index.ts
var activeEditor;
async function* generateCompletion(editor, completer) {
  const cursor = editor.getCursor();
  activeEditor = editor;
  const currentLine = editor.getLine(cursor.line);
  if (!currentLine.length) {
    yield {
      display_suggestion: "",
      complete_suggestion: ""
    };
    return;
  }
  const lastChar = currentLine[cursor.ch - 1];
  if (lastChar !== " ") {
    yield { display_suggestion: "", complete_suggestion: "" };
    return;
  }
  const afterCursor = editor.getRange(cursor, { line: editor.lastLine(), ch: editor.getLine(editor.lastLine()).length });
  const beforeCursor = editor.getRange({ line: 0, ch: 0 }, cursor);
  yield* completer.generate(beforeCursor, afterCursor);
}

// src/providers/ollama/completer.ts
var OllamaCompleter = class {
  constructor(settins, client) {
    this.aborted = false;
    this.settings = settins;
    this.client = client;
  }
  async *generate(prefix, suffix) {
    this.aborted = false;
    const initialCursor = activeEditor.getCursor();
    const completionIterator = await this.client.generate({
      model: this.settings.model,
      prompt: prefix,
      system: "you are one son of a gun",
      stream: true
    });
    let completion = "";
    for await (let response of completionIterator) {
      if (this.aborted) {
        yield { complete_suggestion: "", display_suggestion: "" };
        return;
      }
      const currentCursor = activeEditor.getCursor();
      if (currentCursor.line !== initialCursor.line || currentCursor.ch !== initialCursor.ch) {
        console.log("cursor moved, aborting completion");
        this.abort();
        yield { complete_suggestion: "", display_suggestion: "" };
        return;
      }
      completion += response.response;
      yield { complete_suggestion: completion, display_suggestion: completion };
    }
  }
  async abort() {
    if (this.aborted)
      return;
    this.client.abort();
    this.aborted = true;
    console.log("aborted completion");
  }
};

// node_modules/whatwg-fetch/fetch.js
var g2 = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g2,
  iterable: "Symbol" in g2 && "iterator" in Symbol,
  blob: "FileReader" in g2 && "Blob" in g2 && function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: "FormData" in g2,
  arrayBuffer: "ArrayBuffer" in g2
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve2, reject) {
    reader.onload = function() {
      resolve2(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g2) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};
Response.error = function() {
  var response = new Response(null, { status: 200, statusText: "" });
  response.ok = false;
  response.status = 0;
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response(null, { status, headers: { location: url } });
};
var DOMException = g2.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch2(input, init) {
  return new Promise(function(resolve2, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve2(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g2.location.href ? g2.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g2.Headers && init.headers instanceof g2.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch2.polyfill = true;
if (!g2.fetch) {
  g2.fetch = fetch2;
  g2.Headers = Headers;
  g2.Request = Request;
  g2.Response = Response;
}

// node_modules/ollama/dist/shared/ollama.cddbc85b.mjs
var version = "0.5.11";
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ResponseError = class extends Error {
  constructor(error, status_code) {
    super(error);
    this.error = error;
    this.status_code = status_code;
    this.name = "ResponseError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ResponseError);
    }
  }
};
var AbortableAsyncIterator = class {
  constructor(abortController, itr, doneCallback) {
    __publicField$1(this, "abortController");
    __publicField$1(this, "itr");
    __publicField$1(this, "doneCallback");
    this.abortController = abortController;
    this.itr = itr;
    this.doneCallback = doneCallback;
  }
  abort() {
    this.abortController.abort();
  }
  async *[Symbol.asyncIterator]() {
    for await (const message of this.itr) {
      if ("error" in message) {
        throw new Error(message.error);
      }
      yield message;
      if (message.done || message.status === "success") {
        this.doneCallback();
        return;
      }
    }
    throw new Error("Did not receive done or success response in stream.");
  }
};
var checkOk = async (response) => {
  var _a;
  if (response.ok) {
    return;
  }
  let message = `Error ${response.status}: ${response.statusText}`;
  let errorData = null;
  if ((_a = response.headers.get("content-type")) == null ? void 0 : _a.includes("application/json")) {
    try {
      errorData = await response.json();
      message = errorData.error || message;
    } catch (error) {
      console.log("Failed to parse error response as JSON");
    }
  } else {
    try {
      console.log("Getting text from response");
      const textResponse = await response.text();
      message = textResponse || message;
    } catch (error) {
      console.log("Failed to get text from error response");
    }
  }
  throw new ResponseError(message, response.status);
};
function getPlatform() {
  if (typeof window !== "undefined" && window.navigator) {
    return `${window.navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;
  } else if (typeof process !== "undefined") {
    return `${process.arch} ${process.platform} Node.js/${process.version}`;
  }
  return "";
}
var fetchWithHeaders = async (fetch3, url, options = {}) => {
  const defaultHeaders = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "User-Agent": `ollama-js/${version} (${getPlatform()})`
  };
  if (!options.headers) {
    options.headers = {};
  }
  const customHeaders = Object.fromEntries(
    Object.entries(options.headers).filter(([key]) => !Object.keys(defaultHeaders).some((defaultKey) => defaultKey.toLowerCase() === key.toLowerCase()))
  );
  options.headers = {
    ...defaultHeaders,
    ...customHeaders
  };
  return fetch3(url, options);
};
var get = async (fetch3, host, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var head = async (fetch3, host) => {
  const response = await fetchWithHeaders(fetch3, host, {
    method: "HEAD"
  });
  await checkOk(response);
  return response;
};
var post = async (fetch3, host, data, options) => {
  const isRecord = (input) => {
    return input !== null && typeof input === "object" && !Array.isArray(input);
  };
  const formattedData = isRecord(data) ? JSON.stringify(data) : data;
  const response = await fetchWithHeaders(fetch3, host, {
    method: "POST",
    body: formattedData,
    signal: options == null ? void 0 : options.signal,
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var del = async (fetch3, host, data, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    method: "DELETE",
    body: JSON.stringify(data),
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var parseJSON = async function* (itr) {
  var _a;
  const decoder = new TextDecoder("utf-8");
  let buffer = "";
  const reader = itr.getReader();
  while (true) {
    const { done, value: chunk } = await reader.read();
    if (done) {
      break;
    }
    buffer += decoder.decode(chunk);
    const parts = buffer.split("\n");
    buffer = (_a = parts.pop()) != null ? _a : "";
    for (const part of parts) {
      try {
        yield JSON.parse(part);
      } catch (error) {
        console.warn("invalid json: ", part);
      }
    }
  }
  for (const part of buffer.split("\n").filter((p2) => p2 !== "")) {
    try {
      yield JSON.parse(part);
    } catch (error) {
      console.warn("invalid json: ", part);
    }
  }
};
var formatHost = (host) => {
  if (!host) {
    return "http://127.0.0.1:11434";
  }
  let isExplicitProtocol = host.includes("://");
  if (host.startsWith(":")) {
    host = `http://127.0.0.1${host}`;
    isExplicitProtocol = true;
  }
  if (!isExplicitProtocol) {
    host = `http://${host}`;
  }
  const url = new URL(host);
  let port = url.port;
  if (!port) {
    if (!isExplicitProtocol) {
      port = "11434";
    } else {
      port = url.protocol === "https:" ? "443" : "80";
    }
  }
  let formattedHost = `${url.protocol}//${url.hostname}:${port}${url.pathname}`;
  if (formattedHost.endsWith("/")) {
    formattedHost = formattedHost.slice(0, -1);
  }
  return formattedHost;
};
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var Ollama$1 = class Ollama {
  constructor(config) {
    var _a, _b;
    __publicField(this, "config");
    __publicField(this, "fetch");
    __publicField(this, "ongoingStreamedRequests", []);
    this.config = {
      host: "",
      headers: config == null ? void 0 : config.headers
    };
    if (!(config == null ? void 0 : config.proxy)) {
      this.config.host = formatHost((_a = config == null ? void 0 : config.host) != null ? _a : "http://127.0.0.1:11434");
    }
    this.fetch = (_b = config == null ? void 0 : config.fetch) != null ? _b : fetch;
  }
  // Abort any ongoing streamed requests to Ollama
  abort() {
    for (const request of this.ongoingStreamedRequests) {
      request.abort();
    }
    this.ongoingStreamedRequests.length = 0;
  }
  /**
   * Processes a request to the Ollama server. If the request is streamable, it will return a
   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
   * object.
   * @param endpoint {string} - The endpoint to send the request to.
   * @param request {object} - The request object to send to the endpoint.
   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
   * response messages.
   * @throws {Error} - If the response body is missing or if the response is an error.
   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
   */
  async processStreamableRequest(endpoint, request) {
    var _a;
    request.stream = (_a = request.stream) != null ? _a : false;
    const host = `${this.config.host}/api/${endpoint}`;
    if (request.stream) {
      const abortController = new AbortController();
      const response2 = await post(this.fetch, host, request, {
        signal: abortController.signal,
        headers: this.config.headers
      });
      if (!response2.body) {
        throw new Error("Missing body");
      }
      const itr = parseJSON(response2.body);
      const abortableAsyncIterator = new AbortableAsyncIterator(
        abortController,
        itr,
        () => {
          const i = this.ongoingStreamedRequests.indexOf(abortableAsyncIterator);
          if (i > -1) {
            this.ongoingStreamedRequests.splice(i, 1);
          }
        }
      );
      this.ongoingStreamedRequests.push(abortableAsyncIterator);
      return abortableAsyncIterator;
    }
    const response = await post(this.fetch, host, request, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
  * Encodes an image to base64 if it is a Uint8Array.
  * @param image {Uint8Array | string} - The image to encode.
  * @returns {Promise<string>} - The base64 encoded image.
  */
  async encodeImage(image) {
    if (typeof image !== "string") {
      const uint8Array = new Uint8Array(image);
      let byteString = "";
      const len = uint8Array.byteLength;
      for (let i = 0; i < len; i++) {
        byteString += String.fromCharCode(uint8Array[i]);
      }
      return btoa(byteString);
    }
    return image;
  }
  /**
   * Generates a response from a text prompt.
   * @param request {GenerateRequest} - The request object.
   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async generate(request) {
    if (request.images) {
      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));
    }
    return this.processStreamableRequest("generate", request);
  }
  /**
   * Chats with the model. The request object can contain messages with images that are either
   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
   * request.
   * @param request {ChatRequest} - The request object.
   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
   * AbortableAsyncIterator that yields response messages.
   */
  async chat(request) {
    if (request.messages) {
      for (const message of request.messages) {
        if (message.images) {
          message.images = await Promise.all(
            message.images.map(this.encodeImage.bind(this))
          );
        }
      }
    }
    return this.processStreamableRequest("chat", request);
  }
  /**
   * Creates a new model from a stream of data.
   * @param request {CreateRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
   */
  async create(request) {
    return this.processStreamableRequest("create", {
      name: request.model,
      stream: request.stream,
      modelfile: request.modelfile,
      quantize: request.quantize
    });
  }
  /**
   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PullRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async pull(request) {
    return this.processStreamableRequest("pull", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PushRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async push(request) {
    return this.processStreamableRequest("push", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Deletes a model from the server. The request object should contain the name of the model to
   * delete.
   * @param request {DeleteRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async delete(request) {
    await del(
      this.fetch,
      `${this.config.host}/api/delete`,
      { name: request.model },
      { headers: this.config.headers }
    );
    return { status: "success" };
  }
  /**
   * Copies a model from one name to another. The request object should contain the name of the
   * model to copy and the new name.
   * @param request {CopyRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async copy(request) {
    await post(this.fetch, `${this.config.host}/api/copy`, { ...request }, {
      headers: this.config.headers
    });
    return { status: "success" };
  }
  /**
   * Lists the models on the server.
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async list() {
    const response = await get(this.fetch, `${this.config.host}/api/tags`, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Shows the metadata of a model. The request object should contain the name of the model.
   * @param request {ShowRequest} - The request object.
   * @returns {Promise<ShowResponse>} - The response object.
   */
  async show(request) {
    const response = await post(this.fetch, `${this.config.host}/api/show`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds text input into vectors.
   * @param request {EmbedRequest} - The request object.
   * @returns {Promise<EmbedResponse>} - The response object.
   */
  async embed(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embed`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds a text prompt into a vector.
   * @param request {EmbeddingsRequest} - The request object.
   * @returns {Promise<EmbeddingsResponse>} - The response object.
   */
  async embeddings(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Lists the running models on the server
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async ps() {
    const response = await get(this.fetch, `${this.config.host}/api/ps`, {
      headers: this.config.headers
    });
    return await response.json();
  }
};
var browser = new Ollama$1();

// node_modules/ollama/dist/index.mjs
var import_fs = __toESM(require("fs"), 1);
var import_path = require("path");
var import_crypto = require("crypto");
var import_os = require("os");
var Ollama2 = class extends Ollama$1 {
  async encodeImage(image) {
    if (typeof image !== "string") {
      return Buffer.from(image).toString("base64");
    }
    try {
      if (import_fs.default.existsSync(image)) {
        const fileBuffer = await import_fs.promises.readFile((0, import_path.resolve)(image));
        return Buffer.from(fileBuffer).toString("base64");
      }
    } catch (e) {
    }
    return image;
  }
  /**
   * Parse the modelfile and replace the FROM and ADAPTER commands with the corresponding blob hashes.
   * @param modelfile {string} - The modelfile content
   * @param mfDir {string} - The directory of the modelfile
   * @private @internal
   */
  async parseModelfile(modelfile, mfDir = process.cwd()) {
    const out = [];
    const lines = modelfile.split("\n");
    for (const line of lines) {
      const [command, args] = line.split(" ", 2);
      if (["FROM", "ADAPTER"].includes(command.toUpperCase())) {
        const path = this.resolvePath(args.trim(), mfDir);
        if (await this.fileExists(path)) {
          out.push(`${command} @${await this.createBlob(path)}`);
        } else {
          out.push(`${command} ${args}`);
        }
      } else {
        out.push(line);
      }
    }
    return out.join("\n");
  }
  /**
   * Resolve the path to an absolute path.
   * @param inputPath {string} - The input path
   * @param mfDir {string} - The directory of the modelfile
   * @private @internal
   */
  resolvePath(inputPath, mfDir) {
    if (inputPath.startsWith("~")) {
      return (0, import_path.join)((0, import_os.homedir)(), inputPath.slice(1));
    }
    return (0, import_path.resolve)(mfDir, inputPath);
  }
  /**
   * checks if a file exists
   * @param path {string} - The path to the file
   * @private @internal
   * @returns {Promise<boolean>} - Whether the file exists or not
   */
  async fileExists(path) {
    try {
      await import_fs.promises.access(path);
      return true;
    } catch (e) {
      return false;
    }
  }
  async createBlob(path) {
    if (typeof ReadableStream === "undefined") {
      throw new Error("Streaming uploads are not supported in this environment.");
    }
    const fileStream = (0, import_fs.createReadStream)(path);
    const sha256sum = await new Promise((resolve2, reject) => {
      const hash = (0, import_crypto.createHash)("sha256");
      fileStream.on("data", (data) => hash.update(data));
      fileStream.on("end", () => resolve2(hash.digest("hex")));
      fileStream.on("error", reject);
    });
    const digest = `sha256:${sha256sum}`;
    try {
      await head(this.fetch, `${this.config.host}/api/blobs/${digest}`);
    } catch (e) {
      if (e instanceof Error && e.message.includes("404")) {
        const readableStream = new ReadableStream({
          start(controller) {
            fileStream.on("data", (chunk) => {
              controller.enqueue(chunk);
            });
            fileStream.on("end", () => {
              controller.close();
            });
            fileStream.on("error", (err) => {
              controller.error(err);
            });
          }
        });
        await post(
          this.fetch,
          `${this.config.host}/api/blobs/${digest}`,
          readableStream
        );
      } else {
        throw e;
      }
    }
    return digest;
  }
  async create(request) {
    let modelfileContent = "";
    if (request.path) {
      modelfileContent = await import_fs.promises.readFile(request.path, { encoding: "utf8" });
      modelfileContent = await this.parseModelfile(
        modelfileContent,
        (0, import_path.dirname)(request.path)
      );
    } else if (request.modelfile) {
      modelfileContent = await this.parseModelfile(request.modelfile);
    } else {
      throw new Error("Must provide either path or modelfile to create a model");
    }
    request.modelfile = modelfileContent;
    if (request.stream) {
      return super.create(request);
    } else {
      return super.create(request);
    }
  }
};
var index = new Ollama2();

// src/providers/ollama/provider.ts
var OllamaProvider = class {
  constructor(settings) {
    this.integration = "ollama" /* OLLAMA */;
    this.name = "Ollama";
    this.settings = settings;
    this.client = new Ollama2({ host: this.settings.host });
  }
  async loadCompleter() {
    console.log("loading ollama completer");
    this.completer = new OllamaCompleter(this.settings, this.client);
  }
  async availableModels() {
    const response = await this.client.list();
    return response.models.map((model) => model.name);
  }
};

// src/providers/openai/provider.ts
var import_obsidian = require("obsidian");
var OpenAIProvider = class {
  constructor(settings) {
    this.integration = "openai" /* OPENAI */;
    this.name = "Open AI";
    this.loadCompleter = async () => {
    };
    this.settings = settings;
  }
  displaySettings(plugin, containerEl) {
    containerEl.createEl("h3", { text: "OpenAI Settings" });
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Enter the OpenAI API key.").addText(
      (text) => text.setPlaceholder(this.settings.apiKey).setValue(this.settings.apiKey).onChange(async (value) => {
        this.settings.apiKey = value;
        await plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Model").setDesc("Choose the OpenAI model.").addDropdown((dropdown) => {
      dropdown.addOption("gpt-4", "GPT-4").addOption("davinci", "Davinci").setValue(this.settings.model).onChange(async (value) => {
        this.settings.model = value;
        await plugin.saveSettings();
      });
    });
  }
  availableModels() {
    return ["gpt-4", "davinci"];
  }
};

// src/providers/index.ts
var buildProviders = (settings) => {
  return [
    new OllamaProvider(settings.providers.ollama),
    new OpenAIProvider(settings.providers.openai)
  ];
};

// src/settings/settings.ts
var DEFAULT_SETTINGS = {
  provider: "ollama",
  providers: {
    openai: {
      integration: "openai" /* OPENAI */,
      name: "Open AI",
      description: "OpenAI is an artificial intelligence research laboratory consisting of the for-profit OpenAI LP and the non-profit OpenAI Inc.",
      apiKey: "",
      model: "gpt-4",
      models: ["gpt-4", "gpt-3.5-turbo", "gpt-3.5", "gpt-3", "gpt-2", "gpt-1"]
    },
    ollama: {
      integration: "ollama" /* OLLAMA */,
      name: "Ollama",
      description: "Ollama is an AI provider that offers a variety of models for different use cases.",
      host: "http://localhost:11434",
      model: "mistral-nemo",
      models: ["llama3.2:latest", "mistral-nemo"],
      prompt: "You are",
      system_prompt: "You are one son of a gun"
    }
  },
  promtty: true
};
var InscribeSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Provider Settings" });
    new import_obsidian2.Setting(containerEl).setName("AI Provider").setDesc("Choose your preferred AI provider.").addDropdown((dropdown) => {
      dropdown.addOptions(
        Object.fromEntries(Object.entries(this.plugin.settings.providers).map(([key, value]) => [key, value.name]))
      );
      dropdown.setValue(this.plugin.settings.provider).onChange(async (value) => {
        this.plugin.settings.provider = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    switch (this.plugin.settings.provider) {
      case "ollama" /* OLLAMA */:
        await this.displayOllamaSettings();
        break;
      case "openai" /* OPENAI */:
        await this.displayOpenAISettings();
        break;
      default:
        break;
    }
  }
  async displayOllamaSettings() {
    const { containerEl } = this;
    const settings = this.plugin.settings.providers.ollama;
    containerEl.createEl("h3", { text: "Ollama Settings" });
    new import_obsidian2.Setting(containerEl).setName("Host").setDesc("Enter the Ollama host.").addText(
      (text) => text.setPlaceholder(settings.host).setValue(settings.host).onChange(async (value) => {
        settings.host = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Model").setDesc("Choose the Ollama model.").addExtraButton((button) => {
      button.setTooltip("Refresh model list").onClick(async () => {
        settings.models = await this.plugin.provider.availableModels();
        await this.plugin.saveSettings();
        this.display();
      });
    }).addDropdown((dropdown) => {
      dropdown.addOptions(Object.fromEntries(settings.models.map((model) => [model, model]))).setValue(settings.model).onChange(async (value) => {
        settings.model = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
  }
  async displayOpenAISettings() {
    const { containerEl } = this;
    const settings = this.plugin.settings.providers.openai;
    containerEl.createEl("h3", { text: "OpenAI Settings" });
    new import_obsidian2.Setting(containerEl).setName("API Key").setDesc("Enter the OpenAI API key.").addText(
      (text) => text.setPlaceholder(settings.apiKey).setValue(settings.apiKey).onChange(async (value) => {
        settings.apiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Model").setDesc("Choose the OpenAI model.").addDropdown((dropdown) => {
      dropdown.addOptions(Object.fromEntries(settings.models.map((model) => [model, model]))).setValue(settings.model).onChange(async (value) => {
        settings.model = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/main.ts
var Inscribe = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    await this.buildProviders();
    await this.setupExtention();
    this.addSettingTab(new InscribeSettingsTab(this.app, this));
  }
  async buildProviders() {
    this.providers = buildProviders(this.settings);
    const selectedProvider = this.providers.find((provider) => provider.integration === this.settings.provider);
    if (selectedProvider) {
      selectedProvider.loadCompleter();
      this.provider = selectedProvider;
    }
  }
  async setupExtention() {
    const extension = G({
      fetchFn: () => this.fetchSuggestions(),
      delay: 100,
      continue_suggesting: false,
      accept_shortcut: "Tab"
    });
    this.registerEditorExtension(extension);
  }
  async *fetchSuggestions() {
    console.log("triggered fetch");
    const fileInfo = this.app.workspace.activeEditor;
    if (!fileInfo)
      return;
    if (!fileInfo.editor)
      return;
    yield* generateCompletion(fileInfo.editor, this.provider.completer);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.buildProviders();
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAibm9kZV9tb2R1bGVzL2NvZGVtaXJyb3ItY29tcGFuaW9uLWV4dGVuc2lvbi9zcmMvbGliL3V0aWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9jb2RlbWlycm9yLWNvbXBhbmlvbi1leHRlbnNpb24vc3JjL2V4dGVuc2lvbi50cyIsICJzcmMvc2V0dGluZ3Mvc2V0dGluZ3MudHMiLCAic3JjL2NvbXBsZXRpb24vaW5kZXgudHMiLCAic3JjL3Byb3ZpZGVycy9vbGxhbWEvY29tcGxldGVyLnRzIiwgIm5vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCAibm9kZV9tb2R1bGVzL29sbGFtYS9kaXN0L3NoYXJlZC9vbGxhbWEuY2RkYmM4NWIubWpzIiwgIm5vZGVfbW9kdWxlcy9vbGxhbWEvZGlzdC9pbmRleC5tanMiLCAic3JjL3Byb3ZpZGVycy9vbGxhbWEvcHJvdmlkZXIudHMiLCAic3JjL3Byb3ZpZGVycy9vcGVuYWkvcHJvdmlkZXIudHMiLCAic3JjL3Byb3ZpZGVycy9pbmRleC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgaW5saW5lU3VnZ2VzdGlvbiwgU3VnZ2VzdGlvbiB9IGZyb20gXCJjb2RlbWlycm9yLWNvbXBhbmlvbi1leHRlbnNpb25cIjtcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvcHJvdmlkZXInO1xuaW1wb3J0IHsgU2V0dGluZ3MsIERFRkFVTFRfU0VUVElOR1MsIEluc2NyaWJlU2V0dGluZ3NUYWIgfSBmcm9tICcuL3NldHRpbmdzL3NldHRpbmdzJztcbmltcG9ydCB7IGJ1aWxkUHJvdmlkZXJzIH0gZnJvbSAnLi9wcm92aWRlcnMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVDb21wbGV0aW9uIH0gZnJvbSAnLi9jb21wbGV0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5zY3JpYmUgZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogU2V0dGluZ3M7XG5cdHByb3ZpZGVyOiBQcm92aWRlclxuXHRwcm92aWRlcnM6IFByb3ZpZGVyW11cblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblx0XHRhd2FpdCB0aGlzLmJ1aWxkUHJvdmlkZXJzKCk7XG5cdFx0YXdhaXQgdGhpcy5zZXR1cEV4dGVudGlvbigpO1xuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgSW5zY3JpYmVTZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXHR9XG5cblx0YXN5bmMgYnVpbGRQcm92aWRlcnMoKSB7XG5cdFx0dGhpcy5wcm92aWRlcnMgPSBidWlsZFByb3ZpZGVycyh0aGlzLnNldHRpbmdzKTtcblx0XHRjb25zdCBzZWxlY3RlZFByb3ZpZGVyID0gdGhpcy5wcm92aWRlcnMuZmluZChwcm92aWRlciA9PiBwcm92aWRlci5pbnRlZ3JhdGlvbiA9PT0gdGhpcy5zZXR0aW5ncy5wcm92aWRlcik7XG5cdFx0aWYgKHNlbGVjdGVkUHJvdmlkZXIpIHtcblx0XHRcdHNlbGVjdGVkUHJvdmlkZXIubG9hZENvbXBsZXRlcigpO1xuXHRcdFx0dGhpcy5wcm92aWRlciA9IHNlbGVjdGVkUHJvdmlkZXI7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgc2V0dXBFeHRlbnRpb24oKSB7XG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gaW5saW5lU3VnZ2VzdGlvbih7XG5cdFx0XHRmZXRjaEZuOiAoKSA9PiB0aGlzLmZldGNoU3VnZ2VzdGlvbnMoKSxcblx0XHRcdGRlbGF5OiAxMDAsXG5cdFx0XHRjb250aW51ZV9zdWdnZXN0aW5nOiBmYWxzZSxcblx0XHRcdGFjY2VwdF9zaG9ydGN1dDogJ1RhYicsXG5cdFx0fSk7XG5cdFx0dGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbihleHRlbnNpb24pO1xuXHR9XG5cblx0YXN5bmMgKmZldGNoU3VnZ2VzdGlvbnMoKTogQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbiwgdm9pZCwgdW5rbm93bj4ge1xuXHRcdGNvbnNvbGUubG9nKFwidHJpZ2dlcmVkIGZldGNoXCIpO1xuXHRcdGNvbnN0IGZpbGVJbmZvID0gdGhpcy5hcHAud29ya3NwYWNlLmFjdGl2ZUVkaXRvcjtcblx0XHRpZiAoIWZpbGVJbmZvKSByZXR1cm47XG5cdFx0aWYgKCFmaWxlSW5mby5lZGl0b3IpIHJldHVybjtcblxuXHRcdHlpZWxkKiBnZW5lcmF0ZUNvbXBsZXRpb24oZmlsZUluZm8uZWRpdG9yLCB0aGlzLnByb3ZpZGVyLmNvbXBsZXRlcik7XG5cdH1cblxuXHRhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oXG5cdFx0XHR7fSxcblx0XHRcdERFRkFVTFRfU0VUVElOR1MsXG5cdFx0XHRhd2FpdCB0aGlzLmxvYWREYXRhKClcblx0XHQpO1xuXHR9XG5cblxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcblx0XHRhd2FpdCB0aGlzLmJ1aWxkUHJvdmlkZXJzKCk7XG5cdH1cbn0iLCAiLyoqXG4gKiBAcGFyYW0gZiBjYWxsYmFja1xuICogQHBhcmFtIHdhaXQgbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gYWJvcnRWYWx1ZSBpZiBoYXMgYWJvcnRWYWx1ZSwgcHJvbWlzZSB3aWxsIHJlamVjdCBpdCBpZlxuICogQHJldHVybnMgZGVib3VuY2VkOiBQcm9taXNlLCBmb3JjZTogKCkgPT4gdm9pZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2VQcm9taXNlPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gIGZuOiBULFxuICB3YWl0OiBudW1iZXIsXG4gIGFib3J0VmFsdWU6IGFueSA9IHVuZGVmaW5lZFxuKToge1xuICBkZWJvdW5jZWQ6ICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiBQcm9taXNlPEF3YWl0ZWQ8UmV0dXJuVHlwZTxUPj4+O1xuICBmb3JjZTogKCkgPT4gdm9pZDtcbn0ge1xuICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfTtcbiAgY29uc3QgZm9yY2UgPSB7XG4gICAgZm9yY2U6ICgpID0+IHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9LFxuICB9O1xuICAvLyB0eXBlIEF3YWl0ZWQ8VD4gPSBUIGV4dGVuZHMgUHJvbWlzZUxpa2U8aW5mZXIgVT4gPyBVIDogVFxuICB0eXBlIFJldHVyblQgPSBBd2FpdGVkPFJldHVyblR5cGU8VD4+O1xuICBjb25zdCB3cmFwRnVuYyA9ICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KTogUHJvbWlzZTxSZXR1cm5UPiA9PiB7XG4gICAgY2FuY2VsKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKGZuKC4uLmFyZ3MpKSwgd2FpdCk7XG4gICAgICBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIGlmIChhYm9ydFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZWplY3QoYWJvcnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3JjZS5mb3JjZSA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7IGRlYm91bmNlZDogd3JhcEZ1bmMsIGZvcmNlOiAoKSA9PiBmb3JjZS5mb3JjZSgpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZUFzeW5jR2VuZXJhdG9yPFRQYXJhbXMsIFQ+KFxuICBmbjogKC4uLmFyZ3M6IFRQYXJhbXNbXSkgPT4gQXN5bmNHZW5lcmF0b3I8VCwgdm9pZCwgdm9pZD4sXG4gIHdhaXQ6IG51bWJlcixcbiAgYWJvcnRWYWx1ZTogYW55ID0gdW5kZWZpbmVkXG4pOiB7XG4gIGRlYm91bmNlZDogKC4uLmFyZ3M6IFRQYXJhbXNbXSkgPT4gQXN5bmNHZW5lcmF0b3I8VCwgdm9pZCwgdm9pZD47XG4gIGZvcmNlOiAoKSA9PiB2b2lkO1xufSB7XG4gIGNvbnN0IGZvcmNlID0ge1xuICAgIGZvcmNlOiAoKSA9PiB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfSxcbiAgfTtcbiAgbGV0IHRpbWVyOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBhc3luYyBmdW5jdGlvbiogd3JhcEZ1bmMoLi4uYXJnczogVFBhcmFtc1tdKTogQXN5bmNHZW5lcmF0b3I8VCwgdm9pZCwgdm9pZD4ge1xuICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgbGV0IG93bl90aW1lcjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgb3duX3RpbWVyID0gdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoKSwgd2FpdCk7XG4gICAgICAgIGZvcmNlLmZvcmNlID0gKCkgPT4ge1xuICAgICAgICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGFib3J0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBhYm9ydFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBmbiguLi5hcmdzKSkge1xuICAgICAgaWYgKG93bl90aW1lciAhPT0gdGltZXIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB5aWVsZCBpdGVtO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBkZWJvdW5jZWQ6IHdyYXBGdW5jLCBmb3JjZTogKCkgPT4gZm9yY2UuZm9yY2UoKSB9O1xufVxuIiwgImltcG9ydCB7XG4gIFZpZXdQbHVnaW4sXG4gIERlY29yYXRpb25TZXQsXG4gIEVkaXRvclZpZXcsXG4gIFZpZXdVcGRhdGUsXG4gIERlY29yYXRpb24sXG4gIFdpZGdldFR5cGUsXG4gIGtleW1hcCxcbn0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQge1xuICBTdGF0ZUVmZmVjdCxcbiAgVGV4dCxcbiAgUHJlYyxcbiAgU3RhdGVGaWVsZCxcbiAgRWRpdG9yU3RhdGUsXG4gIEVkaXRvclNlbGVjdGlvbixcbiAgVHJhbnNhY3Rpb25TcGVjLFxufSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBkZWJvdW5jZUFzeW5jR2VuZXJhdG9yIH0gZnJvbSAnLi9saWIvdXRpbHMnO1xuXG4vLyBTcGxpdHRpbmcgdGhpcyB1cCB0byBhbGxvdyAgc29tZW9uZSB0byBkaXNwbGF5IGEgd2hvbGUgc2VudGVuY2UgYXMgYSBzdWdnZXN0aW9uXG4vLyB3aGlsZSBvbmx5IGxldHRpbmcgdGhlIHRhYiBrZXkgaW5zZXJ0IHRoZSBuZXh0IHdvcmQgZXRjLlxuZXhwb3J0IHR5cGUgU3VnZ2VzdGlvbiA9IHtcbiAgY29tcGxldGVfc3VnZ2VzdGlvbjogc3RyaW5nO1xuICBkaXNwbGF5X3N1Z2dlc3Rpb246IHN0cmluZztcbiAgYWNjZXB0X2hvb2s/OiAoKSA9PiB2b2lkO1xufTtcblxuLy8gQ3VycmVudCBzdGF0ZSBvZiB0aGUgYXV0b3N1Z2dlc3Rpb25cbmNvbnN0IElubGluZVN1Z2dlc3Rpb25TdGF0ZSA9IFN0YXRlRmllbGQuZGVmaW5lPHtcbiAgc3VnZ2VzdGlvbjogbnVsbCB8IFN1Z2dlc3Rpb247XG59Pih7XG4gIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4geyBzdWdnZXN0aW9uOiBudWxsIH07XG4gIH0sXG4gIHVwZGF0ZShfXzogYW55LCB0cjogYW55KSB7XG4gICAgY29uc3QgaW5saW5lU3VnZ2VzdGlvbiA9IHRyLmVmZmVjdHMuZmluZCgoZTogYW55KSA9PlxuICAgICAgZS5pcyhJbmxpbmVTdWdnZXN0aW9uRWZmZWN0KVxuICAgICk7XG4gICAgaWYgKHRyLnN0YXRlLmRvYylcbiAgICAgIGlmIChcbiAgICAgICAgaW5saW5lU3VnZ2VzdGlvbiAmJlxuICAgICAgICAoaW5saW5lU3VnZ2VzdGlvbi52YWx1ZS5kb2MgPT0gbnVsbCB8fFxuICAgICAgICAgIHRyLnN0YXRlLmRvYyA9PSBpbmxpbmVTdWdnZXN0aW9uLnZhbHVlLmRvYylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4geyBzdWdnZXN0aW9uOiBpbmxpbmVTdWdnZXN0aW9uLnZhbHVlLnN1Z2dlc3Rpb24gfTtcbiAgICAgIH1cbiAgICByZXR1cm4geyBzdWdnZXN0aW9uOiBudWxsIH07XG4gIH0sXG59KTtcblxuY29uc3QgSW5saW5lU3VnZ2VzdGlvbkVmZmVjdCA9IFN0YXRlRWZmZWN0LmRlZmluZTx7XG4gIHN1Z2dlc3Rpb246IFN1Z2dlc3Rpb24gfCBudWxsO1xuICBkb2M6IFRleHQgfCBudWxsO1xufT4oKTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHN1Z2dlc3Rpb24gZm9yIHRoZSBuZXh0IHdvcmRcbiAqL1xuZnVuY3Rpb24gaW5saW5lU3VnZ2VzdGlvbkRlY29yYXRpb24odmlldzogRWRpdG9yVmlldywgcHJlZml4OiBzdHJpbmcpIHtcbiAgY29uc3QgcG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkO1xuICBjb25zdCB3aWRnZXRzID0gW107XG4gIGNvbnN0IHcgPSBEZWNvcmF0aW9uLndpZGdldCh7XG4gICAgd2lkZ2V0OiBuZXcgSW5saW5lU3VnZ2VzdGlvbldpZGdldChwcmVmaXgpLFxuICAgIHNpZGU6IDEsXG4gIH0pO1xuICB3aWRnZXRzLnB1c2gody5yYW5nZShwb3MpKTtcbiAgcmV0dXJuIERlY29yYXRpb24uc2V0KHdpZGdldHMpO1xufVxuXG5jbGFzcyBJbmxpbmVTdWdnZXN0aW9uV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gIHN1Z2dlc3Rpb246IHN0cmluZztcbiAgY29uc3RydWN0b3Ioc3VnZ2VzdGlvbjogc3RyaW5nKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN1Z2dlc3Rpb24gPSBzdWdnZXN0aW9uO1xuICB9XG4gIHRvRE9NKCkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBkaXYuc3R5bGUub3BhY2l0eSA9ICcwLjQnO1xuICAgIGRpdi5jbGFzc05hbWUgPSAnY20taW5saW5lLXN1Z2dlc3Rpb24nO1xuICAgIGRpdi50ZXh0Q29udGVudCA9IHRoaXMuc3VnZ2VzdGlvbjtcbiAgICByZXR1cm4gZGl2O1xuICB9XG59XG5cbnR5cGUgSW5saW5lRmV0Y2hGbiA9IChzdGF0ZTogRWRpdG9yU3RhdGUpID0+IEFzeW5jR2VuZXJhdG9yPFN1Z2dlc3Rpb24+O1xuXG5leHBvcnQgY29uc3QgZmV0Y2hTdWdnZXN0aW9uID0gKGZldGNoRm46IElubGluZUZldGNoRm4pID0+IHtcbiAgbGV0IHN1Z2dlc3Rpb25JZCA9IDA7XG4gIHJldHVybiBWaWV3UGx1Z2luLmZyb21DbGFzcyhcbiAgICBjbGFzcyBGZXRjaFBsdWdpbiB7XG4gICAgICBhc3luYyB1cGRhdGUodXBkYXRlOiBWaWV3VXBkYXRlKSB7XG4gICAgICAgIGNvbnN0IGRvYyA9IHVwZGF0ZS5zdGF0ZS5kb2M7XG4gICAgICAgIC8vIE9ubHkgZmV0Y2ggaWYgdGhlIGRvY3VtZW50IGhhcyBjaGFuZ2VkXG4gICAgICAgIGlmICghdXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFN1Z2dlc3Rpb25JZCA9ICsrc3VnZ2VzdGlvbklkO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHJlc3VsdCBvZiBmZXRjaEZuKHVwZGF0ZS5zdGF0ZSkpIHtcbiAgICAgICAgICBpZiAoY3VycmVudFN1Z2dlc3Rpb25JZCAhPSBzdWdnZXN0aW9uSWQpIHJldHVybjtcbiAgICAgICAgICB1cGRhdGUudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBlZmZlY3RzOiBJbmxpbmVTdWdnZXN0aW9uRWZmZWN0Lm9mKHtcbiAgICAgICAgICAgICAgc3VnZ2VzdGlvbjogcmVzdWx0LFxuICAgICAgICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApO1xufTtcblxuY2xhc3MgUmVuZGVyUGx1Z2luIHtcbiAgZGVjb3JhdGlvbnM6IERlY29yYXRpb25TZXQ7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEVtcHR5IGRlY29yYXRpb25zXG4gICAgdGhpcy5kZWNvcmF0aW9ucyA9IERlY29yYXRpb24ubm9uZTtcbiAgfVxuICB1cGRhdGUodXBkYXRlOiBWaWV3VXBkYXRlKSB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbjogU3VnZ2VzdGlvbiB8IG51bGwgPSB1cGRhdGUuc3RhdGUuZmllbGQoXG4gICAgICBJbmxpbmVTdWdnZXN0aW9uU3RhdGVcbiAgICApPy5zdWdnZXN0aW9uO1xuICAgIGlmICghc3VnZ2VzdGlvbikge1xuICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWNvcmF0aW9ucyA9IGlubGluZVN1Z2dlc3Rpb25EZWNvcmF0aW9uKFxuICAgICAgdXBkYXRlLnZpZXcsXG4gICAgICBzdWdnZXN0aW9uLmRpc3BsYXlfc3VnZ2VzdGlvblxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcmVuZGVySW5saW5lU3VnZ2VzdGlvblBsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKFJlbmRlclBsdWdpbiwge1xuICBkZWNvcmF0aW9uczogKHY6IFJlbmRlclBsdWdpbikgPT4gdi5kZWNvcmF0aW9ucyxcbn0pO1xuXG5jbGFzcyBpbmxpbmVTdWdnZXN0aW9uS2V5bWFwIHtcbiAgc3VnZ2VzdEZuOiBJbmxpbmVGZXRjaEZuIHwgbnVsbDtcbiAga2V5bWFwOiBhbnk7XG4gIGNvbXBsZXRpb25JZDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHN1Z2dlc3RGbjogSW5saW5lRmV0Y2hGbiB8IG51bGwsIGFjY2VwdF9zaG9ydGN1dDogc3RyaW5nKSB7XG4gICAgdGhpcy5zdWdnZXN0Rm4gPSBzdWdnZXN0Rm47XG4gICAgdGhpcy5rZXltYXAgPSBQcmVjLmhpZ2hlc3QoXG4gICAgICBrZXltYXAub2YoW1xuICAgICAgICB7XG4gICAgICAgICAga2V5OiBhY2NlcHRfc2hvcnRjdXQsXG4gICAgICAgICAgcnVuOiAodmlldzogRWRpdG9yVmlldykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuKHZpZXcpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdKVxuICAgICk7XG4gICAgdGhpcy5jb21wbGV0aW9uSWQgPSAwO1xuICB9XG5cbiAgcnVuID0gKHZpZXc6IEVkaXRvclZpZXcpID0+IHtcbiAgICBjb25zdCBzdWdnZXN0aW9uOiBTdWdnZXN0aW9uIHwgbnVsbCA9IHZpZXcuc3RhdGUuZmllbGQoXG4gICAgICBJbmxpbmVTdWdnZXN0aW9uU3RhdGVcbiAgICApPy5zdWdnZXN0aW9uO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gc3VnZ2VzdGlvbiwgZG8gbm90aGluZyBhbmQgbGV0IHRoZSBkZWZhdWx0IGtleW1hcCBoYW5kbGUgaXRcbiAgICBpZiAoIXN1Z2dlc3Rpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgIC4uLmluc2VydENvbXBsZXRpb25UZXh0KFxuICAgICAgICB2aWV3LnN0YXRlLFxuICAgICAgICBzdWdnZXN0aW9uLmNvbXBsZXRlX3N1Z2dlc3Rpb24sXG4gICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCxcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkXG4gICAgICApLFxuICAgIH0pO1xuICAgIHN1Z2dlc3Rpb24uYWNjZXB0X2hvb2s/LigpO1xuXG4gICAgLy8gUmUtdHJpZ2dlciB0aGUgc3VnZ2VzdGlvblxuICAgIGNvbnN0IHJldHJpZ2dlciA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN1Z2dlc3RGbiA9PSBudWxsKSByZXR1cm47XG4gICAgICBjb25zdCBjb21wbGV0aW9uSWQgPSArK3RoaXMuY29tcGxldGlvbklkO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCByZXN1bHQgb2YgdGhpcy5zdWdnZXN0Rm4odmlldy5zdGF0ZSkpIHtcbiAgICAgICAgaWYgKGNvbXBsZXRpb25JZCAhPSB0aGlzLmNvbXBsZXRpb25JZCkgcmV0dXJuO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICBlZmZlY3RzOiBJbmxpbmVTdWdnZXN0aW9uRWZmZWN0Lm9mKHtcbiAgICAgICAgICAgIHN1Z2dlc3Rpb246IHtcbiAgICAgICAgICAgICAgY29tcGxldGVfc3VnZ2VzdGlvbjogcmVzdWx0LmNvbXBsZXRlX3N1Z2dlc3Rpb24sXG4gICAgICAgICAgICAgIGRpc3BsYXlfc3VnZ2VzdGlvbjogcmVzdWx0LmRpc3BsYXlfc3VnZ2VzdGlvbixcbiAgICAgICAgICAgICAgYWNjZXB0X2hvb2s6IHJlc3VsdC5hY2NlcHRfaG9vayxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb2M6IG51bGwsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0cmlnZ2VyKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0Q29tcGxldGlvblRleHQoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdGV4dDogc3RyaW5nLFxuICBmcm9tOiBudW1iZXIsXG4gIHRvOiBudW1iZXJcbik6IFRyYW5zYWN0aW9uU3BlYyB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUuY2hhbmdlQnlSYW5nZSgocmFuZ2UpID0+IHtcbiAgICAgIGlmIChyYW5nZSA9PSBzdGF0ZS5zZWxlY3Rpb24ubWFpbilcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IGZyb20sIHRvOiB0bywgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSArIHRleHQubGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgIGlmIChcbiAgICAgICAgIXJhbmdlLmVtcHR5IHx8XG4gICAgICAgIChsZW4gJiZcbiAgICAgICAgICBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tIC0gbGVuLCByYW5nZS5mcm9tKSAhPVxuICAgICAgICAgICAgc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pKVxuICAgICAgKVxuICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tIC0gbGVuLCB0bzogcmFuZ2UuZnJvbSwgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gLSBsZW4gKyB0ZXh0Lmxlbmd0aCksXG4gICAgICB9O1xuICAgIH0pLFxuICAgIHVzZXJFdmVudDogJ2lucHV0LmNvbXBsZXRlJyxcbiAgfTtcbn1cblxudHlwZSBJbmxpbmVTdWdnZXN0aW9uT3B0aW9ucyA9IHtcbiAgZmV0Y2hGbjogKFxuICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICApID0+IFByb21pc2U8c3RyaW5nIHwgU3VnZ2VzdGlvbj4gfCBBc3luY0dlbmVyYXRvcjxTdWdnZXN0aW9uPjtcbiAgZGVsYXk/OiBudW1iZXI7XG4gIGNvbnRpbnVlX3N1Z2dlc3Rpbmc/OiBib29sZWFuO1xuICBhY2NlcHRfc2hvcnRjdXQ/OiBzdHJpbmcgfCBudWxsO1xufTtcblxuLy8gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmZ1bmN0aW9uIHRvU3VnZ2VzdGlvbihzdWdnZXN0aW9uOiBzdHJpbmcgfCBTdWdnZXN0aW9uKTogU3VnZ2VzdGlvbiB7XG4gIGlmICh0eXBlb2Ygc3VnZ2VzdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGxldGVfc3VnZ2VzdGlvbjogc3VnZ2VzdGlvbixcbiAgICAgIGRpc3BsYXlfc3VnZ2VzdGlvbjogc3VnZ2VzdGlvbixcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdWdnZXN0aW9uO1xufVxuXG5mdW5jdGlvbiB0b1N1Z2dlc3Rpb25GbihcbiAgZmV0Y2hGbjogKFxuICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICApID0+IFByb21pc2U8c3RyaW5nIHwgU3VnZ2VzdGlvbj4gfCBBc3luY0dlbmVyYXRvcjxTdWdnZXN0aW9uPlxuKTogSW5saW5lRmV0Y2hGbiB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiogKHN0YXRlOiBFZGl0b3JTdGF0ZSkge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBhd2FpdCBmZXRjaEZuKHN0YXRlKTtcblxuICAgIC8vIElmIGl0J3MgYSBzdHJpbmcgb3IgYSBTdWdnZXN0aW9uXG4gICAgaWYgKHR5cGVvZiBzdWdnZXN0aW9uID09PSAnc3RyaW5nJyB8fCAnY29tcGxldGVfc3VnZ2VzdGlvbicgaW4gc3VnZ2VzdGlvbikge1xuICAgICAgeWllbGQgdG9TdWdnZXN0aW9uKHN1Z2dlc3Rpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciBhd2FpdCAoY29uc3QgcyBvZiBzdWdnZXN0aW9uKSB7XG4gICAgICB5aWVsZCB0b1N1Z2dlc3Rpb24ocyk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5saW5lU3VnZ2VzdGlvbihvcHRpb25zOiBJbmxpbmVTdWdnZXN0aW9uT3B0aW9ucykge1xuICBjb25zdCB7IGRlbGF5ID0gNTAwLCBhY2NlcHRfc2hvcnRjdXQgPSAnVGFiJyB9ID0gb3B0aW9ucztcbiAgY29uc3QgZmV0Y2hGbiA9IHRvU3VnZ2VzdGlvbkZuKG9wdGlvbnMuZmV0Y2hGbik7XG4gIGNvbnN0IHsgZGVib3VuY2VkOiBkZWJvdW5jZWRfZmV0Y2hGbiB9ID0gZGVib3VuY2VBc3luY0dlbmVyYXRvcihcbiAgICBmZXRjaEZuLFxuICAgIGRlbGF5XG4gICk7XG4gIHJldHVybiBhY2NlcHRfc2hvcnRjdXRcbiAgICA/IFtcbiAgICAgICAgSW5saW5lU3VnZ2VzdGlvblN0YXRlLFxuICAgICAgICBmZXRjaFN1Z2dlc3Rpb24oZGVib3VuY2VkX2ZldGNoRm4pLFxuICAgICAgICByZW5kZXJJbmxpbmVTdWdnZXN0aW9uUGx1Z2luLFxuICAgICAgICBuZXcgaW5saW5lU3VnZ2VzdGlvbktleW1hcChcbiAgICAgICAgICBvcHRpb25zLmNvbnRpbnVlX3N1Z2dlc3RpbmcgPyBmZXRjaEZuIDogbnVsbCxcbiAgICAgICAgICBhY2NlcHRfc2hvcnRjdXRcbiAgICAgICAgKS5rZXltYXAsXG4gICAgICBdXG4gICAgOiBbXG4gICAgICAgIElubGluZVN1Z2dlc3Rpb25TdGF0ZSxcbiAgICAgICAgZmV0Y2hTdWdnZXN0aW9uKGRlYm91bmNlZF9mZXRjaEZuKSxcbiAgICAgICAgcmVuZGVySW5saW5lU3VnZ2VzdGlvblBsdWdpbixcbiAgICAgIF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JjZWFibGVJbmxpbmVTdWdnZXN0aW9uKG9wdGlvbnM6IElubGluZVN1Z2dlc3Rpb25PcHRpb25zKSB7XG4gIGNvbnN0IHsgZGVsYXkgPSA1MDAsIGFjY2VwdF9zaG9ydGN1dCA9ICdUYWInIH0gPSBvcHRpb25zO1xuICBjb25zdCBmZXRjaEZuID0gdG9TdWdnZXN0aW9uRm4ob3B0aW9ucy5mZXRjaEZuKTtcbiAgY29uc3QgeyBkZWJvdW5jZWQ6IGRlYm91bmNlZF9mZXRjaEZuLCBmb3JjZTogZm9yY2VfZmV0Y2ggfSA9XG4gICAgZGVib3VuY2VBc3luY0dlbmVyYXRvcihmZXRjaEZuLCBkZWxheSk7XG4gIHJldHVybiB7XG4gICAgZXh0ZW5zaW9uOiBhY2NlcHRfc2hvcnRjdXRcbiAgICAgID8gW1xuICAgICAgICAgIElubGluZVN1Z2dlc3Rpb25TdGF0ZSxcbiAgICAgICAgICBmZXRjaFN1Z2dlc3Rpb24oZGVib3VuY2VkX2ZldGNoRm4pLFxuICAgICAgICAgIHJlbmRlcklubGluZVN1Z2dlc3Rpb25QbHVnaW4sXG4gICAgICAgICAgbmV3IGlubGluZVN1Z2dlc3Rpb25LZXltYXAoXG4gICAgICAgICAgICBvcHRpb25zLmNvbnRpbnVlX3N1Z2dlc3RpbmcgPyBmZXRjaEZuIDogbnVsbCxcbiAgICAgICAgICAgIGFjY2VwdF9zaG9ydGN1dFxuICAgICAgICAgICkua2V5bWFwLFxuICAgICAgICBdXG4gICAgICA6IFtcbiAgICAgICAgICBJbmxpbmVTdWdnZXN0aW9uU3RhdGUsXG4gICAgICAgICAgZmV0Y2hTdWdnZXN0aW9uKGRlYm91bmNlZF9mZXRjaEZuKSxcbiAgICAgICAgICByZW5kZXJJbmxpbmVTdWdnZXN0aW9uUGx1Z2luLFxuICAgICAgICBdLFxuICAgIGZvcmNlX2ZldGNoOiBmb3JjZV9mZXRjaCxcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBJbnNjcmliZSBmcm9tIFwic3JjL21haW5cIjtcbmltcG9ydCB7IE9sbGFtYVNldHRpbmdzIH0gZnJvbSBcInNyYy9wcm92aWRlcnMvb2xsYW1hXCI7XG5pbXBvcnQgeyBPcGVuQUlTZXR0aW5ncyB9IGZyb20gXCJzcmMvcHJvdmlkZXJzL29wZW5haVwiO1xuaW1wb3J0IHsgSW50ZWdyYXRpb24gfSBmcm9tIFwic3JjL3Byb3ZpZGVyc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNldHRpbmdzIHtcbiAgICBwcm92aWRlcjogc3RyaW5nLFxuICAgIHByb3ZpZGVyczoge1xuICAgICAgICBvbGxhbWE6IE9sbGFtYVNldHRpbmdzLFxuICAgICAgICBvcGVuYWk6IE9wZW5BSVNldHRpbmdzLFxuICAgIH0sXG4gICAgcHJvbXR0eTogYm9vbGVhbixcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFNldHRpbmdzID0ge1xuICAgIHByb3ZpZGVyOiBcIm9sbGFtYVwiLFxuICAgIHByb3ZpZGVyczoge1xuICAgICAgICBvcGVuYWk6IHtcbiAgICAgICAgICAgIGludGVncmF0aW9uOiBJbnRlZ3JhdGlvbi5PUEVOQUksXG4gICAgICAgICAgICBuYW1lOiBcIk9wZW4gQUlcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIk9wZW5BSSBpcyBhbiBhcnRpZmljaWFsIGludGVsbGlnZW5jZSByZXNlYXJjaCBsYWJvcmF0b3J5IGNvbnNpc3Rpbmcgb2YgdGhlIGZvci1wcm9maXQgT3BlbkFJIExQIGFuZCB0aGUgbm9uLXByb2ZpdCBPcGVuQUkgSW5jLlwiLFxuICAgICAgICAgICAgYXBpS2V5OiBcIlwiLFxuICAgICAgICAgICAgbW9kZWw6IFwiZ3B0LTRcIixcbiAgICAgICAgICAgIG1vZGVsczogW1wiZ3B0LTRcIiwgXCJncHQtMy41LXR1cmJvXCIsIFwiZ3B0LTMuNVwiLCBcImdwdC0zXCIsIFwiZ3B0LTJcIiwgXCJncHQtMVwiXSxcbiAgICAgICAgfSxcbiAgICAgICAgb2xsYW1hOiB7XG4gICAgICAgICAgICBpbnRlZ3JhdGlvbjogSW50ZWdyYXRpb24uT0xMQU1BLFxuICAgICAgICAgICAgbmFtZTogXCJPbGxhbWFcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIk9sbGFtYSBpcyBhbiBBSSBwcm92aWRlciB0aGF0IG9mZmVycyBhIHZhcmlldHkgb2YgbW9kZWxzIGZvciBkaWZmZXJlbnQgdXNlIGNhc2VzLlwiLFxuICAgICAgICAgICAgaG9zdDogXCJodHRwOi8vbG9jYWxob3N0OjExNDM0XCIsXG4gICAgICAgICAgICBtb2RlbDogXCJtaXN0cmFsLW5lbW9cIixcbiAgICAgICAgICAgIG1vZGVsczogW1wibGxhbWEzLjI6bGF0ZXN0XCIsIFwibWlzdHJhbC1uZW1vXCJdLFxuICAgICAgICAgICAgcHJvbXB0OiBcIllvdSBhcmVcIixcbiAgICAgICAgICAgIHN5c3RlbV9wcm9tcHQ6IFwiWW91IGFyZSBvbmUgc29uIG9mIGEgZ3VuXCIsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBwcm9tdHR5OiB0cnVlLFxufVxuXG5leHBvcnQgY2xhc3MgSW5zY3JpYmVTZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwcml2YXRlIHBsdWdpbjogSW5zY3JpYmUpIHtcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIH1cblxuICAgIGFzeW5jIGRpc3BsYXkoKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gQUkgUFJPVklERVIgU0VMRUNUT1JcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoMVwiLCB7IHRleHQ6IFwiUHJvdmlkZXIgU2V0dGluZ3NcIiB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQUkgUHJvdmlkZXJcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiQ2hvb3NlIHlvdXIgcHJlZmVycmVkIEFJIHByb3ZpZGVyLlwiKVxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKChkcm9wZG93bikgPT4ge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVycykubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIHZhbHVlLm5hbWVdKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNhc2UgSW50ZWdyYXRpb24uT0xMQU1BOlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzcGxheU9sbGFtYVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEludGVncmF0aW9uLk9QRU5BSTpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc3BsYXlPcGVuQUlTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGRpc3BsYXlPbGxhbWFTZXR0aW5ncygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlcnMub2xsYW1hO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDNcIiwgeyB0ZXh0OiBcIk9sbGFtYSBTZXR0aW5nc1wiIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJIb3N0XCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkVudGVyIHRoZSBPbGxhbWEgaG9zdC5cIilcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKHNldHRpbmdzLmhvc3QpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5ob3N0KVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5ob3N0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJNb2RlbFwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJDaG9vc2UgdGhlIE9sbGFtYSBtb2RlbC5cIilcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbigoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnNldFRvb2x0aXAoXCJSZWZyZXNoIG1vZGVsIGxpc3RcIikub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1vZGVscyA9IGF3YWl0IHRoaXMucGx1Z2luLnByb3ZpZGVyLmF2YWlsYWJsZU1vZGVscygpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKChkcm9wZG93bikgPT4ge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb25zKE9iamVjdC5mcm9tRW50cmllcyhzZXR0aW5ncy5tb2RlbHMubWFwKG1vZGVsID0+IFttb2RlbCwgbW9kZWxdKSkpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5tb2RlbClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBkaXNwbGF5T3BlbkFJU2V0dGluZ3MoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXJzLm9wZW5haTtcblxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJPcGVuQUkgU2V0dGluZ3NcIiB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQVBJIEtleVwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJFbnRlciB0aGUgT3BlbkFJIEFQSSBrZXkuXCIpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihzZXR0aW5ncy5hcGlLZXkpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5hcGlLZXkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFwaUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiTW9kZWxcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiQ2hvb3NlIHRoZSBPcGVuQUkgbW9kZWwuXCIpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oKGRyb3Bkb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbnMoT2JqZWN0LmZyb21FbnRyaWVzKHNldHRpbmdzLm1vZGVscy5tYXAobW9kZWwgPT4gW21vZGVsLCBtb2RlbF0pKSlcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLm1vZGVsKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cbiIsICJpbXBvcnQgeyBTdWdnZXN0aW9uIH0gZnJvbSBcImNvZGVtaXJyb3ItY29tcGFuaW9uLWV4dGVuc2lvblwiO1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBDb21wbGV0ZXIgfSBmcm9tIFwic3JjL3Byb3ZpZGVyc1wiO1xuXG5leHBvcnQgbGV0IGFjdGl2ZUVkaXRvcjogRWRpdG9yO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRlQ29tcGxldGlvbihlZGl0b3I6IEVkaXRvciwgY29tcGxldGVyOiBDb21wbGV0ZXIpOiBBc3luY0dlbmVyYXRvcjxTdWdnZXN0aW9uPiB7XG4gICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgIGFjdGl2ZUVkaXRvciA9IGVkaXRvcjtcblxuICAgIC8vIElmIHRoZSBjdXJyZW50IGxpbmUgaXMgZW1wdHksIGRvbid0IHN1Z2dlc3QgYW55dGhpbmcuXG4gICAgY29uc3QgY3VycmVudExpbmUgPSBlZGl0b3IuZ2V0TGluZShjdXJzb3IubGluZSk7XG4gICAgaWYgKCFjdXJyZW50TGluZS5sZW5ndGgpIHtcbiAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgZGlzcGxheV9zdWdnZXN0aW9uOiBcIlwiLFxuICAgICAgICAgICAgY29tcGxldGVfc3VnZ2VzdGlvbjogXCJcIixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE9ubHkgaWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgc3BhY2Ugb3IgZG90LCBzdWdnZXN0IGNvbXBsZXRpb25zLlxuICAgIGNvbnN0IGxhc3RDaGFyID0gY3VycmVudExpbmVbY3Vyc29yLmNoIC0gMV07XG4gICAgaWYgKGxhc3RDaGFyICE9PSBcIiBcIikge1xuICAgICAgICB5aWVsZCB7IGRpc3BsYXlfc3VnZ2VzdGlvbjogXCJcIiwgY29tcGxldGVfc3VnZ2VzdGlvbjogXCJcIiB9O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWZ0ZXJDdXJzb3IgPSBlZGl0b3IuZ2V0UmFuZ2UoY3Vyc29yLCB7IGxpbmU6IGVkaXRvci5sYXN0TGluZSgpLCBjaDogZWRpdG9yLmdldExpbmUoZWRpdG9yLmxhc3RMaW5lKCkpLmxlbmd0aCB9KTtcbiAgICBjb25zdCBiZWZvcmVDdXJzb3IgPSBlZGl0b3IuZ2V0UmFuZ2UoeyBsaW5lOiAwLCBjaDogMCB9LCBjdXJzb3IpO1xuXG4gICAgLy8gLy8gSWYgdGhlcmUgaXMgdGV4dCBhZnRlciB0aGUgY3Vyc29yLCBzdG9wXG4gICAgLy8gaWYgKGFmdGVyQ3Vyc29yLmxlbmd0aCA+IDApIHtcbiAgICAvLyAgICAgeWllbGQgeyBkaXNwbGF5X3N1Z2dlc3Rpb246IFwiXCIsIGNvbXBsZXRlX3N1Z2dlc3Rpb246IFwiXCIgfTtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIHlpZWxkKiBjb21wbGV0ZXIuZ2VuZXJhdGUoYmVmb3JlQ3Vyc29yLCBhZnRlckN1cnNvcik7XG59XG4iLCAiaW1wb3J0IHsgT2xsYW1hIH0gZnJvbSBcIm9sbGFtYVwiO1xuaW1wb3J0IHsgU3VnZ2VzdGlvbiB9IGZyb20gXCJjb2RlbWlycm9yLWNvbXBhbmlvbi1leHRlbnNpb25cIjtcbmltcG9ydCB7IE9sbGFtYVNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmltcG9ydCB7IENvbXBsZXRlciB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHsgYWN0aXZlRWRpdG9yIH0gZnJvbSBcInNyYy9jb21wbGV0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9sbGFtYUNvbXBsZXRlciBpbXBsZW1lbnRzIENvbXBsZXRlciB7XG4gICAgY2xpZW50OiBPbGxhbWFcbiAgICBzZXR0aW5nczogT2xsYW1hU2V0dGluZ3M7XG4gICAgYWJvcnRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3Ioc2V0dGluczogT2xsYW1hU2V0dGluZ3MsIGNsaWVudDogT2xsYW1hKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5zO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG5cbiAgICBhc3luYyAqZ2VuZXJhdGUocHJlZml4OiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nKTogQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj4ge1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgaW5pdGlhbEN1cnNvciA9IGFjdGl2ZUVkaXRvci5nZXRDdXJzb3IoKTtcblxuICAgICAgICBjb25zdCBjb21wbGV0aW9uSXRlcmF0b3IgPSBhd2FpdCB0aGlzLmNsaWVudC5nZW5lcmF0ZSh7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5zZXR0aW5ncy5tb2RlbCxcbiAgICAgICAgICAgIHByb21wdDogcHJlZml4LFxuICAgICAgICAgICAgc3lzdGVtOiBcInlvdSBhcmUgb25lIHNvbiBvZiBhIGd1blwiLFxuICAgICAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgY29tcGxldGlvbiA9IFwiXCI7XG4gICAgICAgIGZvciBhd2FpdCAobGV0IHJlc3BvbnNlIG9mIGNvbXBsZXRpb25JdGVyYXRvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHsgY29tcGxldGVfc3VnZ2VzdGlvbjogXCJcIiwgZGlzcGxheV9zdWdnZXN0aW9uOiBcIlwiIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3VycmVudEN1cnNvciA9IGFjdGl2ZUVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q3Vyc29yLmxpbmUgIT09IGluaXRpYWxDdXJzb3IubGluZSB8fCBjdXJyZW50Q3Vyc29yLmNoICE9PSBpbml0aWFsQ3Vyc29yLmNoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjdXJzb3IgbW92ZWQsIGFib3J0aW5nIGNvbXBsZXRpb25cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHsgY29tcGxldGVfc3VnZ2VzdGlvbjogXCJcIiwgZGlzcGxheV9zdWdnZXN0aW9uOiBcIlwiIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcGxldGlvbiArPSByZXNwb25zZS5yZXNwb25zZTtcbiAgICAgICAgICAgIHlpZWxkIHsgY29tcGxldGVfc3VnZ2VzdGlvbjogY29tcGxldGlvbiwgZGlzcGxheV9zdWdnZXN0aW9uOiBjb21wbGV0aW9uIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgIHRoaXMuY2xpZW50LmFib3J0KCk7XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiYWJvcnRlZCBjb21wbGV0aW9uXCIpO1xuICAgIH1cbn1cblxuXG4iLCAiLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG52YXIgZyA9XG4gICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbCkgfHxcbiAge31cblxudmFyIHN1cHBvcnQgPSB7XG4gIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gZyxcbiAgaXRlcmFibGU6ICdTeW1ib2wnIGluIGcgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gIGJsb2I6XG4gICAgJ0ZpbGVSZWFkZXInIGluIGcgJiZcbiAgICAnQmxvYicgaW4gZyAmJlxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gZyxcbiAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gZ1xufVxuXG5mdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbn1cblxuaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gIF1cblxuICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPVxuICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgfVxuICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5eX2B8fiFdL2kudGVzdChuYW1lKSB8fCBuYW1lID09PSAnJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiJylcbiAgfVxuICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG5mdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX1cbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvclxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gIHRoaXMubWFwID0ge31cblxuICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIGlmIChoZWFkZXIubGVuZ3RoICE9IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGVhZGVycyBjb25zdHJ1Y3RvcjogZXhwZWN0ZWQgbmFtZS92YWx1ZSBwYWlyIHRvIGJlIGxlbmd0aCAyLCBmb3VuZCcgKyBoZWFkZXIubGVuZ3RoKVxuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG4gICAgfSwgdGhpcylcbiAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgIH0sIHRoaXMpXG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV1cbiAgdGhpcy5tYXBbbmFtZV0gPSBvbGRWYWx1ZSA/IG9sZFZhbHVlICsgJywgJyArIHZhbHVlIDogdmFsdWVcbn1cblxuSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpXG4gICAgfVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgaXRlbXMucHVzaChuYW1lKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpdGVtcy5wdXNoKHZhbHVlKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbmlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgaWYgKGJvZHkuX25vQm9keSkgcmV0dXJuXG4gIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICB9XG4gIGJvZHkuYm9keVVzZWQgPSB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICB9XG4gICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgdmFyIG1hdGNoID0gL2NoYXJzZXQ9KFtBLVphLXowLTlfLV0rKS8uZXhlYyhibG9iLnR5cGUpXG4gIHZhciBlbmNvZGluZyA9IG1hdGNoID8gbWF0Y2hbMV0gOiAndXRmLTgnXG4gIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IsIGVuY29kaW5nKVxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gIH1cbiAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICB9IGVsc2Uge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBCb2R5KCkge1xuICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAvKlxuICAgICAgZmV0Y2gtbW9jayB3cmFwcyB0aGUgUmVzcG9uc2Ugb2JqZWN0IGluIGFuIEVTNiBQcm94eSB0b1xuICAgICAgcHJvdmlkZSB1c2VmdWwgdGVzdCBoYXJuZXNzIGZlYXR1cmVzIHN1Y2ggYXMgZmx1c2guIEhvd2V2ZXIsIG9uXG4gICAgICBFUzUgYnJvd3NlcnMgd2l0aG91dCBmZXRjaCBvciBQcm94eSBzdXBwb3J0IHBvbGx5ZmlsbHMgbXVzdCBiZSB1c2VkO1xuICAgICAgdGhlIHByb3h5LXBvbGx5ZmlsbCBpcyB1bmFibGUgdG8gcHJveHkgYW4gYXR0cmlidXRlIHVubGVzcyBpdCBleGlzdHNcbiAgICAgIG9uIHRoZSBvYmplY3QgYmVmb3JlIHRoZSBQcm94eSBpcyBjcmVhdGVkLiBUaGlzIGNoYW5nZSBlbnN1cmVzXG4gICAgICBSZXNwb25zZS5ib2R5VXNlZCBleGlzdHMgb24gdGhlIGluc3RhbmNlLCB3aGlsZSBtYWludGFpbmluZyB0aGVcbiAgICAgIHNlbWFudGljIG9mIHNldHRpbmcgUmVxdWVzdC5ib2R5VXNlZCBpbiB0aGUgY29uc3RydWN0b3IgYmVmb3JlXG4gICAgICBfaW5pdEJvZHkgaXMgY2FsbGVkLlxuICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgdGhpcy5ib2R5VXNlZCA9IHRoaXMuYm9keVVzZWRcbiAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIHRoaXMuX25vQm9keSA9IHRydWU7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JylcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGlzQ29uc3VtZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKGlzQ29uc3VtZWQpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29uc3VtZWRcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnVmZmVyLnNsaWNlKFxuICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCArIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIGFzIEFycmF5QnVmZmVyJylcbiAgICB9XG4gIH1cblxuICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICB9XG4gIH1cblxuICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG52YXIgbWV0aG9kcyA9IFsnQ09OTkVDVCcsICdERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQQVRDSCcsICdQT1NUJywgJ1BVVCcsICdUUkFDRSddXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICByZXR1cm4gbWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEgPyB1cGNhc2VkIDogbWV0aG9kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICB9XG4gICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWxcbiAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dClcbiAgfVxuXG4gIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJ1xuICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIH1cbiAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdBYm9ydENvbnRyb2xsZXInIGluIGcpIHtcbiAgICAgIHZhciBjdHJsID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgcmV0dXJuIGN0cmwuc2lnbmFsO1xuICAgIH1cbiAgfSgpKTtcbiAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICB9XG4gIHRoaXMuX2luaXRCb2R5KGJvZHkpXG5cbiAgaWYgKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgaWYgKG9wdGlvbnMuY2FjaGUgPT09ICduby1zdG9yZScgfHwgb3B0aW9ucy5jYWNoZSA9PT0gJ25vLWNhY2hlJykge1xuICAgICAgLy8gU2VhcmNoIGZvciBhICdfJyBwYXJhbWV0ZXIgaW4gdGhlIHF1ZXJ5IHN0cmluZ1xuICAgICAgdmFyIHJlUGFyYW1TZWFyY2ggPSAvKFs/Jl0pXz1bXiZdKi9cbiAgICAgIGlmIChyZVBhcmFtU2VhcmNoLnRlc3QodGhpcy51cmwpKSB7XG4gICAgICAgIC8vIElmIGl0IGFscmVhZHkgZXhpc3RzIHRoZW4gc2V0IHRoZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5yZXBsYWNlKHJlUGFyYW1TZWFyY2gsICckMV89JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBhIG5ldyAnXycgcGFyYW1ldGVyIHRvIHRoZSBlbmQgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHZhciByZVF1ZXJ5U3RyaW5nID0gL1xcPy9cbiAgICAgICAgdGhpcy51cmwgKz0gKHJlUXVlcnlTdHJpbmcudGVzdCh0aGlzLnVybCkgPyAnJicgOiAnPycpICsgJ189JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxufVxuXG5mdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gIGJvZHlcbiAgICAudHJpbSgpXG4gICAgLnNwbGl0KCcmJylcbiAgICAuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9JylcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGZvcm1cbn1cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xccj9cXG5bXFx0IF0rL2csICcgJylcbiAgLy8gQXZvaWRpbmcgc3BsaXQgdmlhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgY29tbW9uIElFMTEgYnVnIHdpdGggdGhlIGNvcmUtanMgMy42LjAgcmVnZXggcG9seWZpbGxcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaC9pc3N1ZXMvNzQ4XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy83NTFcbiAgcHJlUHJvY2Vzc2VkSGVhZGVyc1xuICAgIC5zcGxpdCgnXFxyJylcbiAgICAubWFwKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgcmV0dXJuIGhlYWRlci5pbmRleE9mKCdcXG4nKSA9PT0gMCA/IGhlYWRlci5zdWJzdHIoMSwgaGVhZGVyLmxlbmd0aCkgOiBoZWFkZXJcbiAgICB9KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignUmVzcG9uc2UgJyArIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICByZXR1cm4gaGVhZGVyc1xufVxuXG5Cb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbmV4cG9ydCBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzXG4gIGlmICh0aGlzLnN0YXR1cyA8IDIwMCB8fCB0aGlzLnN0YXR1cyA+IDU5OSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzcG9uc2UnOiBUaGUgc3RhdHVzIHByb3ZpZGVkICgwKSBpcyBvdXRzaWRlIHRoZSByYW5nZSBbMjAwLCA1OTldLlwiKVxuICB9XG4gIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgdGhpcy5zdGF0dXNUZXh0ID0gb3B0aW9ucy5zdGF0dXNUZXh0ID09PSB1bmRlZmluZWQgPyAnJyA6ICcnICsgb3B0aW9ucy5zdGF0dXNUZXh0XG4gIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbn1cblxuQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgIHVybDogdGhpcy51cmxcbiAgfSlcbn1cblxuUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDIwMCwgc3RhdHVzVGV4dDogJyd9KVxuICByZXNwb25zZS5vayA9IGZhbHNlXG4gIHJlc3BvbnNlLnN0YXR1cyA9IDBcbiAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbnZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG5SZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbn1cblxuZXhwb3J0IHZhciBET01FeGNlcHRpb24gPSBnLkRPTUV4Y2VwdGlvblxudHJ5IHtcbiAgbmV3IERPTUV4Y2VwdGlvbigpXG59IGNhdGNoIChlcnIpIHtcbiAgRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSwgbmFtZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSlcbiAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2tcbiAgfVxuICBET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBET01FeGNlcHRpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgfVxuXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICBmdW5jdGlvbiBhYm9ydFhocigpIHtcbiAgICAgIHhoci5hYm9ydCgpXG4gICAgfVxuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgfVxuICAgICAgLy8gVGhpcyBjaGVjayBpZiBzcGVjaWZpY2FsbHkgZm9yIHdoZW4gYSB1c2VyIGZldGNoZXMgYSBmaWxlIGxvY2FsbHkgZnJvbSB0aGUgZmlsZSBzeXN0ZW1cbiAgICAgIC8vIE9ubHkgaWYgdGhlIHN0YXR1cyBpcyBvdXQgb2YgYSBub3JtYWwgcmFuZ2VcbiAgICAgIGlmIChyZXF1ZXN0LnVybC5pbmRleE9mKCdmaWxlOi8vJykgPT09IDAgJiYgKHhoci5zdGF0dXMgPCAyMDAgfHwgeGhyLnN0YXR1cyA+IDU5OSkpIHtcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMgPSAyMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpXG4gICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IHRpbWVkIG91dCcpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhVcmwodXJsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXJsID09PSAnJyAmJiBnLmxvY2F0aW9uLmhyZWYgPyBnLmxvY2F0aW9uLmhyZWYgOiB1cmxcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCBmaXhVcmwocmVxdWVzdC51cmwpLCB0cnVlKVxuXG4gICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhocikge1xuICAgICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBzdXBwb3J0LmFycmF5QnVmZmVyXG4gICAgICApIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5pdCAmJiB0eXBlb2YgaW5pdC5oZWFkZXJzID09PSAnb2JqZWN0JyAmJiAhKGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgfHwgKGcuSGVhZGVycyAmJiBpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBnLkhlYWRlcnMpKSkge1xuICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbml0LmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBuYW1lcy5wdXNoKG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIG5vcm1hbGl6ZVZhbHVlKGluaXQuaGVhZGVyc1tuYW1lXSkpXG4gICAgICB9KVxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG5cbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgfSlcbn1cblxuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG5cbmlmICghZy5mZXRjaCkge1xuICBnLmZldGNoID0gZmV0Y2hcbiAgZy5IZWFkZXJzID0gSGVhZGVyc1xuICBnLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIGcuUmVzcG9uc2UgPSBSZXNwb25zZVxufVxuIiwgImltcG9ydCAnd2hhdHdnLWZldGNoJztcblxuY29uc3QgdmVyc2lvbiA9IFwiMC41LjExXCI7XG5cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMShvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlcnJvciwgc3RhdHVzX2NvZGUpIHtcbiAgICBzdXBlcihlcnJvcik7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMuc3RhdHVzX2NvZGUgPSBzdGF0dXNfY29kZTtcbiAgICB0aGlzLm5hbWUgPSBcIlJlc3BvbnNlRXJyb3JcIjtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlc3BvbnNlRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKGFib3J0Q29udHJvbGxlciwgaXRyLCBkb25lQ2FsbGJhY2spIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJhYm9ydENvbnRyb2xsZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaXRyXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImRvbmVDYWxsYmFja1wiKTtcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICB0aGlzLml0ciA9IGl0cjtcbiAgICB0aGlzLmRvbmVDYWxsYmFjayA9IGRvbmVDYWxsYmFjaztcbiAgfVxuICBhYm9ydCgpIHtcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgbWVzc2FnZSBvZiB0aGlzLml0cikge1xuICAgICAgaWYgKFwiZXJyb3JcIiBpbiBtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIG1lc3NhZ2U7XG4gICAgICBpZiAobWVzc2FnZS5kb25lIHx8IG1lc3NhZ2Uuc3RhdHVzID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgICB0aGlzLmRvbmVDYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRpZCBub3QgcmVjZWl2ZSBkb25lIG9yIHN1Y2Nlc3MgcmVzcG9uc2UgaW4gc3RyZWFtLlwiKTtcbiAgfVxufVxuY29uc3QgY2hlY2tPayA9IGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBgRXJyb3IgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcbiAgbGV0IGVycm9yRGF0YSA9IG51bGw7XG4gIGlmIChyZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKT8uaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIG1lc3NhZ2UgPSBlcnJvckRhdGEuZXJyb3IgfHwgbWVzc2FnZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gcGFyc2UgZXJyb3IgcmVzcG9uc2UgYXMgSlNPTlwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiR2V0dGluZyB0ZXh0IGZyb20gcmVzcG9uc2VcIik7XG4gICAgICBjb25zdCB0ZXh0UmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBtZXNzYWdlID0gdGV4dFJlc3BvbnNlIHx8IG1lc3NhZ2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIGdldCB0ZXh0IGZyb20gZXJyb3IgcmVzcG9uc2VcIik7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBSZXNwb25zZUVycm9yKG1lc3NhZ2UsIHJlc3BvbnNlLnN0YXR1cyk7XG59O1xuZnVuY3Rpb24gZ2V0UGxhdGZvcm0oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gYCR7d2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpfSBCcm93c2VyLyR7bmF2aWdhdG9yLnVzZXJBZ2VudH07YDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBgJHtwcm9jZXNzLmFyY2h9ICR7cHJvY2Vzcy5wbGF0Zm9ybX0gTm9kZS5qcy8ke3Byb2Nlc3MudmVyc2lvbn1gO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuY29uc3QgZmV0Y2hXaXRoSGVhZGVycyA9IGFzeW5jIChmZXRjaCwgdXJsLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBcIlVzZXItQWdlbnRcIjogYG9sbGFtYS1qcy8ke3ZlcnNpb259ICgke2dldFBsYXRmb3JtKCl9KWBcbiAgfTtcbiAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSB7fTtcbiAgfVxuICBjb25zdCBjdXN0b21IZWFkZXJzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuaGVhZGVycykuZmlsdGVyKChba2V5XSkgPT4gIU9iamVjdC5rZXlzKGRlZmF1bHRIZWFkZXJzKS5zb21lKChkZWZhdWx0S2V5KSA9PiBkZWZhdWx0S2V5LnRvTG93ZXJDYXNlKCkgPT09IGtleS50b0xvd2VyQ2FzZSgpKSlcbiAgKTtcbiAgb3B0aW9ucy5oZWFkZXJzID0ge1xuICAgIC4uLmRlZmF1bHRIZWFkZXJzLFxuICAgIC4uLmN1c3RvbUhlYWRlcnNcbiAgfTtcbiAgcmV0dXJuIGZldGNoKHVybCwgb3B0aW9ucyk7XG59O1xuY29uc3QgZ2V0ID0gYXN5bmMgKGZldGNoLCBob3N0LCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoSGVhZGVycyhmZXRjaCwgaG9zdCwge1xuICAgIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnNcbiAgfSk7XG4gIGF3YWl0IGNoZWNrT2socmVzcG9uc2UpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuY29uc3QgaGVhZCA9IGFzeW5jIChmZXRjaCwgaG9zdCkgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aEhlYWRlcnMoZmV0Y2gsIGhvc3QsIHtcbiAgICBtZXRob2Q6IFwiSEVBRFwiXG4gIH0pO1xuICBhd2FpdCBjaGVja09rKHJlc3BvbnNlKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbmNvbnN0IHBvc3QgPSBhc3luYyAoZmV0Y2gsIGhvc3QsIGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgaXNSZWNvcmQgPSAoaW5wdXQpID0+IHtcbiAgICByZXR1cm4gaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGlucHV0KTtcbiAgfTtcbiAgY29uc3QgZm9ybWF0dGVkRGF0YSA9IGlzUmVjb3JkKGRhdGEpID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiBkYXRhO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aEhlYWRlcnMoZmV0Y2gsIGhvc3QsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGZvcm1hdHRlZERhdGEsXG4gICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwsXG4gICAgaGVhZGVyczogb3B0aW9ucz8uaGVhZGVyc1xuICB9KTtcbiAgYXdhaXQgY2hlY2tPayhyZXNwb25zZSk7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG5jb25zdCBkZWwgPSBhc3luYyAoZmV0Y2gsIGhvc3QsIGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhIZWFkZXJzKGZldGNoLCBob3N0LCB7XG4gICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnNcbiAgfSk7XG4gIGF3YWl0IGNoZWNrT2socmVzcG9uc2UpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuY29uc3QgcGFyc2VKU09OID0gYXN5bmMgZnVuY3Rpb24qIChpdHIpIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgY29uc3QgcmVhZGVyID0gaXRyLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSwgdmFsdWU6IGNodW5rIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYnVmZmVyICs9IGRlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICBjb25zdCBwYXJ0cyA9IGJ1ZmZlci5zcGxpdChcIlxcblwiKTtcbiAgICBidWZmZXIgPSBwYXJ0cy5wb3AoKSA/PyBcIlwiO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgSlNPTi5wYXJzZShwYXJ0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcImludmFsaWQganNvbjogXCIsIHBhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHBhcnQgb2YgYnVmZmVyLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigocCkgPT4gcCAhPT0gXCJcIikpIHtcbiAgICB0cnkge1xuICAgICAgeWllbGQgSlNPTi5wYXJzZShwYXJ0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiaW52YWxpZCBqc29uOiBcIiwgcGFydCk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgZm9ybWF0SG9zdCA9IChob3N0KSA9PiB7XG4gIGlmICghaG9zdCkge1xuICAgIHJldHVybiBcImh0dHA6Ly8xMjcuMC4wLjE6MTE0MzRcIjtcbiAgfVxuICBsZXQgaXNFeHBsaWNpdFByb3RvY29sID0gaG9zdC5pbmNsdWRlcyhcIjovL1wiKTtcbiAgaWYgKGhvc3Quc3RhcnRzV2l0aChcIjpcIikpIHtcbiAgICBob3N0ID0gYGh0dHA6Ly8xMjcuMC4wLjEke2hvc3R9YDtcbiAgICBpc0V4cGxpY2l0UHJvdG9jb2wgPSB0cnVlO1xuICB9XG4gIGlmICghaXNFeHBsaWNpdFByb3RvY29sKSB7XG4gICAgaG9zdCA9IGBodHRwOi8vJHtob3N0fWA7XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTChob3N0KTtcbiAgbGV0IHBvcnQgPSB1cmwucG9ydDtcbiAgaWYgKCFwb3J0KSB7XG4gICAgaWYgKCFpc0V4cGxpY2l0UHJvdG9jb2wpIHtcbiAgICAgIHBvcnQgPSBcIjExNDM0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcnQgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIjQ0M1wiIDogXCI4MFwiO1xuICAgIH1cbiAgfVxuICBsZXQgZm9ybWF0dGVkSG9zdCA9IGAke3VybC5wcm90b2NvbH0vLyR7dXJsLmhvc3RuYW1lfToke3BvcnR9JHt1cmwucGF0aG5hbWV9YDtcbiAgaWYgKGZvcm1hdHRlZEhvc3QuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgZm9ybWF0dGVkSG9zdCA9IGZvcm1hdHRlZEhvc3Quc2xpY2UoMCwgLTEpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZWRIb3N0O1xufTtcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xubGV0IE9sbGFtYSQxID0gY2xhc3MgT2xsYW1hIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbmZpZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmV0Y2hcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzXCIsIFtdKTtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGhvc3Q6IFwiXCIsXG4gICAgICBoZWFkZXJzOiBjb25maWc/LmhlYWRlcnNcbiAgICB9O1xuICAgIGlmICghY29uZmlnPy5wcm94eSkge1xuICAgICAgdGhpcy5jb25maWcuaG9zdCA9IGZvcm1hdEhvc3QoY29uZmlnPy5ob3N0ID8/IFwiaHR0cDovLzEyNy4wLjAuMToxMTQzNFwiKTtcbiAgICB9XG4gICAgdGhpcy5mZXRjaCA9IGNvbmZpZz8uZmV0Y2ggPz8gZmV0Y2g7XG4gIH1cbiAgLy8gQWJvcnQgYW55IG9uZ29pbmcgc3RyZWFtZWQgcmVxdWVzdHMgdG8gT2xsYW1hXG4gIGFib3J0KCkge1xuICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICAvKipcbiAgICogUHJvY2Vzc2VzIGEgcmVxdWVzdCB0byB0aGUgT2xsYW1hIHNlcnZlci4gSWYgdGhlIHJlcXVlc3QgaXMgc3RyZWFtYWJsZSwgaXQgd2lsbCByZXR1cm4gYVxuICAgKiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHRoZSByZXNwb25zZSBtZXNzYWdlcy4gT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgcmVzcG9uc2VcbiAgICogb2JqZWN0LlxuICAgKiBAcGFyYW0gZW5kcG9pbnQge3N0cmluZ30gLSBUaGUgZW5kcG9pbnQgdG8gc2VuZCB0aGUgcmVxdWVzdCB0by5cbiAgICogQHBhcmFtIHJlcXVlc3Qge29iamVjdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QgdG8gc2VuZCB0byB0aGUgZW5kcG9pbnQuXG4gICAqIEBwcm90ZWN0ZWQge1QgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFQ+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYSBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzXG4gICAqIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgcmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nIG9yIGlmIHRoZSByZXNwb25zZSBpcyBhbiBlcnJvci5cbiAgICogQHJldHVybnMge1Byb21pc2U8VCB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8VD4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYSBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHRoZSBzdHJlYW1lZCByZXNwb25zZS5cbiAgICovXG4gIGFzeW5jIHByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChlbmRwb2ludCwgcmVxdWVzdCkge1xuICAgIHJlcXVlc3Quc3RyZWFtID0gcmVxdWVzdC5zdHJlYW0gPz8gZmFsc2U7XG4gICAgY29uc3QgaG9zdCA9IGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS8ke2VuZHBvaW50fWA7XG4gICAgaWYgKHJlcXVlc3Quc3RyZWFtKSB7XG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGhvc3QsIHJlcXVlc3QsIHtcbiAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2UyLmJvZHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBib2R5XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRyID0gcGFyc2VKU09OKHJlc3BvbnNlMi5ib2R5KTtcbiAgICAgIGNvbnN0IGFib3J0YWJsZUFzeW5jSXRlcmF0b3IgPSBuZXcgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcihcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLFxuICAgICAgICBpdHIsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cy5pbmRleE9mKGFib3J0YWJsZUFzeW5jSXRlcmF0b3IpO1xuICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMucHVzaChhYm9ydGFibGVBc3luY0l0ZXJhdG9yKTtcbiAgICAgIHJldHVybiBhYm9ydGFibGVBc3luY0l0ZXJhdG9yO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgaG9zdCwgcmVxdWVzdCwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICogRW5jb2RlcyBhbiBpbWFnZSB0byBiYXNlNjQgaWYgaXQgaXMgYSBVaW50OEFycmF5LlxuICAqIEBwYXJhbSBpbWFnZSB7VWludDhBcnJheSB8IHN0cmluZ30gLSBUaGUgaW1hZ2UgdG8gZW5jb2RlLlxuICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gVGhlIGJhc2U2NCBlbmNvZGVkIGltYWdlLlxuICAqL1xuICBhc3luYyBlbmNvZGVJbWFnZShpbWFnZSkge1xuICAgIGlmICh0eXBlb2YgaW1hZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShpbWFnZSk7XG4gICAgICBsZXQgYnl0ZVN0cmluZyA9IFwiXCI7XG4gICAgICBjb25zdCBsZW4gPSB1aW50OEFycmF5LmJ5dGVMZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGJ5dGVTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OEFycmF5W2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidG9hKGJ5dGVTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHJlc3BvbnNlIGZyb20gYSB0ZXh0IHByb21wdC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0dlbmVyYXRlUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEdlbmVyYXRlUmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPEdlbmVyYXRlUmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yXG4gICAqIGFuIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgcmVzcG9uc2UgbWVzc2FnZXMuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZShyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QuaW1hZ2VzKSB7XG4gICAgICByZXF1ZXN0LmltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3QuaW1hZ2VzLm1hcCh0aGlzLmVuY29kZUltYWdlLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwiZ2VuZXJhdGVcIiwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIENoYXRzIHdpdGggdGhlIG1vZGVsLiBUaGUgcmVxdWVzdCBvYmplY3QgY2FuIGNvbnRhaW4gbWVzc2FnZXMgd2l0aCBpbWFnZXMgdGhhdCBhcmUgZWl0aGVyXG4gICAqIFVpbnQ4QXJyYXlzIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3MuIFRoZSBpbWFnZXMgd2lsbCBiZSBiYXNlNjQgZW5jb2RlZCBiZWZvcmUgc2VuZGluZyB0aGVcbiAgICogcmVxdWVzdC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0NoYXRSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2hhdFJlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxDaGF0UmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGFuXG4gICAqIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgcmVzcG9uc2UgbWVzc2FnZXMuXG4gICAqL1xuICBhc3luYyBjaGF0KHJlcXVlc3QpIHtcbiAgICBpZiAocmVxdWVzdC5tZXNzYWdlcykge1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHJlcXVlc3QubWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW1hZ2VzKSB7XG4gICAgICAgICAgbWVzc2FnZS5pbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIG1lc3NhZ2UuaW1hZ2VzLm1hcCh0aGlzLmVuY29kZUltYWdlLmJpbmQodGhpcykpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJjaGF0XCIsIHJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG1vZGVsIGZyb20gYSBzdHJlYW0gb2YgZGF0YS5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0NyZWF0ZVJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm9ncmVzc1Jlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxQcm9ncmVzc1Jlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvciBhIHN0cmVhbSBvZiBwcm9ncmVzcyByZXNwb25zZXMuXG4gICAqL1xuICBhc3luYyBjcmVhdGUocmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcImNyZWF0ZVwiLCB7XG4gICAgICBuYW1lOiByZXF1ZXN0Lm1vZGVsLFxuICAgICAgc3RyZWFtOiByZXF1ZXN0LnN0cmVhbSxcbiAgICAgIG1vZGVsZmlsZTogcmVxdWVzdC5tb2RlbGZpbGUsXG4gICAgICBxdWFudGl6ZTogcmVxdWVzdC5xdWFudGl6ZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWxscyBhIG1vZGVsIGZyb20gdGhlIE9sbGFtYSByZWdpc3RyeS4gVGhlIHJlcXVlc3Qgb2JqZWN0IGNhbiBjb250YWluIGEgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlXG4gICAqIHJlc3BvbnNlIHNob3VsZCBiZSBzdHJlYW1lZC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge1B1bGxSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8UHJvZ3Jlc3NSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8UHJvZ3Jlc3NSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3JcbiAgICogYW4gQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIHB1bGwocmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcInB1bGxcIiwge1xuICAgICAgbmFtZTogcmVxdWVzdC5tb2RlbCxcbiAgICAgIHN0cmVhbTogcmVxdWVzdC5zdHJlYW0sXG4gICAgICBpbnNlY3VyZTogcmVxdWVzdC5pbnNlY3VyZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdXNoZXMgYSBtb2RlbCB0byB0aGUgT2xsYW1hIHJlZ2lzdHJ5LiBUaGUgcmVxdWVzdCBvYmplY3QgY2FuIGNvbnRhaW4gYSBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSBpZiB0aGVcbiAgICogcmVzcG9uc2Ugc2hvdWxkIGJlIHN0cmVhbWVkLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7UHVzaFJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm9ncmVzc1Jlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxQcm9ncmVzc1Jlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvclxuICAgKiBhbiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgcHVzaChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwicHVzaFwiLCB7XG4gICAgICBuYW1lOiByZXF1ZXN0Lm1vZGVsLFxuICAgICAgc3RyZWFtOiByZXF1ZXN0LnN0cmVhbSxcbiAgICAgIGluc2VjdXJlOiByZXF1ZXN0Lmluc2VjdXJlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBtb2RlbCBmcm9tIHRoZSBzZXJ2ZXIuIFRoZSByZXF1ZXN0IG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgbmFtZSBvZiB0aGUgbW9kZWwgdG9cbiAgICogZGVsZXRlLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7RGVsZXRlUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFN0YXR1c1Jlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlKHJlcXVlc3QpIHtcbiAgICBhd2FpdCBkZWwoXG4gICAgICB0aGlzLmZldGNoLFxuICAgICAgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2RlbGV0ZWAsXG4gICAgICB7IG5hbWU6IHJlcXVlc3QubW9kZWwgfSxcbiAgICAgIHsgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVycyB9XG4gICAgKTtcbiAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH07XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhIG1vZGVsIGZyb20gb25lIG5hbWUgdG8gYW5vdGhlci4gVGhlIHJlcXVlc3Qgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBuYW1lIG9mIHRoZVxuICAgKiBtb2RlbCB0byBjb3B5IGFuZCB0aGUgbmV3IG5hbWUuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtDb3B5UmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFN0YXR1c1Jlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgY29weShyZXF1ZXN0KSB7XG4gICAgYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvY29weWAsIHsgLi4ucmVxdWVzdCB9LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9O1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgbW9kZWxzIG9uIHRoZSBzZXJ2ZXIuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPExpc3RSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZy5cbiAgICovXG4gIGFzeW5jIGxpc3QoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL3RhZ3NgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgdGhlIG1ldGFkYXRhIG9mIGEgbW9kZWwuIFRoZSByZXF1ZXN0IG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgbmFtZSBvZiB0aGUgbW9kZWwuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtTaG93UmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNob3dSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIHNob3cocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvc2hvd2AsIHtcbiAgICAgIC4uLnJlcXVlc3RcbiAgICB9LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRW1iZWRzIHRleHQgaW5wdXQgaW50byB2ZWN0b3JzLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7RW1iZWRSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8RW1iZWRSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGVtYmVkKHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2VtYmVkYCwge1xuICAgICAgLi4ucmVxdWVzdFxuICAgIH0sIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBFbWJlZHMgYSB0ZXh0IHByb21wdCBpbnRvIGEgdmVjdG9yLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7RW1iZWRkaW5nc1JlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbWJlZGRpbmdzUmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBlbWJlZGRpbmdzKHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2VtYmVkZGluZ3NgLCB7XG4gICAgICAuLi5yZXF1ZXN0XG4gICAgfSwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIHRoZSBydW5uaW5nIG1vZGVscyBvbiB0aGUgc2VydmVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPExpc3RSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZy5cbiAgICovXG4gIGFzeW5jIHBzKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9wc2AsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG59O1xuY29uc3QgYnJvd3NlciA9IG5ldyBPbGxhbWEkMSgpO1xuXG5leHBvcnQgeyBPbGxhbWEkMSBhcyBPLCBicm93c2VyIGFzIGIsIGhlYWQgYXMgaCwgcG9zdCBhcyBwIH07XG4iLCAiaW1wb3J0IHsgTyBhcyBPbGxhbWEkMSwgaCBhcyBoZWFkLCBwIGFzIHBvc3QgfSBmcm9tICcuL3NoYXJlZC9vbGxhbWEuY2RkYmM4NWIubWpzJztcbmltcG9ydCBmcywgeyBwcm9taXNlcywgY3JlYXRlUmVhZFN0cmVhbSB9IGZyb20gJ2ZzJztcbmltcG9ydCB7IHJlc29sdmUsIGpvaW4sIGRpcm5hbWUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgaG9tZWRpciB9IGZyb20gJ29zJztcbmltcG9ydCAnd2hhdHdnLWZldGNoJztcblxuY2xhc3MgT2xsYW1hIGV4dGVuZHMgT2xsYW1hJDEge1xuICBhc3luYyBlbmNvZGVJbWFnZShpbWFnZSkge1xuICAgIGlmICh0eXBlb2YgaW1hZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbWFnZSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhpbWFnZSkpIHtcbiAgICAgICAgY29uc3QgZmlsZUJ1ZmZlciA9IGF3YWl0IHByb21pc2VzLnJlYWRGaWxlKHJlc29sdmUoaW1hZ2UpKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGZpbGVCdWZmZXIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtb2RlbGZpbGUgYW5kIHJlcGxhY2UgdGhlIEZST00gYW5kIEFEQVBURVIgY29tbWFuZHMgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBibG9iIGhhc2hlcy5cbiAgICogQHBhcmFtIG1vZGVsZmlsZSB7c3RyaW5nfSAtIFRoZSBtb2RlbGZpbGUgY29udGVudFxuICAgKiBAcGFyYW0gbWZEaXIge3N0cmluZ30gLSBUaGUgZGlyZWN0b3J5IG9mIHRoZSBtb2RlbGZpbGVcbiAgICogQHByaXZhdGUgQGludGVybmFsXG4gICAqL1xuICBhc3luYyBwYXJzZU1vZGVsZmlsZShtb2RlbGZpbGUsIG1mRGlyID0gcHJvY2Vzcy5jd2QoKSkge1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGNvbnN0IGxpbmVzID0gbW9kZWxmaWxlLnNwbGl0KFwiXFxuXCIpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgY29uc3QgW2NvbW1hbmQsIGFyZ3NdID0gbGluZS5zcGxpdChcIiBcIiwgMik7XG4gICAgICBpZiAoW1wiRlJPTVwiLCBcIkFEQVBURVJcIl0uaW5jbHVkZXMoY29tbWFuZC50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5yZXNvbHZlUGF0aChhcmdzLnRyaW0oKSwgbWZEaXIpO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5maWxlRXhpc3RzKHBhdGgpKSB7XG4gICAgICAgICAgb3V0LnB1c2goYCR7Y29tbWFuZH0gQCR7YXdhaXQgdGhpcy5jcmVhdGVCbG9iKHBhdGgpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dC5wdXNoKGAke2NvbW1hbmR9ICR7YXJnc31gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0LnB1c2gobGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQuam9pbihcIlxcblwiKTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgcGF0aCB0byBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgKiBAcGFyYW0gaW5wdXRQYXRoIHtzdHJpbmd9IC0gVGhlIGlucHV0IHBhdGhcbiAgICogQHBhcmFtIG1mRGlyIHtzdHJpbmd9IC0gVGhlIGRpcmVjdG9yeSBvZiB0aGUgbW9kZWxmaWxlXG4gICAqIEBwcml2YXRlIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVzb2x2ZVBhdGgoaW5wdXRQYXRoLCBtZkRpcikge1xuICAgIGlmIChpbnB1dFBhdGguc3RhcnRzV2l0aChcIn5cIikpIHtcbiAgICAgIHJldHVybiBqb2luKGhvbWVkaXIoKSwgaW5wdXRQYXRoLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmUobWZEaXIsIGlucHV0UGF0aCk7XG4gIH1cbiAgLyoqXG4gICAqIGNoZWNrcyBpZiBhIGZpbGUgZXhpc3RzXG4gICAqIEBwYXJhbSBwYXRoIHtzdHJpbmd9IC0gVGhlIHBhdGggdG8gdGhlIGZpbGVcbiAgICogQHByaXZhdGUgQGludGVybmFsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSAtIFdoZXRoZXIgdGhlIGZpbGUgZXhpc3RzIG9yIG5vdFxuICAgKi9cbiAgYXN5bmMgZmlsZUV4aXN0cyhwYXRoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHByb21pc2VzLmFjY2VzcyhwYXRoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVCbG9iKHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIFJlYWRhYmxlU3RyZWFtID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW1pbmcgdXBsb2FkcyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LlwiKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZVN0cmVhbSA9IGNyZWF0ZVJlYWRTdHJlYW0ocGF0aCk7XG4gICAgY29uc3Qgc2hhMjU2c3VtID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUyLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKFwic2hhMjU2XCIpO1xuICAgICAgZmlsZVN0cmVhbS5vbihcImRhdGFcIiwgKGRhdGEpID0+IGhhc2gudXBkYXRlKGRhdGEpKTtcbiAgICAgIGZpbGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4gcmVzb2x2ZTIoaGFzaC5kaWdlc3QoXCJoZXhcIikpKTtcbiAgICAgIGZpbGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRpZ2VzdCA9IGBzaGEyNTY6JHtzaGEyNTZzdW19YDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaGVhZCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvYmxvYnMvJHtkaWdlc3R9YCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UuaW5jbHVkZXMoXCI0MDRcIikpIHtcbiAgICAgICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGZpbGVTdHJlYW0ub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaWxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaWxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBwb3N0KFxuICAgICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICAgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2Jsb2JzLyR7ZGlnZXN0fWAsXG4gICAgICAgICAgcmVhZGFibGVTdHJlYW1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWdlc3Q7XG4gIH1cbiAgYXN5bmMgY3JlYXRlKHJlcXVlc3QpIHtcbiAgICBsZXQgbW9kZWxmaWxlQ29udGVudCA9IFwiXCI7XG4gICAgaWYgKHJlcXVlc3QucGF0aCkge1xuICAgICAgbW9kZWxmaWxlQ29udGVudCA9IGF3YWl0IHByb21pc2VzLnJlYWRGaWxlKHJlcXVlc3QucGF0aCwgeyBlbmNvZGluZzogXCJ1dGY4XCIgfSk7XG4gICAgICBtb2RlbGZpbGVDb250ZW50ID0gYXdhaXQgdGhpcy5wYXJzZU1vZGVsZmlsZShcbiAgICAgICAgbW9kZWxmaWxlQ29udGVudCxcbiAgICAgICAgZGlybmFtZShyZXF1ZXN0LnBhdGgpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5tb2RlbGZpbGUpIHtcbiAgICAgIG1vZGVsZmlsZUNvbnRlbnQgPSBhd2FpdCB0aGlzLnBhcnNlTW9kZWxmaWxlKHJlcXVlc3QubW9kZWxmaWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBwYXRoIG9yIG1vZGVsZmlsZSB0byBjcmVhdGUgYSBtb2RlbFwiKTtcbiAgICB9XG4gICAgcmVxdWVzdC5tb2RlbGZpbGUgPSBtb2RlbGZpbGVDb250ZW50O1xuICAgIGlmIChyZXF1ZXN0LnN0cmVhbSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZShyZXF1ZXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZShyZXF1ZXN0KTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGluZGV4ID0gbmV3IE9sbGFtYSgpO1xuXG5leHBvcnQgeyBPbGxhbWEsIGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBhZGRJY29uLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBJbnRlZ3JhdGlvbiB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tIFwiLi4vcHJvdmlkZXJcIjtcbmltcG9ydCBPbGxhbWFDb21wbGV0ZXIgZnJvbSBcIi4vY29tcGxldGVyXCI7XG5pbXBvcnQgeyBPbGxhbWFTZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCI7XG5pbXBvcnQgSW5zY3JpYmUgZnJvbSBcInNyYy9tYWluXCI7XG5pbXBvcnQgeyBMaXN0UmVzcG9uc2UsIE1vZGVsUmVzcG9uc2UsIE9sbGFtYSB9IGZyb20gXCJvbGxhbWFcIjtcblxuZXhwb3J0IGNsYXNzIE9sbGFtYVByb3ZpZGVyIGltcGxlbWVudHMgUHJvdmlkZXIge1xuICAgIGludGVncmF0aW9uOiBJbnRlZ3JhdGlvbiA9IEludGVncmF0aW9uLk9MTEFNQTtcbiAgICBuYW1lOiBzdHJpbmcgPSBcIk9sbGFtYVwiO1xuICAgIGRlc2NyaXB0aW9uOiBcIk9sbGFtYSBpcyBhIGxhbmd1YWdlIG1vZGVsIHRoYXQgY2FuIGdlbmVyYXRlIHRleHQgYmFzZWQgb24gYSBwcm9tcHQuXCI7XG4gICAgc2V0dGluZ3M6IE9sbGFtYVNldHRpbmdzO1xuICAgIGNvbXBsZXRlcjogT2xsYW1hQ29tcGxldGVyO1xuICAgIGNsaWVudDogT2xsYW1hO1xuXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IE9sbGFtYVNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5jbGllbnQgPSBuZXcgT2xsYW1hKHsgaG9zdDogdGhpcy5zZXR0aW5ncy5ob3N0IH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWRDb21wbGV0ZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibG9hZGluZyBvbGxhbWEgY29tcGxldGVyXCIpO1xuICAgICAgICB0aGlzLmNvbXBsZXRlciA9IG5ldyBPbGxhbWFDb21wbGV0ZXIodGhpcy5zZXR0aW5ncywgdGhpcy5jbGllbnQpO1xuICAgIH1cblxuICAgIGFzeW5jIGF2YWlsYWJsZU1vZGVscygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlOiBMaXN0UmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5saXN0KCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5tb2RlbHMubWFwKChtb2RlbDogTW9kZWxSZXNwb25zZSkgPT4gbW9kZWwubmFtZSk7XG4gICAgfVxufSIsICJpbXBvcnQgSW5zY3JpYmUgZnJvbSBcInNyYy9tYWluXCI7XG5pbXBvcnQgeyBDb21wbGV0ZXIsIEludGVncmF0aW9uLCBQcm92aWRlciB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHsgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgT3BlbkFJU2V0dGluZ3MgfSBmcm9tIFwiLlwiO1xuXG5leHBvcnQgY2xhc3MgT3BlbkFJUHJvdmlkZXIgaW1wbGVtZW50cyBQcm92aWRlciB7XG4gICAgaW50ZWdyYXRpb246IEludGVncmF0aW9uID0gSW50ZWdyYXRpb24uT1BFTkFJO1xuICAgIG5hbWU6IHN0cmluZyA9IFwiT3BlbiBBSVwiO1xuICAgIGRlc2NyaXB0aW9uOiBcIk9wZW5BSSB0aGUgZXZpbGVzdCBjb21wYW55IGluIHRoZSB3b3JsZFwiO1xuICAgIHNldHRpbmdzOiBPcGVuQUlTZXR0aW5nc1xuICAgIGNvbXBsZXRlcjogQ29tcGxldGVyO1xuICAgIG1vZGVsczogc3RyaW5nW107XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IE9wZW5BSVNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9XG4gICAgbG9hZENvbXBsZXRlcjogKCkgPT4gUHJvbWlzZTx2b2lkPiA9IGFzeW5jICgpID0+IHsgfTtcbiAgICBkaXNwbGF5U2V0dGluZ3MocGx1Z2luOiBJbnNjcmliZSwgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDNcIiwgeyB0ZXh0OiBcIk9wZW5BSSBTZXR0aW5nc1wiIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJBUEkgS2V5XCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkVudGVyIHRoZSBPcGVuQUkgQVBJIGtleS5cIilcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKHRoaXMuc2V0dGluZ3MuYXBpS2V5KVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5hcGlLZXkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuYXBpS2V5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiTW9kZWxcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiQ2hvb3NlIHRoZSBPcGVuQUkgbW9kZWwuXCIpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oKGRyb3Bkb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbihcImdwdC00XCIsIFwiR1BULTRcIilcbiAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbihcImRhdmluY2lcIiwgXCJEYXZpbmNpXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLm1vZGVsKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXZhaWxhYmxlTW9kZWxzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFtcImdwdC00XCIsIFwiZGF2aW5jaVwiXTtcbiAgICB9XG59IiwgImltcG9ydCB7IFNldHRpbmdzIH0gZnJvbSBcInNyYy9zZXR0aW5ncy9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlclwiO1xuaW1wb3J0IHsgT2xsYW1hUHJvdmlkZXIgfSBmcm9tIFwiLi9vbGxhbWFcIjtcbmltcG9ydCB7IE9wZW5BSVByb3ZpZGVyIH0gZnJvbSBcIi4vb3BlbmFpL3Byb3ZpZGVyXCI7XG5cbmV4cG9ydCAqIGZyb20gXCIuL3Byb3ZpZGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jb21wbGV0ZXJcIjtcblxuZXhwb3J0IGVudW0gSW50ZWdyYXRpb24ge1xuICAgIE9MTEFNQSA9IFwib2xsYW1hXCIsXG4gICAgT1BFTkFJID0gXCJvcGVuYWlcIixcbn1cblxuLy8gYnVpbGRlciBmdW5jdGlvbiBmb3IgcHJvdmlkZXJzXG5leHBvcnQgY29uc3QgYnVpbGRQcm92aWRlcnMgPSAoc2V0dGluZ3M6IFNldHRpbmdzKTogUHJvdmlkZXJbXSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IE9sbGFtYVByb3ZpZGVyKHNldHRpbmdzLnByb3ZpZGVycy5vbGxhbWEpLFxuICAgICAgICBuZXcgT3BlbkFJUHJvdmlkZXIoc2V0dGluZ3MucHJvdmlkZXJzLm9wZW5haSksXG4gICAgXTtcbn1cblxuLy8gYnVpbGRlciBmdW5jdGlvbiBmb3IgcHJvdmlkZXJcbmV4cG9ydCBjb25zdCBjcmVhdGVQcm92aWRlciA9IChzZXR0aW5nczogU2V0dGluZ3MpOiBQcm92aWRlciA9PiB7XG4gICAgc3dpdGNoIChzZXR0aW5ncy5wcm92aWRlcikge1xuICAgICAgICBjYXNlIEludGVncmF0aW9uLk9MTEFNQTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2xsYW1hUHJvdmlkZXIoc2V0dGluZ3MucHJvdmlkZXJzLm9sbGFtYSk7XG4gICAgICAgIGNhc2UgSW50ZWdyYXRpb24uT1BFTkFJOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBPcGVuQUlQcm92aWRlcihzZXR0aW5ncy5wcm92aWRlcnMub3BlbmFpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvdmlkZXJcIik7XG4gICAgfVxufVxuXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLG1CQUF1Qjs7Ozs7OztBQzRDaEIsU0FBU0MsRUFDZEMsR0FDQUMsR0FDQUMsSUFBa0IsUUFJbEI7QUFDQSxRQUFNQyxLQUFRO0lBQ1osT0FBTyxNQUFNO0lBRWI7RUFBQTtBQUVGLE1BQUlDLElBQXVCO0FBRTNCLGtCQUFnQkMsS0FBWUMsSUFBZ0Q7QUFDMUVGLFNBQVMsYUFBYUEsQ0FBSztBQUMzQixRQUFJRyxLQUEyQjtBQUUzQixRQUFBO0FBQ0ksWUFBQSxJQUFJLFFBQWMsQ0FBQ0MsTUFBWTtBQUNuQ0QsUUFBQUEsS0FBWUgsSUFBUSxXQUFX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U0FBUyxnQkFBZ0IsS0FBSyxTQUFTLFFBQVE7QUFDeEcsUUFBSSxrQkFBa0I7QUFDckIsdUJBQWlCLGNBQWM7QUFDL0IsV0FBSyxXQUFXO0FBQUEsSUFDakI7QUFBQSxFQUNEO0FBQUEsRUFFQSxNQUFNLGlCQUFpQjtBQUN0QixVQUFNLFlBQVksRUFBaUI7QUFBQSxNQUNsQyxTQUFTLE1BQU0sS0FBSyxpQkFBaUI7QUFBQSxNQUNyQyxPQUFPO0FBQUEsTUFDUCxxQkFBcUI7QUFBQSxNQUNyQixpQkFBaUI7QUFBQSxJQUNsQixDQUFDO0FBQ0QsU0FBSyx3QkFBd0IsU0FBUztBQUFBLEVBQ3ZDO0FBQUEsRUFFQSxPQUFPLG1CQUE4RDtBQUNwRSxZQUFRLElBQUksaUJBQWlCO0FBQzdCLFVBQU0sV0FBVyxLQUFLLElBQUksVUFBVTtBQUNwQyxRQUFJLENBQUM7QUFBVTtBQUNmLFFBQUksQ0FBQyxTQUFTO0FBQVE7QUFFdEIsV0FBTyxtQkFBbUIsU0FBUyxRQUFRLEtBQUssU0FBUyxTQUFTO0FBQUEsRUFDbkU7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNwQixTQUFLLFdBQVcsT0FBTztBQUFBLE1BQ3RCLENBQUM7QUFBQSxNQUNEO0FBQUEsTUFDQSxNQUFNLEtBQUssU0FBUztBQUFBLElBQ3JCO0FBQUEsRUFDRDtBQUFBLEVBR0EsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUNqQyxVQUFNLEtBQUssZUFBZTtBQUFBLEVBQzNCO0FBQ0Q7IiwKICAibmFtZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJkZWJvdW5jZUFzeW5jR2VuZXJhdG9yIiwgImZuIiwgIndhaXQiLCAiYWJvcnRWYWx1ZSIsICJmb3JjZSIsICJ0aW1lciIsICJ3cmFwRnVuYyIsICJhcmdzIiwgIm93bl90aW1lciIsICJyZXNvbHZlIiwgImUiLCAiaXRlbSIsICJJbmxpbmVTdWdnZXN0aW9uU3RhdGUiLCAiU3RhdGVGaWVsZCIsICJfXyIsICJ0ciIsICJpbmxpbmVTdWdnZXN0aW9uIiwgImUiLCAiSW5saW5lU3VnZ2VzdGlvbkVmZmVjdCIsICJTdGF0ZUVmZmVjdCIsICJpbmxpbmVTdWdnZXN0aW9uRGVjb3JhdGlvbiIsICJ2aWV3IiwgInByZWZpeCIsICJwb3MiLCAid2lkZ2V0cyIsICJ3IiwgIkRlY29yYXRpb24iLCAiSW5saW5lU3VnZ2VzdGlvbldpZGdldCIsICJXaWRnZXRUeXBlIiwgInN1Z2dlc3Rpb24iLCAiX19wdWJsaWNGaWVsZCIsICJkaXYiLCAiZmV0Y2hTdWdnZXN0aW9uIiwgImZldGNoRm4iLCAic3VnZ2VzdGlvbklkIiwgIlZpZXdQbHVnaW4iLCAidXBkYXRlIiwgImRvYyIsICJjdXJyZW50U3VnZ2VzdGlvbklkIiwgInJlc3VsdCIsICJSZW5kZXJQbHVnaW4iLCAiX2EiLCAicmVuZGVySW5saW5lU3VnZ2VzdGlvblBsdWdpbiIsICJ2IiwgImlubGluZVN1Z2dlc3Rpb25LZXltYXAiLCAic3VnZ2VzdEZuIiwgImFjY2VwdF9zaG9ydGN1dCIsICJpbnNlcnRDb21wbGV0aW9uVGV4dCIsICJfYiIsICJjb21wbGV0aW9uSWQiLCAiUHJlYyIsICJrZXltYXAiLCAic3RhdGUiLCAidGV4dCIsICJmcm9tIiwgInRvIiwgInJhbmdlIiwgIkVkaXRvclNlbGVjdGlvbiIsICJsZW4iLCAidG9TdWdnZXN0aW9uIiwgInRvU3VnZ2VzdGlvbkZuIiwgIm9wdGlvbnMiLCAiZGVsYXkiLCAiZGVib3VuY2VkX2ZldGNoRm4iLCAiZGVib3VuY2VBc3luY0dlbmVyYXRvciIsICJpbXBvcnRfb2JzaWRpYW4iLCAiZyIsICJyZXNvbHZlIiwgImZldGNoIiwgImZldGNoIiwgInAiLCAiX19kZWZQcm9wIiwgIk9sbGFtYSIsICJmcyIsICJPbGxhbWEiXQp9Cg==
