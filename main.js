/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Inscribe
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/extension/index.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var SplitStrategies = {
  /** Split at word boundaries (space-separated) */
  word: (remaining) => {
    const firstSpace = remaining.indexOf(" ");
    return firstSpace === -1 ? { accept: remaining, remaining: "" } : { accept: remaining.slice(0, firstSpace + 1), remaining: remaining.slice(firstSpace + 1) };
  },
  /** Split at sentence boundaries (punctuation followed by whitespace) */
  sentence: (remaining) => {
    const sentenceEnd = remaining.match(/[.!?]\s+/);
    return sentenceEnd ? { accept: remaining.slice(0, sentenceEnd.index + 1), remaining: remaining.slice(sentenceEnd.index + 1) } : { accept: remaining, remaining: "" };
  },
  /** Split at paragraph boundaries (double newline) */
  paragraph: (remaining) => {
    const paragraphEnd = remaining.indexOf("\n\n");
    return paragraphEnd === -1 ? { accept: remaining, remaining: "" } : { accept: remaining.slice(0, paragraphEnd + 2), remaining: remaining.slice(paragraphEnd + 2) };
  },
  /** Accept entire suggestion at once */
  full: (remaining) => ({ accept: remaining, remaining: "" })
};
var SuggestionEffect = import_state.StateEffect.define();
var SuggestionStateField = import_state.StateField.define({
  create: () => ({
    fullSuggestion: null,
    remainingSuggestion: null,
    originalDocument: null,
    splitStrategy: null,
    originalCursorPos: null
  }),
  update(oldState, transaction) {
    const effect = transaction.effects.find((e) => e.is(SuggestionEffect));
    if (effect) {
      return effect.value.suggestion === null ? {
        // Reset state
        fullSuggestion: null,
        remainingSuggestion: null,
        originalDocument: null,
        splitStrategy: null,
        originalCursorPos: null
      } : {
        // Initialize new suggestion
        fullSuggestion: effect.value.suggestion,
        remainingSuggestion: effect.value.suggestion,
        originalDocument: effect.value.document,
        splitStrategy: effect.value.splitStrategy,
        originalCursorPos: effect.value.originalCursorPos
      };
    }
    if (transaction.docChanged && oldState.remainingSuggestion && oldState.originalCursorPos !== null) {
      let insertedText = "";
      let isInsertionAtCursor = false;
      transaction.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        if (fromA === oldState.originalCursorPos && toA === fromA) {
          insertedText = inserted.toString();
          isInsertionAtCursor = true;
        }
      });
      if (isInsertionAtCursor) {
        if (oldState.remainingSuggestion.startsWith(insertedText)) {
          const newRemaining = oldState.remainingSuggestion.slice(insertedText.length);
          return {
            ...oldState,
            remainingSuggestion: newRemaining || null,
            originalCursorPos: oldState.originalCursorPos + insertedText.length
          };
        } else {
          return { ...oldState, remainingSuggestion: null, originalCursorPos: null };
        }
      } else {
        return { ...oldState, remainingSuggestion: null, originalCursorPos: null };
      }
    }
    return oldState;
  }
});
var SuggestionWidget = class extends import_view.WidgetType {
  constructor(suggestion) {
    super();
    this.suggestion = suggestion;
  }
  toDOM() {
    const element = document.createElement("span");
    element.className = "cm-inline-suggestion";
    element.style.opacity = "0.5";
    element.textContent = this.suggestion;
    return element;
  }
};
function createSuggestionDecoration(view, suggestionText) {
  const cursorPos = view.state.selection.main.head;
  return import_view.Decoration.set([
    import_view.Decoration.widget({
      widget: new SuggestionWidget(suggestionText),
      side: 1
      // Display after cursor position
    }).range(cursorPos)
  ]);
}
var suggestionRenderer = import_view.ViewPlugin.fromClass(
  class {
    constructor() {
      this.decorations = import_view.Decoration.none;
    }
    update(update) {
      const remaining = update.state.field(SuggestionStateField).remainingSuggestion;
      this.decorations = remaining ? createSuggestionDecoration(update.view, remaining) : import_view.Decoration.none;
    }
  },
  { decorations: (v) => v.decorations }
);
function createFetchSystem(fetchFn, delay) {
  let currentRequestId = 0;
  let timeoutId;
  let activeGenerator = true;
  async function* debouncedGenerator(state) {
    clearTimeout(timeoutId);
    activeGenerator = true;
    await new Promise((resolve2) => {
      timeoutId = setTimeout(resolve2, delay);
    });
    if (activeGenerator) {
      yield* fetchFn(state);
    }
  }
  const fetchPlugin = import_view.ViewPlugin.fromClass(
    class {
      async update(update) {
        const state = update.state;
        if (!update.docChanged || state.field(SuggestionStateField).remainingSuggestion)
          return;
        const requestId = ++currentRequestId;
        for await (const suggestion of debouncedGenerator(state)) {
          if (requestId !== currentRequestId)
            return;
          update.view.dispatch({
            effects: SuggestionEffect.of({
              suggestion: suggestion.text,
              splitStrategy: suggestion.splitStrategy,
              document: state.doc,
              originalCursorPos: state.selection.main.head
            })
          });
        }
      }
    }
  );
  return {
    fetchPlugin,
    cancelDebounce: () => {
      activeGenerator = false;
      clearTimeout(timeoutId);
    }
  };
}
function insertSuggestionText(state, text) {
  const cursorPos = state.selection.main.head;
  return {
    ...state.changeByRange((range) => ({
      changes: { from: cursorPos, insert: text },
      range: import_state.EditorSelection.cursor(cursorPos + text.length)
    })),
    userEvent: "input.complete"
  };
}
function createInputHandlers(cancelFetch, acceptKey) {
  return import_state.Prec.highest(
    import_view.keymap.of([{
      key: acceptKey,
      run: (view) => {
        const state = view.state.field(SuggestionStateField);
        if (!state.remainingSuggestion)
          return false;
        const strategyName = state.splitStrategy || "word";
        const splitter = SplitStrategies[strategyName];
        const { accept, remaining } = splitter(state.remainingSuggestion);
        if (!accept)
          return false;
        view.dispatch({
          ...insertSuggestionText(view.state, accept),
          effects: SuggestionEffect.of({
            suggestion: remaining || null,
            document: remaining ? state.originalDocument : null,
            splitStrategy: remaining ? state.splitStrategy : null,
            originalCursorPos: null
          })
        });
        if (!remaining)
          cancelFetch();
        return true;
      }
    }])
  );
}
function inlineSuggestion(options) {
  const { delayMs = 500, acceptShortcut = "Tab", fetchFn: userFetchFn } = options;
  const normalizedFetch = async function* (state) {
    const result = await userFetchFn(state);
    if (Symbol.asyncIterator in result) {
      yield* result;
    } else {
      yield result;
    }
  };
  const { fetchPlugin, cancelDebounce } = createFetchSystem(normalizedFetch, delayMs);
  const suggestionKeymap = createInputHandlers(cancelDebounce, acceptShortcut);
  return [
    SuggestionStateField,
    fetchPlugin,
    suggestionRenderer,
    suggestionKeymap
  ];
}

// src/providers/openai/provider.ts
var OpenAICompleter = class {
  constructor(settings) {
    this.integration = "openai" /* OPENAI */;
    this.name = "Open AI";
    this.settings = settings;
  }
  availableModels() {
    return ["gpt-4", "davinci"];
  }
};

// node_modules/ollama/dist/index.mjs
var import_fs = __toESM(require("fs"), 1);
var import_path = require("path");

// node_modules/whatwg-fetch/fetch.js
var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g,
  iterable: "Symbol" in g && "iterator" in Symbol,
  blob: "FileReader" in g && "Blob" in g && function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: "FormData" in g,
  arrayBuffer: "ArrayBuffer" in g
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve2, reject) {
    reader.onload = function() {
      resolve2(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};
Response.error = function() {
  var response = new Response(null, { status: 200, statusText: "" });
  response.ok = false;
  response.status = 0;
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response(null, { status, headers: { location: url } });
};
var DOMException = g.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch2(input, init) {
  return new Promise(function(resolve2, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve2(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch2.polyfill = true;
if (!g.fetch) {
  g.fetch = fetch2;
  g.Headers = Headers;
  g.Request = Request;
  g.Response = Response;
}

// node_modules/ollama/dist/browser.mjs
var version = "0.5.12";
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ResponseError = class extends Error {
  constructor(error, status_code) {
    super(error);
    this.error = error;
    this.status_code = status_code;
    this.name = "ResponseError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ResponseError);
    }
  }
};
var AbortableAsyncIterator = class {
  constructor(abortController, itr, doneCallback) {
    __publicField$1(this, "abortController");
    __publicField$1(this, "itr");
    __publicField$1(this, "doneCallback");
    this.abortController = abortController;
    this.itr = itr;
    this.doneCallback = doneCallback;
  }
  abort() {
    this.abortController.abort();
  }
  async *[Symbol.asyncIterator]() {
    for await (const message of this.itr) {
      if ("error" in message) {
        throw new Error(message.error);
      }
      yield message;
      if (message.done || message.status === "success") {
        this.doneCallback();
        return;
      }
    }
    throw new Error("Did not receive done or success response in stream.");
  }
};
var checkOk = async (response) => {
  var _a;
  if (response.ok) {
    return;
  }
  let message = `Error ${response.status}: ${response.statusText}`;
  let errorData = null;
  if ((_a = response.headers.get("content-type")) == null ? void 0 : _a.includes("application/json")) {
    try {
      errorData = await response.json();
      message = errorData.error || message;
    } catch (error) {
      console.log("Failed to parse error response as JSON");
    }
  } else {
    try {
      console.log("Getting text from response");
      const textResponse = await response.text();
      message = textResponse || message;
    } catch (error) {
      console.log("Failed to get text from error response");
    }
  }
  throw new ResponseError(message, response.status);
};
function getPlatform() {
  if (typeof window !== "undefined" && window.navigator) {
    return `${window.navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;
  } else if (typeof process !== "undefined") {
    return `${process.arch} ${process.platform} Node.js/${process.version}`;
  }
  return "";
}
var fetchWithHeaders = async (fetch3, url, options = {}) => {
  const defaultHeaders = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "User-Agent": `ollama-js/${version} (${getPlatform()})`
  };
  if (!options.headers) {
    options.headers = {};
  }
  const customHeaders = Object.fromEntries(
    Object.entries(options.headers).filter(([key]) => !Object.keys(defaultHeaders).some((defaultKey) => defaultKey.toLowerCase() === key.toLowerCase()))
  );
  options.headers = {
    ...defaultHeaders,
    ...customHeaders
  };
  return fetch3(url, options);
};
var get = async (fetch3, host, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var post = async (fetch3, host, data, options) => {
  const isRecord = (input) => {
    return input !== null && typeof input === "object" && !Array.isArray(input);
  };
  const formattedData = isRecord(data) ? JSON.stringify(data) : data;
  const response = await fetchWithHeaders(fetch3, host, {
    method: "POST",
    body: formattedData,
    signal: options == null ? void 0 : options.signal,
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var del = async (fetch3, host, data, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    method: "DELETE",
    body: JSON.stringify(data),
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var parseJSON = async function* (itr) {
  var _a;
  const decoder = new TextDecoder("utf-8");
  let buffer = "";
  const reader = itr.getReader();
  while (true) {
    const { done, value: chunk } = await reader.read();
    if (done) {
      break;
    }
    buffer += decoder.decode(chunk);
    const parts = buffer.split("\n");
    buffer = (_a = parts.pop()) != null ? _a : "";
    for (const part of parts) {
      try {
        yield JSON.parse(part);
      } catch (error) {
        console.warn("invalid json: ", part);
      }
    }
  }
  for (const part of buffer.split("\n").filter((p) => p !== "")) {
    try {
      yield JSON.parse(part);
    } catch (error) {
      console.warn("invalid json: ", part);
    }
  }
};
var formatHost = (host) => {
  if (!host) {
    return "http://127.0.0.1:11434";
  }
  let isExplicitProtocol = host.includes("://");
  if (host.startsWith(":")) {
    host = `http://127.0.0.1${host}`;
    isExplicitProtocol = true;
  }
  if (!isExplicitProtocol) {
    host = `http://${host}`;
  }
  const url = new URL(host);
  let port = url.port;
  if (!port) {
    if (!isExplicitProtocol) {
      port = "11434";
    } else {
      port = url.protocol === "https:" ? "443" : "80";
    }
  }
  let formattedHost = `${url.protocol}//${url.hostname}:${port}${url.pathname}`;
  if (formattedHost.endsWith("/")) {
    formattedHost = formattedHost.slice(0, -1);
  }
  return formattedHost;
};
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var Ollama$1 = class Ollama {
  constructor(config) {
    var _a, _b;
    __publicField(this, "config");
    __publicField(this, "fetch");
    __publicField(this, "ongoingStreamedRequests", []);
    this.config = {
      host: "",
      headers: config == null ? void 0 : config.headers
    };
    if (!(config == null ? void 0 : config.proxy)) {
      this.config.host = formatHost((_a = config == null ? void 0 : config.host) != null ? _a : "http://127.0.0.1:11434");
    }
    this.fetch = (_b = config == null ? void 0 : config.fetch) != null ? _b : fetch;
  }
  // Abort any ongoing streamed requests to Ollama
  abort() {
    for (const request of this.ongoingStreamedRequests) {
      request.abort();
    }
    this.ongoingStreamedRequests.length = 0;
  }
  /**
   * Processes a request to the Ollama server. If the request is streamable, it will return a
   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
   * object.
   * @param endpoint {string} - The endpoint to send the request to.
   * @param request {object} - The request object to send to the endpoint.
   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
   * response messages.
   * @throws {Error} - If the response body is missing or if the response is an error.
   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
   */
  async processStreamableRequest(endpoint, request) {
    var _a;
    request.stream = (_a = request.stream) != null ? _a : false;
    const host = `${this.config.host}/api/${endpoint}`;
    if (request.stream) {
      const abortController = new AbortController();
      const response2 = await post(this.fetch, host, request, {
        signal: abortController.signal,
        headers: this.config.headers
      });
      if (!response2.body) {
        throw new Error("Missing body");
      }
      const itr = parseJSON(response2.body);
      const abortableAsyncIterator = new AbortableAsyncIterator(
        abortController,
        itr,
        () => {
          const i = this.ongoingStreamedRequests.indexOf(abortableAsyncIterator);
          if (i > -1) {
            this.ongoingStreamedRequests.splice(i, 1);
          }
        }
      );
      this.ongoingStreamedRequests.push(abortableAsyncIterator);
      return abortableAsyncIterator;
    }
    const response = await post(this.fetch, host, request, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Encodes an image to base64 if it is a Uint8Array.
   * @param image {Uint8Array | string} - The image to encode.
   * @returns {Promise<string>} - The base64 encoded image.
   */
  async encodeImage(image) {
    if (typeof image !== "string") {
      const uint8Array = new Uint8Array(image);
      let byteString = "";
      const len = uint8Array.byteLength;
      for (let i = 0; i < len; i++) {
        byteString += String.fromCharCode(uint8Array[i]);
      }
      return btoa(byteString);
    }
    return image;
  }
  /**
   * Generates a response from a text prompt.
   * @param request {GenerateRequest} - The request object.
   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async generate(request) {
    if (request.images) {
      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));
    }
    return this.processStreamableRequest("generate", request);
  }
  /**
   * Chats with the model. The request object can contain messages with images that are either
   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
   * request.
   * @param request {ChatRequest} - The request object.
   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
   * AbortableAsyncIterator that yields response messages.
   */
  async chat(request) {
    if (request.messages) {
      for (const message of request.messages) {
        if (message.images) {
          message.images = await Promise.all(
            message.images.map(this.encodeImage.bind(this))
          );
        }
      }
    }
    return this.processStreamableRequest("chat", request);
  }
  /**
   * Creates a new model from a stream of data.
   * @param request {CreateRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
   */
  async create(request) {
    return this.processStreamableRequest("create", {
      ...request
    });
  }
  /**
   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PullRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async pull(request) {
    return this.processStreamableRequest("pull", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PushRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async push(request) {
    return this.processStreamableRequest("push", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Deletes a model from the server. The request object should contain the name of the model to
   * delete.
   * @param request {DeleteRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async delete(request) {
    await del(
      this.fetch,
      `${this.config.host}/api/delete`,
      { name: request.model },
      { headers: this.config.headers }
    );
    return { status: "success" };
  }
  /**
   * Copies a model from one name to another. The request object should contain the name of the
   * model to copy and the new name.
   * @param request {CopyRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async copy(request) {
    await post(this.fetch, `${this.config.host}/api/copy`, { ...request }, {
      headers: this.config.headers
    });
    return { status: "success" };
  }
  /**
   * Lists the models on the server.
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async list() {
    const response = await get(this.fetch, `${this.config.host}/api/tags`, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Shows the metadata of a model. The request object should contain the name of the model.
   * @param request {ShowRequest} - The request object.
   * @returns {Promise<ShowResponse>} - The response object.
   */
  async show(request) {
    const response = await post(this.fetch, `${this.config.host}/api/show`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds text input into vectors.
   * @param request {EmbedRequest} - The request object.
   * @returns {Promise<EmbedResponse>} - The response object.
   */
  async embed(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embed`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds a text prompt into a vector.
   * @param request {EmbeddingsRequest} - The request object.
   * @returns {Promise<EmbeddingsResponse>} - The response object.
   */
  async embeddings(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Lists the running models on the server
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async ps() {
    const response = await get(this.fetch, `${this.config.host}/api/ps`, {
      headers: this.config.headers
    });
    return await response.json();
  }
};
var browser = new Ollama$1();

// node_modules/ollama/dist/index.mjs
var Ollama2 = class extends Ollama$1 {
  async encodeImage(image) {
    if (typeof image !== "string") {
      return Buffer.from(image).toString("base64");
    }
    try {
      if (import_fs.default.existsSync(image)) {
        const fileBuffer = await import_fs.promises.readFile((0, import_path.resolve)(image));
        return Buffer.from(fileBuffer).toString("base64");
      }
    } catch (e) {
    }
    return image;
  }
  /**
   * checks if a file exists
   * @param path {string} - The path to the file
   * @private @internal
   * @returns {Promise<boolean>} - Whether the file exists or not
   */
  async fileExists(path) {
    try {
      await import_fs.promises.access(path);
      return true;
    } catch (e) {
      return false;
    }
  }
  async create(request) {
    if (request.from && await this.fileExists((0, import_path.resolve)(request.from))) {
      throw Error("Creating with a local path is not currently supported from ollama-js");
    }
    if (request.stream) {
      return super.create(request);
    } else {
      return super.create(request);
    }
  }
};
var index = new Ollama2();

// node_modules/mustache/mustache.mjs
var objectToString = Object.prototype.toString;
var isArray = Array.isArray || function isArrayPolyfill(object) {
  return objectToString.call(object) === "[object Array]";
};
function isFunction(object) {
  return typeof object === "function";
}
function typeStr(obj) {
  return isArray(obj) ? "array" : typeof obj;
}
function escapeRegExp(string) {
  return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function hasProperty(obj, propName) {
  return obj != null && typeof obj === "object" && propName in obj;
}
function primitiveHasOwnProperty(primitive, propName) {
  return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
}
var regExpTest = RegExp.prototype.test;
function testRegExp(re, string) {
  return regExpTest.call(re, string);
}
var nonSpaceRe = /\S/;
function isWhitespace(string) {
  return !testRegExp(nonSpaceRe, string);
}
var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(string) {
  return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
    return entityMap[s];
  });
}
var whiteRe = /\s*/;
var spaceRe = /\s+/;
var equalsRe = /\s*=/;
var curlyRe = /\s*\}/;
var tagRe = /#|\^|\/|>|\{|&|=|!/;
function parseTemplate(template, tags) {
  if (!template)
    return [];
  var lineHasNonSpace = false;
  var sections = [];
  var tokens = [];
  var spaces = [];
  var hasTag = false;
  var nonSpace = false;
  var indentation = "";
  var tagIndex = 0;
  function stripSpace() {
    if (hasTag && !nonSpace) {
      while (spaces.length)
        delete tokens[spaces.pop()];
    } else {
      spaces = [];
    }
    hasTag = false;
    nonSpace = false;
  }
  var openingTagRe, closingTagRe, closingCurlyRe;
  function compileTags(tagsToCompile) {
    if (typeof tagsToCompile === "string")
      tagsToCompile = tagsToCompile.split(spaceRe, 2);
    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
      throw new Error("Invalid tags: " + tagsToCompile);
    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
    closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
    closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
  }
  compileTags(tags || mustache.tags);
  var scanner = new Scanner(template);
  var start, type, value, chr, token, openSection;
  while (!scanner.eos()) {
    start = scanner.pos;
    value = scanner.scanUntil(openingTagRe);
    if (value) {
      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
        chr = value.charAt(i);
        if (isWhitespace(chr)) {
          spaces.push(tokens.length);
          indentation += chr;
        } else {
          nonSpace = true;
          lineHasNonSpace = true;
          indentation += " ";
        }
        tokens.push(["text", chr, start, start + 1]);
        start += 1;
        if (chr === "\n") {
          stripSpace();
          indentation = "";
          tagIndex = 0;
          lineHasNonSpace = false;
        }
      }
    }
    if (!scanner.scan(openingTagRe))
      break;
    hasTag = true;
    type = scanner.scan(tagRe) || "name";
    scanner.scan(whiteRe);
    if (type === "=") {
      value = scanner.scanUntil(equalsRe);
      scanner.scan(equalsRe);
      scanner.scanUntil(closingTagRe);
    } else if (type === "{") {
      value = scanner.scanUntil(closingCurlyRe);
      scanner.scan(curlyRe);
      scanner.scanUntil(closingTagRe);
      type = "&";
    } else {
      value = scanner.scanUntil(closingTagRe);
    }
    if (!scanner.scan(closingTagRe))
      throw new Error("Unclosed tag at " + scanner.pos);
    if (type == ">") {
      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
    } else {
      token = [type, value, start, scanner.pos];
    }
    tagIndex++;
    tokens.push(token);
    if (type === "#" || type === "^") {
      sections.push(token);
    } else if (type === "/") {
      openSection = sections.pop();
      if (!openSection)
        throw new Error('Unopened section "' + value + '" at ' + start);
      if (openSection[1] !== value)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
    } else if (type === "name" || type === "{" || type === "&") {
      nonSpace = true;
    } else if (type === "=") {
      compileTags(value);
    }
  }
  stripSpace();
  openSection = sections.pop();
  if (openSection)
    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
  return nestTokens(squashTokens(tokens));
}
function squashTokens(tokens) {
  var squashedTokens = [];
  var token, lastToken;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    if (token) {
      if (token[0] === "text" && lastToken && lastToken[0] === "text") {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        squashedTokens.push(token);
        lastToken = token;
      }
    }
  }
  return squashedTokens;
}
function nestTokens(tokens) {
  var nestedTokens = [];
  var collector = nestedTokens;
  var sections = [];
  var token, section;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    switch (token[0]) {
      case "#":
      case "^":
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case "/":
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
    }
  }
  return nestedTokens;
}
function Scanner(string) {
  this.string = string;
  this.tail = string;
  this.pos = 0;
}
Scanner.prototype.eos = function eos() {
  return this.tail === "";
};
Scanner.prototype.scan = function scan(re) {
  var match = this.tail.match(re);
  if (!match || match.index !== 0)
    return "";
  var string = match[0];
  this.tail = this.tail.substring(string.length);
  this.pos += string.length;
  return string;
};
Scanner.prototype.scanUntil = function scanUntil(re) {
  var index2 = this.tail.search(re), match;
  switch (index2) {
    case -1:
      match = this.tail;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, index2);
      this.tail = this.tail.substring(index2);
  }
  this.pos += match.length;
  return match;
};
function Context(view, parentContext) {
  this.view = view;
  this.cache = { ".": this.view };
  this.parent = parentContext;
}
Context.prototype.push = function push(view) {
  return new Context(view, this);
};
Context.prototype.lookup = function lookup(name) {
  var cache = this.cache;
  var value;
  if (cache.hasOwnProperty(name)) {
    value = cache[name];
  } else {
    var context = this, intermediateValue, names, index2, lookupHit = false;
    while (context) {
      if (name.indexOf(".") > 0) {
        intermediateValue = context.view;
        names = name.split(".");
        index2 = 0;
        while (intermediateValue != null && index2 < names.length) {
          if (index2 === names.length - 1)
            lookupHit = hasProperty(intermediateValue, names[index2]) || primitiveHasOwnProperty(intermediateValue, names[index2]);
          intermediateValue = intermediateValue[names[index2++]];
        }
      } else {
        intermediateValue = context.view[name];
        lookupHit = hasProperty(context.view, name);
      }
      if (lookupHit) {
        value = intermediateValue;
        break;
      }
      context = context.parent;
    }
    cache[name] = value;
  }
  if (isFunction(value))
    value = value.call(this.view);
  return value;
};
function Writer() {
  this.templateCache = {
    _cache: {},
    set: function set(key, value) {
      this._cache[key] = value;
    },
    get: function get2(key) {
      return this._cache[key];
    },
    clear: function clear() {
      this._cache = {};
    }
  };
}
Writer.prototype.clearCache = function clearCache() {
  if (typeof this.templateCache !== "undefined") {
    this.templateCache.clear();
  }
};
Writer.prototype.parse = function parse(template, tags) {
  var cache = this.templateCache;
  var cacheKey = template + ":" + (tags || mustache.tags).join(":");
  var isCacheEnabled = typeof cache !== "undefined";
  var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
  if (tokens == void 0) {
    tokens = parseTemplate(template, tags);
    isCacheEnabled && cache.set(cacheKey, tokens);
  }
  return tokens;
};
Writer.prototype.render = function render(template, view, partials, config) {
  var tags = this.getConfigTags(config);
  var tokens = this.parse(template, tags);
  var context = view instanceof Context ? view : new Context(view, void 0);
  return this.renderTokens(tokens, context, partials, template, config);
};
Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
  var buffer = "";
  var token, symbol, value;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    value = void 0;
    token = tokens[i];
    symbol = token[0];
    if (symbol === "#")
      value = this.renderSection(token, context, partials, originalTemplate, config);
    else if (symbol === "^")
      value = this.renderInverted(token, context, partials, originalTemplate, config);
    else if (symbol === ">")
      value = this.renderPartial(token, context, partials, config);
    else if (symbol === "&")
      value = this.unescapedValue(token, context);
    else if (symbol === "name")
      value = this.escapedValue(token, context, config);
    else if (symbol === "text")
      value = this.rawValue(token);
    if (value !== void 0)
      buffer += value;
  }
  return buffer;
};
Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
  var self2 = this;
  var buffer = "";
  var value = context.lookup(token[1]);
  function subRender(template) {
    return self2.render(template, context, partials, config);
  }
  if (!value)
    return;
  if (isArray(value)) {
    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
    }
  } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
  } else if (isFunction(value)) {
    if (typeof originalTemplate !== "string")
      throw new Error("Cannot use higher-order sections without the original template");
    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
    if (value != null)
      buffer += value;
  } else {
    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
  }
  return buffer;
};
Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
  var value = context.lookup(token[1]);
  if (!value || isArray(value) && value.length === 0)
    return this.renderTokens(token[4], context, partials, originalTemplate, config);
};
Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
  var filteredIndentation = indentation.replace(/[^ \t]/g, "");
  var partialByNl = partial.split("\n");
  for (var i = 0; i < partialByNl.length; i++) {
    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
      partialByNl[i] = filteredIndentation + partialByNl[i];
    }
  }
  return partialByNl.join("\n");
};
Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
  if (!partials)
    return;
  var tags = this.getConfigTags(config);
  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
  if (value != null) {
    var lineHasNonSpace = token[6];
    var tagIndex = token[5];
    var indentation = token[4];
    var indentedValue = value;
    if (tagIndex == 0 && indentation) {
      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
    }
    var tokens = this.parse(indentedValue, tags);
    return this.renderTokens(tokens, context, partials, indentedValue, config);
  }
};
Writer.prototype.unescapedValue = function unescapedValue(token, context) {
  var value = context.lookup(token[1]);
  if (value != null)
    return value;
};
Writer.prototype.escapedValue = function escapedValue(token, context, config) {
  var escape = this.getConfigEscape(config) || mustache.escape;
  var value = context.lookup(token[1]);
  if (value != null)
    return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
};
Writer.prototype.rawValue = function rawValue(token) {
  return token[1];
};
Writer.prototype.getConfigTags = function getConfigTags(config) {
  if (isArray(config)) {
    return config;
  } else if (config && typeof config === "object") {
    return config.tags;
  } else {
    return void 0;
  }
};
Writer.prototype.getConfigEscape = function getConfigEscape(config) {
  if (config && typeof config === "object" && !isArray(config)) {
    return config.escape;
  } else {
    return void 0;
  }
};
var mustache = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  /**
   * Allows a user to override the default caching strategy, by providing an
   * object with set, get and clear methods. This can also be used to disable
   * the cache by setting it to the literal `undefined`.
   */
  set templateCache(cache) {
    defaultWriter.templateCache = cache;
  },
  /**
   * Gets the default or overridden caching object from the default writer.
   */
  get templateCache() {
    return defaultWriter.templateCache;
  }
};
var defaultWriter = new Writer();
mustache.clearCache = function clearCache2() {
  return defaultWriter.clearCache();
};
mustache.parse = function parse2(template, tags) {
  return defaultWriter.parse(template, tags);
};
mustache.render = function render2(template, view, partials, config) {
  if (typeof template !== "string") {
    throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
  }
  return defaultWriter.render(template, view, partials, config);
};
mustache.escape = escapeHtml;
mustache.Scanner = Scanner;
mustache.Context = Context;
mustache.Writer = Writer;
var mustache_default = mustache;

// src/completion/prompt.ts
var TEMPLATE_VARIABLES = `{{pre_cursor}}
{{post_cursor}} 
{{active_sentence}} 
{{last_line}}`;
function buildPrompt(template, args) {
  return mustache_default.render(template, args);
}
function preparePrompt(editor, template = TEMPLATE_VARIABLES) {
  const cursor = editor.getCursor();
  const preCursor = editor.getRange({ line: 0, ch: 0 }, cursor);
  const postCursor = editor.getRange(cursor, { line: editor.lastLine(), ch: editor.getLine(editor.lastLine()).length });
  const activeSentence = sentenceAtCursor(editor);
  const lastLine = editor.getLine(editor.lastLine());
  return buildPrompt(template, {
    pre_cursor: preCursor,
    post_cursor: postCursor,
    active_sentence: activeSentence,
    last_line: lastLine
  });
}
function sentenceAtCursor(editor) {
  const cursor = editor.getCursor();
  let currentLine = cursor.line;
  let sentenceLines = [editor.getLine(currentLine)];
  while (currentLine > 0) {
    currentLine--;
    const line = editor.getLine(currentLine);
    if (/[.!?]\s*$/.test(line)) {
      break;
    }
    sentenceLines.unshift(line);
  }
  return sentenceLines.join(" ").replace(/\s+/g, " ").trim();
}

// src/providers/ollama/completer.ts
var OllamaCompleter = class {
  constructor(settins) {
    this.integration = "ollama" /* OLLAMA */;
    this.aborted = false;
    this.settings = settins;
    this.client = new Ollama2({ host: this.settings.host });
  }
  async *generate(editor) {
    this.aborted = false;
    const prompt = preparePrompt(editor, this.settings.user_prompt);
    const completionIterator = await this.client.generate({
      model: this.settings.model,
      prompt,
      system: this.settings.system_prompt,
      stream: true
    });
    const initialPosition = editor.getCursor();
    let completion = "";
    for await (let response of completionIterator) {
      if (this.aborted) {
        return;
      }
      const currentPosition = editor.getCursor();
      if (currentPosition.line !== initialPosition.line || currentPosition.ch !== initialPosition.ch) {
        console.log("cursor moved, aborting completion");
        this.abort();
        return;
      }
      completion += response.response;
      yield completion;
    }
  }
  async abort() {
    if (this.aborted)
      return;
    this.client.abort();
    this.aborted = true;
    console.log("aborted completion");
  }
  async availableModels() {
    const response = await this.client.list();
    return response.models.map((model) => model.name);
  }
};

// src/providers/index.ts
var buildCompleter = (settings) => {
  switch (settings.provider) {
    case "ollama" /* OLLAMA */:
      return new OllamaCompleter(settings.providers.ollama);
    case "openai" /* OPENAI */:
      return new OpenAICompleter(settings.providers.openai);
    default:
      throw new Error("Invalid provider");
  }
};

// src/settings/index.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  provider: "ollama",
  providers: {
    openai: {
      integration: "openai" /* OPENAI */,
      name: "Open AI",
      description: "Use OpenAI APIs to generate text.",
      apiKey: "",
      model: "gpt-4o",
      models: ["gpt-4", "gpt-3.5-turbo", "gpt-3.5", "gpt-3", "gpt-2", "gpt-1"]
    },
    ollama: {
      integration: "ollama" /* OLLAMA */,
      name: "Ollama",
      description: "Use your own Ollama instance to generate text.",
      host: "http://localhost:11434",
      model: "mistral-nemo",
      models: ["llama3.2:latest", "mistral-nemo"],
      user_prompt: "Complete following text:\n {{pre_cursor}}}",
      system_prompt: "You are an helpful AI completer. Follow instructions"
    }
  },
  delay_ms: 500,
  splitStrategy: "word"
};
var InscribeSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    await this.displayGeneralSettings();
    switch (this.plugin.settings.provider) {
      case "ollama" /* OLLAMA */:
        await this.displayOllamaSettings();
        break;
      case "openai" /* OPENAI */:
        await this.displayOpenAISettings();
        break;
      default:
        break;
    }
  }
  async displayGeneralSettings() {
    const { containerEl } = this;
    const settings = this.plugin.settings;
    containerEl.createEl("h1", { text: "General" });
    new import_obsidian.Setting(containerEl).setName("AI Provider").setDesc("Choose your preferred AI provider.").addDropdown((dropdown) => {
      dropdown.addOptions(
        Object.fromEntries(Object.entries(this.plugin.settings.providers).map(([key, value]) => [key, value.name]))
      );
      dropdown.setValue(this.plugin.settings.provider).onChange(async (value) => {
        this.plugin.settings.provider = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Delay (ms)").setDesc("Set the delay in milliseconds before fetching suggestions.").addText((text) => {
      text.inputEl.setAttrs({ type: "number", min: "0" });
      text.setPlaceholder(settings.delay_ms.toString()).setValue(settings.delay_ms.toString()).onChange(async (value) => {
        settings.delay_ms = parseInt(value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Accept Strategy").setDesc("Choose the accept strategy.").addDropdown((dropdown) => {
      dropdown.addOptions({
        "word": "Word",
        "sentence": "Sentence",
        "paragraph": "Paragraph",
        "full": "Full"
      });
      dropdown.setValue(this.plugin.settings.splitStrategy).onChange(async (value) => {
        this.plugin.settings.splitStrategy = value;
        await this.plugin.saveSettings();
      });
    });
  }
  async displayOllamaSettings() {
    const { containerEl } = this;
    const settings = this.plugin.settings.providers.ollama;
    containerEl.createEl("h3", { text: "Ollama Settings" });
    new import_obsidian.Setting(containerEl).setName("Host").setDesc("Enter the Ollama host.").addText(
      (text) => text.setPlaceholder(settings.host).setValue(settings.host).onChange(async (value) => {
        settings.host = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Model").setDesc("Choose the Ollama model.").addExtraButton((button) => {
      button.setTooltip("Refresh model list").onClick(async () => {
        settings.models = await this.plugin.completer.availableModels();
        await this.plugin.saveSettings();
        this.display();
      });
    }).addDropdown((dropdown) => {
      dropdown.addOptions(Object.fromEntries(settings.models.map((model) => [model, model]))).setValue(settings.model).onChange(async (value) => {
        settings.model = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("User Prompt").setDesc("Enter the user prompt.").addExtraButton((button) => {
      button.setTooltip("Insert variables").onClick(() => {
        settings.user_prompt = `${settings.user_prompt}
${TEMPLATE_VARIABLES}`;
        this.display();
      });
    }).addTextArea(
      (text) => {
        text.inputEl.setAttr("rows", "5");
        text.inputEl.setCssStyles({ width: "100%", resize: "vertical", position: "relative" });
        text.setPlaceholder(settings.user_prompt).setValue(settings.user_prompt).onChange(async (value) => {
          settings.user_prompt = value;
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("System Prompt").setDesc("Enter the system prompt.").addTextArea((text) => {
      text.inputEl.setAttr("rows", "2");
      text.inputEl.setCssStyles({ width: "100%", resize: "vertical", position: "relative" });
      text.setPlaceholder(settings.system_prompt).setValue(settings.system_prompt).onChange(async (value) => {
        settings.system_prompt = value;
        await this.plugin.saveSettings();
      });
    });
  }
  async displayOpenAISettings() {
    const { containerEl } = this;
    const settings = this.plugin.settings.providers.openai;
    containerEl.createEl("h3", { text: "OpenAI Settings" });
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Enter the OpenAI API key.").addText(
      (text) => text.setPlaceholder(settings.apiKey).setValue(settings.apiKey).onChange(async (value) => {
        settings.apiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Model").setDesc("Choose the OpenAI model.").addDropdown((dropdown) => {
      dropdown.addOptions(Object.fromEntries(settings.models.map((model) => [model, model]))).setValue(settings.model).onChange(async (value) => {
        settings.model = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/completion/index.ts
async function* generateCompletion(editor, completer, splitStrategy) {
  completer.abort();
  const cursor = editor.getCursor();
  const currentLine = editor.getLine(cursor.line);
  if (!currentLine.length) {
    return;
  }
  const lastChar = currentLine[cursor.ch - 1];
  if (lastChar !== " ") {
    return;
  }
  for await (const text of completer.generate(editor)) {
    yield { text, splitStrategy };
  }
}

// src/main.ts
var Inscribe = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    await this.loadCompleter();
    await this.setupExtention();
    this.addSettingTab(new InscribeSettingsTab(this.app, this));
  }
  async loadCompleter() {
    this.completer = buildCompleter(this.settings);
  }
  async setupExtention() {
    const extension = inlineSuggestion({
      fetchFn: () => this.fetchSuggestions(),
      delayMs: this.settings.delay_ms
    });
    this.registerEditorExtension(extension);
  }
  async *fetchSuggestions() {
    const activeEditor = this.app.workspace.activeEditor;
    if (!activeEditor)
      return;
    if (!activeEditor.editor)
      return;
    yield* generateCompletion(activeEditor.editor, this.completer, this.settings.splitStrategy);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.loadCompleter();
  }
};
/*! Bundled license information:

mustache/mustache.mjs:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL2V4dGVuc2lvbi9pbmRleC50cyIsICJzcmMvcHJvdmlkZXJzL29wZW5haS9wcm92aWRlci50cyIsICJub2RlX21vZHVsZXMvb2xsYW1hL2Rpc3QvaW5kZXgubWpzIiwgIm5vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCAibm9kZV9tb2R1bGVzL29sbGFtYS9kaXN0L2Jyb3dzZXIubWpzIiwgIm5vZGVfbW9kdWxlcy9tdXN0YWNoZS9tdXN0YWNoZS5tanMiLCAic3JjL2NvbXBsZXRpb24vcHJvbXB0LnRzIiwgInNyYy9wcm92aWRlcnMvb2xsYW1hL2NvbXBsZXRlci50cyIsICJzcmMvcHJvdmlkZXJzL2luZGV4LnRzIiwgInNyYy9zZXR0aW5ncy9pbmRleC50cyIsICJzcmMvY29tcGxldGlvbi9pbmRleC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgU3VnZ2VzdGlvbiwgaW5saW5lU3VnZ2VzdGlvbiB9IGZyb20gXCIuL2V4dGVuc2lvblwiO1xuaW1wb3J0IHsgU2V0dGluZ3MsIERFRkFVTFRfU0VUVElOR1MgfSBmcm9tICcuL3NldHRpbmdzJztcbmltcG9ydCB7IEluc2NyaWJlU2V0dGluZ3NUYWIgfSBmcm9tIFwiLi9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgYnVpbGRDb21wbGV0ZXIsIENvbXBsZXRlciB9IGZyb20gJy4vcHJvdmlkZXJzJztcbmltcG9ydCB7IGdlbmVyYXRlQ29tcGxldGlvbiB9IGZyb20gJy4vY29tcGxldGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluc2NyaWJlIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IFNldHRpbmdzO1xuXHRjb21wbGV0ZXI6IENvbXBsZXRlclxuXG5cdGFzeW5jIG9ubG9hZCgpIHtcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXHRcdGF3YWl0IHRoaXMubG9hZENvbXBsZXRlcigpO1xuXHRcdGF3YWl0IHRoaXMuc2V0dXBFeHRlbnRpb24oKTtcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IEluc2NyaWJlU2V0dGluZ3NUYWIodGhpcy5hcHAsIHRoaXMpKTtcblx0fVxuXG5cdGFzeW5jIGxvYWRDb21wbGV0ZXIoKSB7XG5cdFx0dGhpcy5jb21wbGV0ZXIgPSBidWlsZENvbXBsZXRlcih0aGlzLnNldHRpbmdzKTtcblx0fVxuXG5cdGFzeW5jIHNldHVwRXh0ZW50aW9uKCkge1xuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IGlubGluZVN1Z2dlc3Rpb24oe1xuXHRcdFx0ZmV0Y2hGbjogKCkgPT4gdGhpcy5mZXRjaFN1Z2dlc3Rpb25zKCksXG5cdFx0XHRkZWxheU1zOiB0aGlzLnNldHRpbmdzLmRlbGF5X21zLFxuXHRcdH0pO1xuXHRcdHRoaXMucmVnaXN0ZXJFZGl0b3JFeHRlbnNpb24oZXh0ZW5zaW9uKTtcblx0fVxuXG5cdGFzeW5jICogZmV0Y2hTdWdnZXN0aW9ucygpOiBBc3luY0dlbmVyYXRvcjxTdWdnZXN0aW9uPiB7XG5cdFx0Y29uc3QgYWN0aXZlRWRpdG9yID0gdGhpcy5hcHAud29ya3NwYWNlLmFjdGl2ZUVkaXRvcjtcblx0XHRpZiAoIWFjdGl2ZUVkaXRvcikgcmV0dXJuO1xuXHRcdGlmICghYWN0aXZlRWRpdG9yLmVkaXRvcikgcmV0dXJuO1xuXG5cdFx0eWllbGQqIGdlbmVyYXRlQ29tcGxldGlvbihhY3RpdmVFZGl0b3IuZWRpdG9yLCB0aGlzLmNvbXBsZXRlciwgdGhpcy5zZXR0aW5ncy5zcGxpdFN0cmF0ZWd5KTtcblx0fVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihcblx0XHRcdHt9LFxuXHRcdFx0REVGQVVMVF9TRVRUSU5HUyxcblx0XHRcdGF3YWl0IHRoaXMubG9hZERhdGEoKVxuXHRcdCk7XG5cdH1cblxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcblx0XHRhd2FpdCB0aGlzLmxvYWRDb21wbGV0ZXIoKTtcblx0fVxufSIsICIvKipcbiAqIEEgQ29kZU1pcnJvciBleHRlbnNpb24gcHJvdmlkaW5nIGludGVsbGlnZW50IGlubGluZSBjb2RlIHN1Z2dlc3Rpb25zIHdpdGggY29uZmlndXJhYmxlXG4gKiBiZWhhdmlvciBmb3Igc3VnZ2VzdGlvbiBmZXRjaGluZywgZGlzcGxheSwgYW5kIGFjY2VwdGFuY2UuXG4gKi9cblxuaW1wb3J0IHsgVmlld1BsdWdpbiwgRWRpdG9yVmlldywgVmlld1VwZGF0ZSwgRGVjb3JhdGlvbiwgV2lkZ2V0VHlwZSwga2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBTdGF0ZUVmZmVjdCwgVGV4dCwgUHJlYywgU3RhdGVGaWVsZCwgRWRpdG9yU3RhdGUsIEVkaXRvclNlbGVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcblxuLyoqXG4gKiBCdWlsdC1pbiBzdHJhdGVnaWVzIGZvciBzcGxpdHRpbmcgc3VnZ2VzdGlvbnMgaW50byBhY2NlcHRlZC9yZW1haW5pbmcgcG9ydGlvbnNcbiAqL1xuY29uc3QgU3BsaXRTdHJhdGVnaWVzID0ge1xuICAgIC8qKiBTcGxpdCBhdCB3b3JkIGJvdW5kYXJpZXMgKHNwYWNlLXNlcGFyYXRlZCkgKi9cbiAgICB3b3JkOiAocmVtYWluaW5nOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgZmlyc3RTcGFjZSA9IHJlbWFpbmluZy5pbmRleE9mKCcgJyk7XG4gICAgICAgIHJldHVybiBmaXJzdFNwYWNlID09PSAtMVxuICAgICAgICAgICAgPyB7IGFjY2VwdDogcmVtYWluaW5nLCByZW1haW5pbmc6ICcnIH1cbiAgICAgICAgICAgIDogeyBhY2NlcHQ6IHJlbWFpbmluZy5zbGljZSgwLCBmaXJzdFNwYWNlICsgMSksIHJlbWFpbmluZzogcmVtYWluaW5nLnNsaWNlKGZpcnN0U3BhY2UgKyAxKSB9O1xuICAgIH0sXG5cbiAgICAvKiogU3BsaXQgYXQgc2VudGVuY2UgYm91bmRhcmllcyAocHVuY3R1YXRpb24gZm9sbG93ZWQgYnkgd2hpdGVzcGFjZSkgKi9cbiAgICBzZW50ZW5jZTogKHJlbWFpbmluZzogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbnRlbmNlRW5kID0gcmVtYWluaW5nLm1hdGNoKC9bLiE/XVxccysvKTtcbiAgICAgICAgcmV0dXJuIHNlbnRlbmNlRW5kXG4gICAgICAgICAgICA/IHsgYWNjZXB0OiByZW1haW5pbmcuc2xpY2UoMCwgc2VudGVuY2VFbmQuaW5kZXghICsgMSksIHJlbWFpbmluZzogcmVtYWluaW5nLnNsaWNlKHNlbnRlbmNlRW5kLmluZGV4ISArIDEpIH1cbiAgICAgICAgICAgIDogeyBhY2NlcHQ6IHJlbWFpbmluZywgcmVtYWluaW5nOiAnJyB9O1xuICAgIH0sXG5cbiAgICAvKiogU3BsaXQgYXQgcGFyYWdyYXBoIGJvdW5kYXJpZXMgKGRvdWJsZSBuZXdsaW5lKSAqL1xuICAgIHBhcmFncmFwaDogKHJlbWFpbmluZzogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFncmFwaEVuZCA9IHJlbWFpbmluZy5pbmRleE9mKCdcXG5cXG4nKTtcbiAgICAgICAgcmV0dXJuIHBhcmFncmFwaEVuZCA9PT0gLTFcbiAgICAgICAgICAgID8geyBhY2NlcHQ6IHJlbWFpbmluZywgcmVtYWluaW5nOiAnJyB9XG4gICAgICAgICAgICA6IHsgYWNjZXB0OiByZW1haW5pbmcuc2xpY2UoMCwgcGFyYWdyYXBoRW5kICsgMiksIHJlbWFpbmluZzogcmVtYWluaW5nLnNsaWNlKHBhcmFncmFwaEVuZCArIDIpIH07XG4gICAgfSxcblxuICAgIC8qKiBBY2NlcHQgZW50aXJlIHN1Z2dlc3Rpb24gYXQgb25jZSAqL1xuICAgIGZ1bGw6IChyZW1haW5pbmc6IHN0cmluZykgPT4gKHsgYWNjZXB0OiByZW1haW5pbmcsIHJlbWFpbmluZzogJycgfSksXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIEF2YWlsYWJsZSBzdHJhdGVnaWVzIGZvciBzcGxpdHRpbmcgYWNjZXB0ZWQgc3VnZ2VzdGlvbnMgZnJvbSByZW1haW5pbmcgdGV4dFxuICovXG5leHBvcnQgdHlwZSBTcGxpdFN0cmF0ZWd5ID0ga2V5b2YgdHlwZW9mIFNwbGl0U3RyYXRlZ2llcztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3VnZ2VzdGlvbiB0byBiZSBkaXNwbGF5ZWQgaW5saW5lIGluIHRoZSBlZGl0b3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWdnZXN0aW9uIHtcbiAgICAvKiogVGhlIGZ1bGwgc3VnZ2VzdGlvbiB0ZXh0IHRvIGRpc3BsYXkgKi9cbiAgICB0ZXh0OiBzdHJpbmc7XG4gICAgLyoqIFN0cmF0ZWd5IGZvciBzcGxpdHRpbmcgdGhlIHN1Z2dlc3Rpb24gaW50byBhY2NlcHQvcmVtYWluIHBvcnRpb25zICovXG4gICAgc3BsaXRTdHJhdGVneTogU3BsaXRTdHJhdGVneTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBpbmxpbmUgc3VnZ2VzdGlvbiBleHRlbnNpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmxpbmVTdWdnZXN0aW9uT3B0aW9ucyB7XG4gICAgLyoqIEFzeW5jIGZ1bmN0aW9uIHRvIGZldGNoIHN1Z2dlc3Rpb25zIGJhc2VkIG9uIGN1cnJlbnQgZWRpdG9yIHN0YXRlICovXG4gICAgZmV0Y2hGbjogKHN0YXRlOiBFZGl0b3JTdGF0ZSkgPT4gQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj4gfCBQcm9taXNlPFN1Z2dlc3Rpb24+O1xuICAgIC8qKiBEZWJvdW5jZSBkZWxheSBmb3Igc3VnZ2VzdGlvbiBmZXRjaGVzIChtcykgKi9cbiAgICBkZWxheU1zPzogbnVtYmVyO1xuICAgIC8qKiBLZXlib2FyZCBzaG9ydGN1dCB0byBhY2NlcHQgY3VycmVudCBzdWdnZXN0aW9uICovXG4gICAgYWNjZXB0U2hvcnRjdXQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgc3RhdGUgdHJhY2tpbmcgZm9yIHN1Z2dlc3Rpb24gbWFuYWdlbWVudFxuICovXG5pbnRlcmZhY2UgU3VnZ2VzdGlvblN0YXRlIHtcbiAgICBmdWxsU3VnZ2VzdGlvbjogc3RyaW5nIHwgbnVsbDtcbiAgICByZW1haW5pbmdTdWdnZXN0aW9uOiBzdHJpbmcgfCBudWxsO1xuICAgIG9yaWdpbmFsRG9jdW1lbnQ6IFRleHQgfCBudWxsO1xuICAgIHNwbGl0U3RyYXRlZ3k6IFNwbGl0U3RyYXRlZ3kgfCBudWxsO1xuICAgIG9yaWdpbmFsQ3Vyc29yUG9zOiBudW1iZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIEVtcHR5IHN1Z2dlc3Rpb24gY29uc3RhbnQgdXNlZCBmb3IgaW5pdGlhbGl6YXRpb24gYW5kIHJlc2V0IG9wZXJhdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IEVtcHR5U3VnZ2VzdGlvbjogU3VnZ2VzdGlvbiA9IHtcbiAgICB0ZXh0OiAnJyxcbiAgICBzcGxpdFN0cmF0ZWd5OiAnd29yZCcsXG59O1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTdGF0ZSBNYW5hZ2VtZW50IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKlxuICogU3RhdGUgZWZmZWN0IGZvciB1cGRhdGluZyBzdWdnZXN0aW9uIGluZm9ybWF0aW9uXG4gKi9cbmNvbnN0IFN1Z2dlc3Rpb25FZmZlY3QgPSBTdGF0ZUVmZmVjdC5kZWZpbmU8e1xuICAgIHN1Z2dlc3Rpb246IHN0cmluZyB8IG51bGw7XG4gICAgc3BsaXRTdHJhdGVneTogU3BsaXRTdHJhdGVneSB8IG51bGw7XG4gICAgZG9jdW1lbnQ6IFRleHQgfCBudWxsO1xuICAgIG9yaWdpbmFsQ3Vyc29yUG9zOiBudW1iZXIgfCBudWxsO1xufT4oKTtcblxuLyoqXG4gKiBTdGF0ZSBmaWVsZCBtYWludGFpbmluZyBjdXJyZW50IHN1Z2dlc3Rpb24gc3RhdGVcbiAqL1xuY29uc3QgU3VnZ2VzdGlvblN0YXRlRmllbGQgPSBTdGF0ZUZpZWxkLmRlZmluZTxTdWdnZXN0aW9uU3RhdGU+KHtcbiAgICBjcmVhdGU6ICgpID0+ICh7XG4gICAgICAgIGZ1bGxTdWdnZXN0aW9uOiBudWxsLFxuICAgICAgICByZW1haW5pbmdTdWdnZXN0aW9uOiBudWxsLFxuICAgICAgICBvcmlnaW5hbERvY3VtZW50OiBudWxsLFxuICAgICAgICBzcGxpdFN0cmF0ZWd5OiBudWxsLFxuICAgICAgICBvcmlnaW5hbEN1cnNvclBvczogbnVsbCxcbiAgICB9KSxcblxuICAgIHVwZGF0ZShvbGRTdGF0ZSwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gSGFuZGxlIHN1Z2dlc3Rpb24gZWZmZWN0IHVwZGF0ZXNcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gdHJhbnNhY3Rpb24uZWZmZWN0cy5maW5kKGUgPT4gZS5pcyhTdWdnZXN0aW9uRWZmZWN0KSk7XG4gICAgICAgIGlmIChlZmZlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3QudmFsdWUuc3VnZ2VzdGlvbiA9PT0gbnVsbFxuICAgICAgICAgICAgICAgID8geyAvLyBSZXNldCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBmdWxsU3VnZ2VzdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nU3VnZ2VzdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxEb2N1bWVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdHJhdGVneTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxDdXJzb3JQb3M6IG51bGwsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogeyAvLyBJbml0aWFsaXplIG5ldyBzdWdnZXN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxTdWdnZXN0aW9uOiBlZmZlY3QudmFsdWUuc3VnZ2VzdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nU3VnZ2VzdGlvbjogZWZmZWN0LnZhbHVlLnN1Z2dlc3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRG9jdW1lbnQ6IGVmZmVjdC52YWx1ZS5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdHJhdGVneTogZWZmZWN0LnZhbHVlLnNwbGl0U3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ3Vyc29yUG9zOiBlZmZlY3QudmFsdWUub3JpZ2luYWxDdXJzb3JQb3MsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB1c2VyIGlucHV0IHRoYXQgYWZmZWN0cyBjdXJyZW50IHN1Z2dlc3Rpb25cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmRvY0NoYW5nZWQgJiYgb2xkU3RhdGUucmVtYWluaW5nU3VnZ2VzdGlvbiAmJiBvbGRTdGF0ZS5vcmlnaW5hbEN1cnNvclBvcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGluc2VydGVkVGV4dCA9ICcnO1xuICAgICAgICAgICAgbGV0IGlzSW5zZXJ0aW9uQXRDdXJzb3IgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQW5hbHl6ZSBkb2N1bWVudCBjaGFuZ2VzIHRvIGRldGVjdCB1c2VyIGlucHV0XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CLCBpbnNlcnRlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQSA9PT0gb2xkU3RhdGUub3JpZ2luYWxDdXJzb3JQb3MgJiYgdG9BID09PSBmcm9tQSkge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZFRleHQgPSBpbnNlcnRlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpc0luc2VydGlvbkF0Q3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGlzSW5zZXJ0aW9uQXRDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSBpZiBpbnB1dCBtYXRjaGVzIGN1cnJlbnQgc3VnZ2VzdGlvblxuICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZS5yZW1haW5pbmdTdWdnZXN0aW9uLnN0YXJ0c1dpdGgoaW5zZXJ0ZWRUZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdSZW1haW5pbmcgPSBvbGRTdGF0ZS5yZW1haW5pbmdTdWdnZXN0aW9uLnNsaWNlKGluc2VydGVkVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub2xkU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdTdWdnZXN0aW9uOiBuZXdSZW1haW5pbmcgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ3Vyc29yUG9zOiBvbGRTdGF0ZS5vcmlnaW5hbEN1cnNvclBvcyArIGluc2VydGVkVGV4dC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBpbnB1dCAtIGRpc2NhcmQgc3VnZ2VzdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5vbGRTdGF0ZSwgcmVtYWluaW5nU3VnZ2VzdGlvbjogbnVsbCwgb3JpZ2luYWxDdXJzb3JQb3M6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElucHV0IG9jY3VycmVkIGVsc2V3aGVyZSAtIGRpc2NhcmQgc3VnZ2VzdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLm9sZFN0YXRlLCByZW1haW5pbmdTdWdnZXN0aW9uOiBudWxsLCBvcmlnaW5hbEN1cnNvclBvczogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9sZFN0YXRlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEN1c3RvbSB3aWRnZXQgaW1wbGVtZW50YXRpb24gZm9yIGRpc3BsYXlpbmcgaW5saW5lIHN1Z2dlc3Rpb25zXG4gKi9cbmNsYXNzIFN1Z2dlc3Rpb25XaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBzdWdnZXN0aW9uOiBzdHJpbmcpIHsgc3VwZXIoKTsgfVxuXG4gICAgdG9ET00oKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ2NtLWlubGluZS1zdWdnZXN0aW9uJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0aGlzLnN1Z2dlc3Rpb247XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGRlY29yYXRpb24gc2V0IGZvciBjdXJyZW50IHN1Z2dlc3Rpb24gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3VnZ2VzdGlvbkRlY29yYXRpb24odmlldzogRWRpdG9yVmlldywgc3VnZ2VzdGlvblRleHQ6IHN0cmluZykge1xuICAgIGNvbnN0IGN1cnNvclBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoW1xuICAgICAgICBEZWNvcmF0aW9uLndpZGdldCh7XG4gICAgICAgICAgICB3aWRnZXQ6IG5ldyBTdWdnZXN0aW9uV2lkZ2V0KHN1Z2dlc3Rpb25UZXh0KSxcbiAgICAgICAgICAgIHNpZGU6IDEsIC8vIERpc3BsYXkgYWZ0ZXIgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgIH0pLnJhbmdlKGN1cnNvclBvcyksXG4gICAgXSk7XG59XG5cbi8qKlxuICogVmlldyBwbHVnaW4gaGFuZGxpbmcgc3VnZ2VzdGlvbiBkZWNvcmF0aW9uIHVwZGF0ZXNcbiAqL1xuY29uc3Qgc3VnZ2VzdGlvblJlbmRlcmVyID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoXG4gICAgY2xhc3Mge1xuICAgICAgICBkZWNvcmF0aW9ucyA9IERlY29yYXRpb24ubm9uZTtcblxuICAgICAgICB1cGRhdGUodXBkYXRlOiBWaWV3VXBkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSB1cGRhdGUuc3RhdGUuZmllbGQoU3VnZ2VzdGlvblN0YXRlRmllbGQpLnJlbWFpbmluZ1N1Z2dlc3Rpb247XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gcmVtYWluaW5nXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTdWdnZXN0aW9uRGVjb3JhdGlvbih1cGRhdGUudmlldywgcmVtYWluaW5nKVxuICAgICAgICAgICAgICAgIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7IGRlY29yYXRpb25zOiAodikgPT4gdi5kZWNvcmF0aW9ucyB9XG4pO1xuXG4vKipcbiAqIENyZWF0ZXMgc3VnZ2VzdGlvbiBmZXRjaGluZyBzeXN0ZW0gd2l0aCBkZWJvdW5jaW5nIGFuZCBjYW5jZWxsYXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmV0Y2hTeXN0ZW0oXG4gICAgZmV0Y2hGbjogKHN0YXRlOiBFZGl0b3JTdGF0ZSkgPT4gQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj4sXG4gICAgZGVsYXk6IG51bWJlclxuKSB7XG4gICAgbGV0IGN1cnJlbnRSZXF1ZXN0SWQgPSAwO1xuICAgIGxldCB0aW1lb3V0SWQ6IE5vZGVKUy5UaW1lb3V0O1xuICAgIGxldCBhY3RpdmVHZW5lcmF0b3IgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRGVib3VuY2VkIGdlbmVyYXRvciB3aXRoIGNhbmNlbGxhdGlvbiBzdXBwb3J0XG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24qIGRlYm91bmNlZEdlbmVyYXRvcihzdGF0ZTogRWRpdG9yU3RhdGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGFjdGl2ZUdlbmVyYXRvciA9IHRydWU7XG5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGFjdGl2ZUdlbmVyYXRvcikge1xuICAgICAgICAgICAgeWllbGQqIGZldGNoRm4oc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmlldyBwbHVnaW4gaGFuZGxpbmcgc3VnZ2VzdGlvbiBmZXRjaGluZyBsb2dpY1xuICAgICAqL1xuICAgIGNvbnN0IGZldGNoUGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoXG4gICAgICAgIGNsYXNzIHtcbiAgICAgICAgICAgIGFzeW5jIHVwZGF0ZSh1cGRhdGU6IFZpZXdVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHVwZGF0ZS5zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHN0YXRlLmZpZWxkKFN1Z2dlc3Rpb25TdGF0ZUZpZWxkKS5yZW1haW5pbmdTdWdnZXN0aW9uKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSArK2N1cnJlbnRSZXF1ZXN0SWQ7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBzdWdnZXN0aW9uIG9mIGRlYm91bmNlZEdlbmVyYXRvcihzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RJZCAhPT0gY3VycmVudFJlcXVlc3RJZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBTdWdnZXN0aW9uRWZmZWN0Lm9mKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uOiBzdWdnZXN0aW9uLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRTdHJhdGVneTogc3VnZ2VzdGlvbi5zcGxpdFN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBzdGF0ZS5kb2MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxDdXJzb3JQb3M6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZldGNoUGx1Z2luLFxuICAgICAgICBjYW5jZWxEZWJvdW5jZTogKCkgPT4ge1xuICAgICAgICAgICAgYWN0aXZlR2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRyYW5zYWN0aW9uIGZvciBpbnNlcnRpbmcgc3VnZ2VzdGlvbiB0ZXh0XG4gKi9cbmZ1bmN0aW9uIGluc2VydFN1Z2dlc3Rpb25UZXh0KHN0YXRlOiBFZGl0b3JTdGF0ZSwgdGV4dDogc3RyaW5nKSB7XG4gICAgY29uc3QgY3Vyc29yUG9zID0gc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+ICh7XG4gICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IGN1cnNvclBvcywgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihjdXJzb3JQb3MgKyB0ZXh0Lmxlbmd0aClcbiAgICAgICAgfSkpLFxuICAgICAgICB1c2VyRXZlbnQ6ICdpbnB1dC5jb21wbGV0ZScsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGlucHV0IGhhbmRsZXJzIGZvciBzdWdnZXN0aW9uIGFjY2VwdGFuY2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRIYW5kbGVycyhjYW5jZWxGZXRjaDogKCkgPT4gdm9pZCwgYWNjZXB0S2V5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gUHJlYy5oaWdoZXN0KFxuICAgICAgICBrZXltYXAub2YoW3tcbiAgICAgICAgICAgIGtleTogYWNjZXB0S2V5LFxuICAgICAgICAgICAgcnVuOiAodmlldzogRWRpdG9yVmlldykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChTdWdnZXN0aW9uU3RhdGVGaWVsZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5yZW1haW5pbmdTdWdnZXN0aW9uKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneU5hbWUgPSBzdGF0ZS5zcGxpdFN0cmF0ZWd5IHx8ICd3b3JkJztcbiAgICAgICAgICAgICAgICBjb25zdCBzcGxpdHRlciA9IFNwbGl0U3RyYXRlZ2llc1tzdHJhdGVneU5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYWNjZXB0LCByZW1haW5pbmcgfSA9IHNwbGl0dGVyKHN0YXRlLnJlbWFpbmluZ1N1Z2dlc3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhY2NlcHQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAuLi5pbnNlcnRTdWdnZXN0aW9uVGV4dCh2aWV3LnN0YXRlLCBhY2NlcHQpLFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBTdWdnZXN0aW9uRWZmZWN0Lm9mKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb246IHJlbWFpbmluZyB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHJlbWFpbmluZyA/IHN0YXRlLm9yaWdpbmFsRG9jdW1lbnQgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRTdHJhdGVneTogcmVtYWluaW5nID8gc3RhdGUuc3BsaXRTdHJhdGVneSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEN1cnNvclBvczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlbWFpbmluZykgY2FuY2VsRmV0Y2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1dKVxuICAgICk7XG59XG5cbi8qKlxuICogTWFpbiBleHRlbnNpb24gZnVuY3Rpb24gZm9yIGlubGluZSBzdWdnZXN0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5saW5lU3VnZ2VzdGlvbihvcHRpb25zOiBJbmxpbmVTdWdnZXN0aW9uT3B0aW9ucykge1xuICAgIGNvbnN0IHsgZGVsYXlNcyA9IDUwMCwgYWNjZXB0U2hvcnRjdXQgPSAnVGFiJywgZmV0Y2hGbjogdXNlckZldGNoRm4gfSA9IG9wdGlvbnM7XG5cbiAgICAvLyBOb3JtYWxpemUgZmV0Y2ggZnVuY3Rpb24gdG8gaGFuZGxlIGJvdGggYXN5bmMgZ2VuZXJhdG9ycyBhbmQgcHJvbWlzZXNcbiAgICBjb25zdCBub3JtYWxpemVkRmV0Y2ggPSBhc3luYyBmdW5jdGlvbiogKHN0YXRlOiBFZGl0b3JTdGF0ZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1c2VyRmV0Y2hGbihzdGF0ZSk7XG4gICAgICAgIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgIHlpZWxkKiByZXN1bHQgYXMgQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCByZXN1bHQgYXMgU3VnZ2VzdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJbml0aWFsaXplIHN5c3RlbSBjb21wb25lbnRzXG4gICAgY29uc3QgeyBmZXRjaFBsdWdpbiwgY2FuY2VsRGVib3VuY2UgfSA9IGNyZWF0ZUZldGNoU3lzdGVtKG5vcm1hbGl6ZWRGZXRjaCwgZGVsYXlNcyk7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbktleW1hcCA9IGNyZWF0ZUlucHV0SGFuZGxlcnMoY2FuY2VsRGVib3VuY2UsIGFjY2VwdFNob3J0Y3V0KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIFN1Z2dlc3Rpb25TdGF0ZUZpZWxkLFxuICAgICAgICBmZXRjaFBsdWdpbixcbiAgICAgICAgc3VnZ2VzdGlvblJlbmRlcmVyLFxuICAgICAgICBzdWdnZXN0aW9uS2V5bWFwXG4gICAgXTtcbn0iLCAiaW1wb3J0IHsgQ29tcGxldGVyLCBQcm92aWRlciB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBPcGVuQUlTZXR0aW5ncyB9IGZyb20gXCIuXCI7XG5pbXBvcnQgeyBTdWdnZXN0aW9uIH0gZnJvbSBcImNvZGVtaXJyb3ItY29tcGFuaW9uLWV4dGVuc2lvblwiO1xuXG5leHBvcnQgY2xhc3MgT3BlbkFJQ29tcGxldGVyIGltcGxlbWVudHMgQ29tcGxldGVyIHtcbiAgICBpbnRlZ3JhdGlvbjogUHJvdmlkZXIgPSBQcm92aWRlci5PUEVOQUk7XG4gICAgbmFtZTogc3RyaW5nID0gXCJPcGVuIEFJXCI7XG4gICAgZGVzY3JpcHRpb246IFwiT3BlbkFJIHRoZSBldmlsZXN0IGNvbXBhbnkgaW4gdGhlIHdvcmxkXCI7XG4gICAgc2V0dGluZ3M6IE9wZW5BSVNldHRpbmdzXG4gICAgY29tcGxldGVyOiBDb21wbGV0ZXI7XG4gICAgbW9kZWxzOiBzdHJpbmdbXTtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5nczogT3BlbkFJU2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIH1cbiAgICBnZW5lcmF0ZTogKGVkaXRvcjogRWRpdG9yKSA9PiBBc3luY0dlbmVyYXRvcjxzdHJpbmc+O1xuICAgIGFib3J0OiAoKSA9PiB2b2lkO1xuICAgIGF2YWlsYWJsZU1vZGVscygpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiBbXCJncHQtNFwiLCBcImRhdmluY2lcIl07XG4gICAgfVxufSIsICJpbXBvcnQgZnMsIHsgcHJvbWlzZXMgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyByZXNvbHZlIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBPbGxhbWEgYXMgT2xsYW1hJDEgfSBmcm9tICcuL2Jyb3dzZXIubWpzJztcbmltcG9ydCAnd2hhdHdnLWZldGNoJztcblxuY2xhc3MgT2xsYW1hIGV4dGVuZHMgT2xsYW1hJDEge1xuICBhc3luYyBlbmNvZGVJbWFnZShpbWFnZSkge1xuICAgIGlmICh0eXBlb2YgaW1hZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbWFnZSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhpbWFnZSkpIHtcbiAgICAgICAgY29uc3QgZmlsZUJ1ZmZlciA9IGF3YWl0IHByb21pc2VzLnJlYWRGaWxlKHJlc29sdmUoaW1hZ2UpKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGZpbGVCdWZmZXIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbiAgLyoqXG4gICAqIGNoZWNrcyBpZiBhIGZpbGUgZXhpc3RzXG4gICAqIEBwYXJhbSBwYXRoIHtzdHJpbmd9IC0gVGhlIHBhdGggdG8gdGhlIGZpbGVcbiAgICogQHByaXZhdGUgQGludGVybmFsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSAtIFdoZXRoZXIgdGhlIGZpbGUgZXhpc3RzIG9yIG5vdFxuICAgKi9cbiAgYXN5bmMgZmlsZUV4aXN0cyhwYXRoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHByb21pc2VzLmFjY2VzcyhwYXRoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGUocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0LmZyb20gJiYgYXdhaXQgdGhpcy5maWxlRXhpc3RzKHJlc29sdmUocmVxdWVzdC5mcm9tKSkpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQ3JlYXRpbmcgd2l0aCBhIGxvY2FsIHBhdGggaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgZnJvbSBvbGxhbWEtanNcIik7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0LnN0cmVhbSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZShyZXF1ZXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZShyZXF1ZXN0KTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGluZGV4ID0gbmV3IE9sbGFtYSgpO1xuXG5leHBvcnQgeyBPbGxhbWEsIGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cbnZhciBnID1cbiAgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzKSB8fFxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsKSB8fFxuICB7fVxuXG52YXIgc3VwcG9ydCA9IHtcbiAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBnLFxuICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gZyAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgYmxvYjpcbiAgICAnRmlsZVJlYWRlcicgaW4gZyAmJlxuICAgICdCbG9iJyBpbiBnICYmXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBnLFxuICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBnXG59XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxufVxuXG5pZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgXVxuXG4gIHZhciBpc0FycmF5QnVmZmVyVmlldyA9XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICB9XG4gIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+IV0vaS50ZXN0KG5hbWUpIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWU6IFwiJyArIG5hbWUgKyAnXCInKVxuICB9XG4gIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbmZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdGhpcy5tYXAgPSB7fVxuXG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgfSwgdGhpcylcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgaWYgKGhlYWRlci5sZW5ndGggIT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIZWFkZXJzIGNvbnN0cnVjdG9yOiBleHBlY3RlZCBuYW1lL3ZhbHVlIHBhaXIgdG8gYmUgbGVuZ3RoIDIsIGZvdW5kJyArIGhlYWRlci5sZW5ndGgpXG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgfSwgdGhpcylcbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICB9XG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKG5hbWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIGl0ZW1zLnB1c2godmFsdWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXNcbn1cblxuZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICBpZiAoYm9keS5fbm9Cb2R5KSByZXR1cm5cbiAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gIH1cbiAgYm9keS5ib2R5VXNlZCA9IHRydWVcbn1cblxuZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgIH1cbiAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB2YXIgbWF0Y2ggPSAvY2hhcnNldD0oW0EtWmEtejAtOV8tXSspLy5leGVjKGJsb2IudHlwZSlcbiAgdmFyIGVuY29kaW5nID0gbWF0Y2ggPyBtYXRjaFsxXSA6ICd1dGYtOCdcbiAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYiwgZW5jb2RpbmcpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgfVxuICByZXR1cm4gY2hhcnMuam9pbignJylcbn1cblxuZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gIGlmIChidWYuc2xpY2UpIHtcbiAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gIH0gZWxzZSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aClcbiAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICB9XG59XG5cbmZ1bmN0aW9uIEJvZHkoKSB7XG4gIHRoaXMuYm9keVVzZWQgPSBmYWxzZVxuXG4gIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgIC8qXG4gICAgICBmZXRjaC1tb2NrIHdyYXBzIHRoZSBSZXNwb25zZSBvYmplY3QgaW4gYW4gRVM2IFByb3h5IHRvXG4gICAgICBwcm92aWRlIHVzZWZ1bCB0ZXN0IGhhcm5lc3MgZmVhdHVyZXMgc3VjaCBhcyBmbHVzaC4gSG93ZXZlciwgb25cbiAgICAgIEVTNSBicm93c2VycyB3aXRob3V0IGZldGNoIG9yIFByb3h5IHN1cHBvcnQgcG9sbHlmaWxscyBtdXN0IGJlIHVzZWQ7XG4gICAgICB0aGUgcHJveHktcG9sbHlmaWxsIGlzIHVuYWJsZSB0byBwcm94eSBhbiBhdHRyaWJ1dGUgdW5sZXNzIGl0IGV4aXN0c1xuICAgICAgb24gdGhlIG9iamVjdCBiZWZvcmUgdGhlIFByb3h5IGlzIGNyZWF0ZWQuIFRoaXMgY2hhbmdlIGVuc3VyZXNcbiAgICAgIFJlc3BvbnNlLmJvZHlVc2VkIGV4aXN0cyBvbiB0aGUgaW5zdGFuY2UsIHdoaWxlIG1haW50YWluaW5nIHRoZVxuICAgICAgc2VtYW50aWMgb2Ygc2V0dGluZyBSZXF1ZXN0LmJvZHlVc2VkIGluIHRoZSBjb25zdHJ1Y3RvciBiZWZvcmVcbiAgICAgIF9pbml0Qm9keSBpcyBjYWxsZWQuXG4gICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICB0aGlzLmJvZHlVc2VkID0gdGhpcy5ib2R5VXNlZFxuICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgIGlmICghYm9keSkge1xuICAgICAgdGhpcy5fbm9Cb2R5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcilcbiAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgaXNDb25zdW1lZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAoaXNDb25zdW1lZCkge1xuICAgICAgICByZXR1cm4gaXNDb25zdW1lZFxuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5fYm9keUFycmF5QnVmZmVyKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0ICsgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgYXMgQXJyYXlCdWZmZXInKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbnZhciBtZXRob2RzID0gWydDT05ORUNUJywgJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BBVENIJywgJ1BPU1QnLCAnUFVUJywgJ1RSQUNFJ11cblxuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcblxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgIH1cbiAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICB0aGlzLnNpZ25hbCA9IGlucHV0LnNpZ25hbFxuICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICB9XG5cbiAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nXG4gIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgfVxuICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gIHRoaXMuc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgfHwgdGhpcy5zaWduYWwgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ0Fib3J0Q29udHJvbGxlcicgaW4gZykge1xuICAgICAgdmFyIGN0cmwgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICByZXR1cm4gY3RybC5zaWduYWw7XG4gICAgfVxuICB9KCkpO1xuICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gIH1cbiAgdGhpcy5faW5pdEJvZHkoYm9keSlcblxuICBpZiAodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICBpZiAob3B0aW9ucy5jYWNoZSA9PT0gJ25vLXN0b3JlJyB8fCBvcHRpb25zLmNhY2hlID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAvLyBTZWFyY2ggZm9yIGEgJ18nIHBhcmFtZXRlciBpbiB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICB2YXIgcmVQYXJhbVNlYXJjaCA9IC8oWz8mXSlfPVteJl0qL1xuICAgICAgaWYgKHJlUGFyYW1TZWFyY2gudGVzdCh0aGlzLnVybCkpIHtcbiAgICAgICAgLy8gSWYgaXQgYWxyZWFkeSBleGlzdHMgdGhlbiBzZXQgdGhlIHZhbHVlIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnJlcGxhY2UocmVQYXJhbVNlYXJjaCwgJyQxXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGEgbmV3ICdfJyBwYXJhbWV0ZXIgdG8gdGhlIGVuZCB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgdmFyIHJlUXVlcnlTdHJpbmcgPSAvXFw/L1xuICAgICAgICB0aGlzLnVybCArPSAocmVRdWVyeVN0cmluZy50ZXN0KHRoaXMudXJsKSA/ICcmJyA6ICc/JykgKyAnXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG59XG5cbmZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgYm9keVxuICAgIC50cmltKClcbiAgICAuc3BsaXQoJyYnKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICByZXR1cm4gZm9ybVxufVxuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcbiAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKVxuICAvLyBBdm9pZGluZyBzcGxpdCB2aWEgcmVnZXggdG8gd29yayBhcm91bmQgYSBjb21tb24gSUUxMSBidWcgd2l0aCB0aGUgY29yZS1qcyAzLjYuMCByZWdleCBwb2x5ZmlsbFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoL2lzc3Vlcy83NDhcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzc1MVxuICBwcmVQcm9jZXNzZWRIZWFkZXJzXG4gICAgLnNwbGl0KCdcXHInKVxuICAgIC5tYXAoZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICByZXR1cm4gaGVhZGVyLmluZGV4T2YoJ1xcbicpID09PSAwID8gaGVhZGVyLnN1YnN0cigxLCBoZWFkZXIubGVuZ3RoKSA6IGhlYWRlclxuICAgIH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdSZXNwb25zZSAnICsgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbkJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuZXhwb3J0IGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXNcbiAgaWYgKHRoaXMuc3RhdHVzIDwgMjAwIHx8IHRoaXMuc3RhdHVzID4gNTk5KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNwb25zZSc6IFRoZSBzdGF0dXMgcHJvdmlkZWQgKDApIGlzIG91dHNpZGUgdGhlIHJhbmdlIFsyMDAsIDU5OV0uXCIpXG4gIH1cbiAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHQgPT09IHVuZGVmaW5lZCA/ICcnIDogJycgKyBvcHRpb25zLnN0YXR1c1RleHRcbiAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxufVxuXG5Cb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG5SZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgdXJsOiB0aGlzLnVybFxuICB9KVxufVxuXG5SZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMjAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gIHJlc3BvbnNlLm9rID0gZmFsc2VcbiAgcmVzcG9uc2Uuc3RhdHVzID0gMFxuICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxudmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cblJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxufVxuXG5leHBvcnQgdmFyIERPTUV4Y2VwdGlvbiA9IGcuRE9NRXhjZXB0aW9uXG50cnkge1xuICBuZXcgRE9NRXhjZXB0aW9uKClcbn0gY2F0Y2ggKGVycikge1xuICBET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKVxuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFja1xuICB9XG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERPTUV4Y2VwdGlvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgeGhyLmFib3J0KClcbiAgICB9XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICB9XG4gICAgICAvLyBUaGlzIGNoZWNrIGlmIHNwZWNpZmljYWxseSBmb3Igd2hlbiBhIHVzZXIgZmV0Y2hlcyBhIGZpbGUgbG9jYWxseSBmcm9tIHRoZSBmaWxlIHN5c3RlbVxuICAgICAgLy8gT25seSBpZiB0aGUgc3RhdHVzIGlzIG91dCBvZiBhIG5vcm1hbCByYW5nZVxuICAgICAgaWYgKHJlcXVlc3QudXJsLmluZGV4T2YoJ2ZpbGU6Ly8nKSA9PT0gMCAmJiAoeGhyLnN0YXR1cyA8IDIwMCB8fCB4aHIuc3RhdHVzID4gNTk5KSkge1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IDIwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgdGltZWQgb3V0JykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFVybCh1cmwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cmwgPT09ICcnICYmIGcubG9jYXRpb24uaHJlZiA/IGcubG9jYXRpb24uaHJlZiA6IHVybFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdXJsXG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIGZpeFVybChyZXF1ZXN0LnVybCksIHRydWUpXG5cbiAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKSB7XG4gICAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHN1cHBvcnQuYXJyYXlCdWZmZXJcbiAgICAgICkge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbml0ICYmIHR5cGVvZiBpbml0LmhlYWRlcnMgPT09ICdvYmplY3QnICYmICEoaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycyB8fCAoZy5IZWFkZXJzICYmIGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIGcuSGVhZGVycykpKSB7XG4gICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaXQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWVzLnB1c2gobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgbm9ybWFsaXplVmFsdWUoaW5pdC5oZWFkZXJzW25hbWVdKSlcbiAgICAgIH0pXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcblxuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICB9KVxufVxuXG5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcblxuaWYgKCFnLmZldGNoKSB7XG4gIGcuZmV0Y2ggPSBmZXRjaFxuICBnLkhlYWRlcnMgPSBIZWFkZXJzXG4gIGcuUmVxdWVzdCA9IFJlcXVlc3RcbiAgZy5SZXNwb25zZSA9IFJlc3BvbnNlXG59XG4iLCAiaW1wb3J0ICd3aGF0d2ctZmV0Y2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gXCIwLjUuMTJcIjtcblxudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQxKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGVycm9yLCBzdGF0dXNfY29kZSkge1xuICAgIHN1cGVyKGVycm9yKTtcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5zdGF0dXNfY29kZSA9IHN0YXR1c19jb2RlO1xuICAgIHRoaXMubmFtZSA9IFwiUmVzcG9uc2VFcnJvclwiO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVzcG9uc2VFcnJvcik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHtcbiAgY29uc3RydWN0b3IoYWJvcnRDb250cm9sbGVyLCBpdHIsIGRvbmVDYWxsYmFjaykge1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImFib3J0Q29udHJvbGxlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpdHJcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiZG9uZUNhbGxiYWNrXCIpO1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xuICAgIHRoaXMuaXRyID0gaXRyO1xuICAgIHRoaXMuZG9uZUNhbGxiYWNrID0gZG9uZUNhbGxiYWNrO1xuICB9XG4gIGFib3J0KCkge1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBtZXNzYWdlIG9mIHRoaXMuaXRyKSB7XG4gICAgICBpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgfVxuICAgICAgeWllbGQgbWVzc2FnZTtcbiAgICAgIGlmIChtZXNzYWdlLmRvbmUgfHwgbWVzc2FnZS5zdGF0dXMgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgIHRoaXMuZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCByZWNlaXZlIGRvbmUgb3Igc3VjY2VzcyByZXNwb25zZSBpbiBzdHJlYW0uXCIpO1xuICB9XG59XG5jb25zdCBjaGVja09rID0gYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbWVzc2FnZSA9IGBFcnJvciAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICBsZXQgZXJyb3JEYXRhID0gbnVsbDtcbiAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpPy5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICB0cnkge1xuICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgbWVzc2FnZSA9IGVycm9yRGF0YS5lcnJvciB8fCBtZXNzYWdlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBlcnJvciByZXNwb25zZSBhcyBKU09OXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCJHZXR0aW5nIHRleHQgZnJvbSByZXNwb25zZVwiKTtcbiAgICAgIGNvbnN0IHRleHRSZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIG1lc3NhZ2UgPSB0ZXh0UmVzcG9uc2UgfHwgbWVzc2FnZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gZ2V0IHRleHQgZnJvbSBlcnJvciByZXNwb25zZVwiKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IFJlc3BvbnNlRXJyb3IobWVzc2FnZSwgcmVzcG9uc2Uuc3RhdHVzKTtcbn07XG5mdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hdmlnYXRvcikge1xuICAgIHJldHVybiBgJHt3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtLnRvTG93ZXJDYXNlKCl9IEJyb3dzZXIvJHtuYXZpZ2F0b3IudXNlckFnZW50fTtgO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGAke3Byb2Nlc3MuYXJjaH0gJHtwcm9jZXNzLnBsYXRmb3JtfSBOb2RlLmpzLyR7cHJvY2Vzcy52ZXJzaW9ufWA7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5jb25zdCBmZXRjaFdpdGhIZWFkZXJzID0gYXN5bmMgKGZldGNoLCB1cmwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIFwiVXNlci1BZ2VudFwiOiBgb2xsYW1hLWpzLyR7dmVyc2lvbn0gKCR7Z2V0UGxhdGZvcm0oKX0pYFxuICB9O1xuICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IHt9O1xuICB9XG4gIGNvbnN0IGN1c3RvbUhlYWRlcnMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5oZWFkZXJzKS5maWx0ZXIoKFtrZXldKSA9PiAhT2JqZWN0LmtleXMoZGVmYXVsdEhlYWRlcnMpLnNvbWUoKGRlZmF1bHRLZXkpID0+IGRlZmF1bHRLZXkudG9Mb3dlckNhc2UoKSA9PT0ga2V5LnRvTG93ZXJDYXNlKCkpKVxuICApO1xuICBvcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgLi4uZGVmYXVsdEhlYWRlcnMsXG4gICAgLi4uY3VzdG9tSGVhZGVyc1xuICB9O1xuICByZXR1cm4gZmV0Y2godXJsLCBvcHRpb25zKTtcbn07XG5jb25zdCBnZXQgPSBhc3luYyAoZmV0Y2gsIGhvc3QsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhIZWFkZXJzKGZldGNoLCBob3N0LCB7XG4gICAgaGVhZGVyczogb3B0aW9ucz8uaGVhZGVyc1xuICB9KTtcbiAgYXdhaXQgY2hlY2tPayhyZXNwb25zZSk7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG5jb25zdCBwb3N0ID0gYXN5bmMgKGZldGNoLCBob3N0LCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGlzUmVjb3JkID0gKGlucHV0KSA9PiB7XG4gICAgcmV0dXJuIGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShpbnB1dCk7XG4gIH07XG4gIGNvbnN0IGZvcm1hdHRlZERhdGEgPSBpc1JlY29yZChkYXRhKSA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogZGF0YTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhIZWFkZXJzKGZldGNoLCBob3N0LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBmb3JtYXR0ZWREYXRhLFxuICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsLFxuICAgIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnNcbiAgfSk7XG4gIGF3YWl0IGNoZWNrT2socmVzcG9uc2UpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuY29uc3QgZGVsID0gYXN5bmMgKGZldGNoLCBob3N0LCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoSGVhZGVycyhmZXRjaCwgaG9zdCwge1xuICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzXG4gIH0pO1xuICBhd2FpdCBjaGVja09rKHJlc3BvbnNlKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbmNvbnN0IHBhcnNlSlNPTiA9IGFzeW5jIGZ1bmN0aW9uKiAoaXRyKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIGNvbnN0IHJlYWRlciA9IGl0ci5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlOiBjaHVuayB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJ1ZmZlciArPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgY29uc3QgcGFydHMgPSBidWZmZXIuc3BsaXQoXCJcXG5cIik7XG4gICAgYnVmZmVyID0gcGFydHMucG9wKCkgPz8gXCJcIjtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIEpTT04ucGFyc2UocGFydCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJpbnZhbGlkIGpzb246IFwiLCBwYXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBwYXJ0IG9mIGJ1ZmZlci5zcGxpdChcIlxcblwiKS5maWx0ZXIoKHApID0+IHAgIT09IFwiXCIpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHlpZWxkIEpTT04ucGFyc2UocGFydCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImludmFsaWQganNvbjogXCIsIHBhcnQpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGZvcm1hdEhvc3QgPSAoaG9zdCkgPT4ge1xuICBpZiAoIWhvc3QpIHtcbiAgICByZXR1cm4gXCJodHRwOi8vMTI3LjAuMC4xOjExNDM0XCI7XG4gIH1cbiAgbGV0IGlzRXhwbGljaXRQcm90b2NvbCA9IGhvc3QuaW5jbHVkZXMoXCI6Ly9cIik7XG4gIGlmIChob3N0LnN0YXJ0c1dpdGgoXCI6XCIpKSB7XG4gICAgaG9zdCA9IGBodHRwOi8vMTI3LjAuMC4xJHtob3N0fWA7XG4gICAgaXNFeHBsaWNpdFByb3RvY29sID0gdHJ1ZTtcbiAgfVxuICBpZiAoIWlzRXhwbGljaXRQcm90b2NvbCkge1xuICAgIGhvc3QgPSBgaHR0cDovLyR7aG9zdH1gO1xuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoaG9zdCk7XG4gIGxldCBwb3J0ID0gdXJsLnBvcnQ7XG4gIGlmICghcG9ydCkge1xuICAgIGlmICghaXNFeHBsaWNpdFByb3RvY29sKSB7XG4gICAgICBwb3J0ID0gXCIxMTQzNFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3J0ID0gdXJsLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCI0NDNcIiA6IFwiODBcIjtcbiAgICB9XG4gIH1cbiAgbGV0IGZvcm1hdHRlZEhvc3QgPSBgJHt1cmwucHJvdG9jb2x9Ly8ke3VybC5ob3N0bmFtZX06JHtwb3J0fSR7dXJsLnBhdGhuYW1lfWA7XG4gIGlmIChmb3JtYXR0ZWRIb3N0LmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIGZvcm1hdHRlZEhvc3QgPSBmb3JtYXR0ZWRIb3N0LnNsaWNlKDAsIC0xKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVkSG9zdDtcbn07XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmxldCBPbGxhbWEkMSA9IGNsYXNzIE9sbGFtYSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb25maWdcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZldGNoXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvbmdvaW5nU3RyZWFtZWRSZXF1ZXN0c1wiLCBbXSk7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBob3N0OiBcIlwiLFxuICAgICAgaGVhZGVyczogY29uZmlnPy5oZWFkZXJzXG4gICAgfTtcbiAgICBpZiAoIWNvbmZpZz8ucHJveHkpIHtcbiAgICAgIHRoaXMuY29uZmlnLmhvc3QgPSBmb3JtYXRIb3N0KGNvbmZpZz8uaG9zdCA/PyBcImh0dHA6Ly8xMjcuMC4wLjE6MTE0MzRcIik7XG4gICAgfVxuICAgIHRoaXMuZmV0Y2ggPSBjb25maWc/LmZldGNoID8/IGZldGNoO1xuICB9XG4gIC8vIEFib3J0IGFueSBvbmdvaW5nIHN0cmVhbWVkIHJlcXVlc3RzIHRvIE9sbGFtYVxuICBhYm9ydCgpIHtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIHJlcXVlc3QgdG8gdGhlIE9sbGFtYSBzZXJ2ZXIuIElmIHRoZSByZXF1ZXN0IGlzIHN0cmVhbWFibGUsIGl0IHdpbGwgcmV0dXJuIGFcbiAgICogQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyB0aGUgcmVzcG9uc2UgbWVzc2FnZXMuIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIHJlc3BvbnNlXG4gICAqIG9iamVjdC5cbiAgICogQHBhcmFtIGVuZHBvaW50IHtzdHJpbmd9IC0gVGhlIGVuZHBvaW50IHRvIHNlbmQgdGhlIHJlcXVlc3QgdG8uXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtvYmplY3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0IHRvIHNlbmQgdG8gdGhlIGVuZHBvaW50LlxuICAgKiBAcHJvdGVjdGVkIHtUIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxUPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGEgQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkc1xuICAgKiByZXNwb25zZSBtZXNzYWdlcy5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZyBvciBpZiB0aGUgcmVzcG9uc2UgaXMgYW4gZXJyb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFQgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFQ+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGEgQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyB0aGUgc3RyZWFtZWQgcmVzcG9uc2UuXG4gICAqL1xuICBhc3luYyBwcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoZW5kcG9pbnQsIHJlcXVlc3QpIHtcbiAgICByZXF1ZXN0LnN0cmVhbSA9IHJlcXVlc3Quc3RyZWFtID8/IGZhbHNlO1xuICAgIGNvbnN0IGhvc3QgPSBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvJHtlbmRwb2ludH1gO1xuICAgIGlmIChyZXF1ZXN0LnN0cmVhbSkge1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBob3N0LCByZXF1ZXN0LCB7XG4gICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlMi5ib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYm9keVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ciA9IHBhcnNlSlNPTihyZXNwb25zZTIuYm9keSk7XG4gICAgICBjb25zdCBhYm9ydGFibGVBc3luY0l0ZXJhdG9yID0gbmV3IEFib3J0YWJsZUFzeW5jSXRlcmF0b3IoXG4gICAgICAgIGFib3J0Q29udHJvbGxlcixcbiAgICAgICAgaXRyLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMuaW5kZXhPZihhYm9ydGFibGVBc3luY0l0ZXJhdG9yKTtcbiAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzLnB1c2goYWJvcnRhYmxlQXN5bmNJdGVyYXRvcik7XG4gICAgICByZXR1cm4gYWJvcnRhYmxlQXN5bmNJdGVyYXRvcjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGhvc3QsIHJlcXVlc3QsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBFbmNvZGVzIGFuIGltYWdlIHRvIGJhc2U2NCBpZiBpdCBpcyBhIFVpbnQ4QXJyYXkuXG4gICAqIEBwYXJhbSBpbWFnZSB7VWludDhBcnJheSB8IHN0cmluZ30gLSBUaGUgaW1hZ2UgdG8gZW5jb2RlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIFRoZSBiYXNlNjQgZW5jb2RlZCBpbWFnZS5cbiAgICovXG4gIGFzeW5jIGVuY29kZUltYWdlKGltYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBpbWFnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGltYWdlKTtcbiAgICAgIGxldCBieXRlU3RyaW5nID0gXCJcIjtcbiAgICAgIGNvbnN0IGxlbiA9IHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYnl0ZVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVpbnQ4QXJyYXlbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ0b2EoYnl0ZVN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcmVzcG9uc2UgZnJvbSBhIHRleHQgcHJvbXB0LlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7R2VuZXJhdGVSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8R2VuZXJhdGVSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8R2VuZXJhdGVSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3JcbiAgICogYW4gQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlKHJlcXVlc3QpIHtcbiAgICBpZiAocmVxdWVzdC5pbWFnZXMpIHtcbiAgICAgIHJlcXVlc3QuaW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdC5pbWFnZXMubWFwKHRoaXMuZW5jb2RlSW1hZ2UuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJnZW5lcmF0ZVwiLCByZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogQ2hhdHMgd2l0aCB0aGUgbW9kZWwuIFRoZSByZXF1ZXN0IG9iamVjdCBjYW4gY29udGFpbiBtZXNzYWdlcyB3aXRoIGltYWdlcyB0aGF0IGFyZSBlaXRoZXJcbiAgICogVWludDhBcnJheXMgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5ncy4gVGhlIGltYWdlcyB3aWxsIGJlIGJhc2U2NCBlbmNvZGVkIGJlZm9yZSBzZW5kaW5nIHRoZVxuICAgKiByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7Q2hhdFJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGF0UmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPENoYXRSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYW5cbiAgICogQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIGNoYXQocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0Lm1lc3NhZ2VzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcmVxdWVzdC5tZXNzYWdlcykge1xuICAgICAgICBpZiAobWVzc2FnZS5pbWFnZXMpIHtcbiAgICAgICAgICBtZXNzYWdlLmltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgbWVzc2FnZS5pbWFnZXMubWFwKHRoaXMuZW5jb2RlSW1hZ2UuYmluZCh0aGlzKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcImNoYXRcIiwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbW9kZWwgZnJvbSBhIHN0cmVhbSBvZiBkYXRhLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7Q3JlYXRlUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFByb2dyZXNzUmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFByb2dyZXNzUmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGEgc3RyZWFtIG9mIHByb2dyZXNzIHJlc3BvbnNlcy5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZShyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwiY3JlYXRlXCIsIHtcbiAgICAgIC4uLnJlcXVlc3RcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHVsbHMgYSBtb2RlbCBmcm9tIHRoZSBPbGxhbWEgcmVnaXN0cnkuIFRoZSByZXF1ZXN0IG9iamVjdCBjYW4gY29udGFpbiBhIHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIGlmIHRoZVxuICAgKiByZXNwb25zZSBzaG91bGQgYmUgc3RyZWFtZWQuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtQdWxsUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFByb2dyZXNzUmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFByb2dyZXNzUmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yXG4gICAqIGFuIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgcmVzcG9uc2UgbWVzc2FnZXMuXG4gICAqL1xuICBhc3luYyBwdWxsKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJwdWxsXCIsIHtcbiAgICAgIG5hbWU6IHJlcXVlc3QubW9kZWwsXG4gICAgICBzdHJlYW06IHJlcXVlc3Quc3RyZWFtLFxuICAgICAgaW5zZWN1cmU6IHJlcXVlc3QuaW5zZWN1cmVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHVzaGVzIGEgbW9kZWwgdG8gdGhlIE9sbGFtYSByZWdpc3RyeS4gVGhlIHJlcXVlc3Qgb2JqZWN0IGNhbiBjb250YWluIGEgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlXG4gICAqIHJlc3BvbnNlIHNob3VsZCBiZSBzdHJlYW1lZC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge1B1c2hSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8UHJvZ3Jlc3NSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8UHJvZ3Jlc3NSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3JcbiAgICogYW4gQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIHB1c2gocmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcInB1c2hcIiwge1xuICAgICAgbmFtZTogcmVxdWVzdC5tb2RlbCxcbiAgICAgIHN0cmVhbTogcmVxdWVzdC5zdHJlYW0sXG4gICAgICBpbnNlY3VyZTogcmVxdWVzdC5pbnNlY3VyZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbW9kZWwgZnJvbSB0aGUgc2VydmVyLiBUaGUgcmVxdWVzdCBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRvXG4gICAqIGRlbGV0ZS5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0RlbGV0ZVJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdGF0dXNSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZShyZXF1ZXN0KSB7XG4gICAgYXdhaXQgZGVsKFxuICAgICAgdGhpcy5mZXRjaCxcbiAgICAgIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9kZWxldGVgLFxuICAgICAgeyBuYW1lOiByZXF1ZXN0Lm1vZGVsIH0sXG4gICAgICB7IGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnMgfVxuICAgICk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9O1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYSBtb2RlbCBmcm9tIG9uZSBuYW1lIHRvIGFub3RoZXIuIFRoZSByZXF1ZXN0IG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgbmFtZSBvZiB0aGVcbiAgICogbW9kZWwgdG8gY29weSBhbmQgdGhlIG5ldyBuYW1lLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7Q29weVJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdGF0dXNSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGNvcHkocmVxdWVzdCkge1xuICAgIGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2NvcHlgLCB7IC4uLnJlcXVlc3QgfSwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIgfTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgdGhlIG1vZGVscyBvbiB0aGUgc2VydmVyLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMaXN0UmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIHRoZSByZXNwb25zZSBib2R5IGlzIG1pc3NpbmcuXG4gICAqL1xuICBhc3luYyBsaXN0KCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS90YWdzYCwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBtZXRhZGF0YSBvZiBhIG1vZGVsLiBUaGUgcmVxdWVzdCBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG5hbWUgb2YgdGhlIG1vZGVsLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7U2hvd1JlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaG93UmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBzaG93KHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL3Nob3dgLCB7XG4gICAgICAuLi5yZXF1ZXN0XG4gICAgfSwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVtYmVkcyB0ZXh0IGlucHV0IGludG8gdmVjdG9ycy5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0VtYmVkUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEVtYmVkUmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBlbWJlZChyZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9lbWJlZGAsIHtcbiAgICAgIC4uLnJlcXVlc3RcbiAgICB9LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRW1iZWRzIGEgdGV4dCBwcm9tcHQgaW50byBhIHZlY3Rvci5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0VtYmVkZGluZ3NSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8RW1iZWRkaW5nc1Jlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgZW1iZWRkaW5ncyhyZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9lbWJlZGRpbmdzYCwge1xuICAgICAgLi4ucmVxdWVzdFxuICAgIH0sIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgcnVubmluZyBtb2RlbHMgb24gdGhlIHNlcnZlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMaXN0UmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIHRoZSByZXNwb25zZSBib2R5IGlzIG1pc3NpbmcuXG4gICAqL1xuICBhc3luYyBwcygpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvcHNgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxufTtcbmNvbnN0IGJyb3dzZXIgPSBuZXcgT2xsYW1hJDEoKTtcblxuZXhwb3J0IHsgT2xsYW1hJDEgYXMgT2xsYW1hLCBicm93c2VyIGFzIGRlZmF1bHQgfTtcbiIsICIvKiFcbiAqIG11c3RhY2hlLmpzIC0gTG9naWMtbGVzcyB7e211c3RhY2hlfX0gdGVtcGxhdGVzIHdpdGggSmF2YVNjcmlwdFxuICogaHR0cDovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qc1xuICovXG5cbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheVBvbHlmaWxsIChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBNb3JlIGNvcnJlY3QgdHlwZW9mIHN0cmluZyBoYW5kbGluZyBhcnJheVxuICogd2hpY2ggbm9ybWFsbHkgcmV0dXJucyB0eXBlb2YgJ29iamVjdCdcbiAqL1xuZnVuY3Rpb24gdHlwZVN0ciAob2JqKSB7XG4gIHJldHVybiBpc0FycmF5KG9iaikgPyAnYXJyYXknIDogdHlwZW9mIG9iajtcbn1cblxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwIChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xufVxuXG4vKipcbiAqIE51bGwgc2FmZSB3YXkgb2YgY2hlY2tpbmcgd2hldGhlciBvciBub3QgYW4gb2JqZWN0LFxuICogaW5jbHVkaW5nIGl0cyBwcm90b3R5cGUsIGhhcyBhIGdpdmVuIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGhhc1Byb3BlcnR5IChvYmosIHByb3BOYW1lKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAocHJvcE5hbWUgaW4gb2JqKTtcbn1cblxuLyoqXG4gKiBTYWZlIHdheSBvZiBkZXRlY3Rpbmcgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIHRoaW5nIGlzIGEgcHJpbWl0aXZlIGFuZFxuICogd2hldGhlciBpdCBoYXMgdGhlIGdpdmVuIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIHByaW1pdGl2ZUhhc093blByb3BlcnR5IChwcmltaXRpdmUsIHByb3BOYW1lKSB7XG4gIHJldHVybiAoXG4gICAgcHJpbWl0aXZlICE9IG51bGxcbiAgICAmJiB0eXBlb2YgcHJpbWl0aXZlICE9PSAnb2JqZWN0J1xuICAgICYmIHByaW1pdGl2ZS5oYXNPd25Qcm9wZXJ0eVxuICAgICYmIHByaW1pdGl2ZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSlcbiAgKTtcbn1cblxuLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9pc3N1ZXMuYXBhY2hlLm9yZy9qaXJhL2Jyb3dzZS9DT1VDSERCLTU3N1xuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8xODlcbnZhciByZWdFeHBUZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xuZnVuY3Rpb24gdGVzdFJlZ0V4cCAocmUsIHN0cmluZykge1xuICByZXR1cm4gcmVnRXhwVGVzdC5jYWxsKHJlLCBzdHJpbmcpO1xufVxuXG52YXIgbm9uU3BhY2VSZSA9IC9cXFMvO1xuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChzdHJpbmcpIHtcbiAgcmV0dXJuICF0ZXN0UmVnRXhwKG5vblNwYWNlUmUsIHN0cmluZyk7XG59XG5cbnZhciBlbnRpdHlNYXAgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5OycsXG4gICcvJzogJyYjeDJGOycsXG4gICdgJzogJyYjeDYwOycsXG4gICc9JzogJyYjeDNEOydcbn07XG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwgKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvWyY8PlwiJ2A9XFwvXS9nLCBmdW5jdGlvbiBmcm9tRW50aXR5TWFwIChzKSB7XG4gICAgcmV0dXJuIGVudGl0eU1hcFtzXTtcbiAgfSk7XG59XG5cbnZhciB3aGl0ZVJlID0gL1xccyovO1xudmFyIHNwYWNlUmUgPSAvXFxzKy87XG52YXIgZXF1YWxzUmUgPSAvXFxzKj0vO1xudmFyIGN1cmx5UmUgPSAvXFxzKlxcfS87XG52YXIgdGFnUmUgPSAvI3xcXF58XFwvfD58XFx7fCZ8PXwhLztcblxuLyoqXG4gKiBCcmVha3MgdXAgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgc3RyaW5nIGludG8gYSB0cmVlIG9mIHRva2Vucy4gSWYgdGhlIGB0YWdzYFxuICogYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIHN0cmluZyB2YWx1ZXM6IHRoZVxuICogb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIChlLmcuIFsgXCI8JVwiLCBcIiU+XCIgXSkuIE9mXG4gKiBjb3Vyc2UsIHRoZSBkZWZhdWx0IGlzIHRvIHVzZSBtdXN0YWNoZXMgKGkuZS4gbXVzdGFjaGUudGFncykuXG4gKlxuICogQSB0b2tlbiBpcyBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IDQgZWxlbWVudHMuIFRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZVxuICogbXVzdGFjaGUgc3ltYm9sIHRoYXQgd2FzIHVzZWQgaW5zaWRlIHRoZSB0YWcsIGUuZy4gXCIjXCIgb3IgXCImXCIuIElmIHRoZSB0YWdcbiAqIGRpZCBub3QgY29udGFpbiBhIHN5bWJvbCAoaS5lLiB7e215VmFsdWV9fSkgdGhpcyBlbGVtZW50IGlzIFwibmFtZVwiLiBGb3JcbiAqIGFsbCB0ZXh0IHRoYXQgYXBwZWFycyBvdXRzaWRlIGEgc3ltYm9sIHRoaXMgZWxlbWVudCBpcyBcInRleHRcIi5cbiAqXG4gKiBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgYSB0b2tlbiBpcyBpdHMgXCJ2YWx1ZVwiLiBGb3IgbXVzdGFjaGUgdGFncyB0aGlzIGlzXG4gKiB3aGF0ZXZlciBlbHNlIHdhcyBpbnNpZGUgdGhlIHRhZyBiZXNpZGVzIHRoZSBvcGVuaW5nIHN5bWJvbC4gRm9yIHRleHQgdG9rZW5zXG4gKiB0aGlzIGlzIHRoZSB0ZXh0IGl0c2VsZi5cbiAqXG4gKiBUaGUgdGhpcmQgYW5kIGZvdXJ0aCBlbGVtZW50cyBvZiB0aGUgdG9rZW4gYXJlIHRoZSBzdGFydCBhbmQgZW5kIGluZGljZXMsXG4gKiByZXNwZWN0aXZlbHksIG9mIHRoZSB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXG4gKlxuICogVG9rZW5zIHRoYXQgYXJlIHRoZSByb290IG5vZGUgb2YgYSBzdWJ0cmVlIGNvbnRhaW4gdHdvIG1vcmUgZWxlbWVudHM6IDEpIGFuXG4gKiBhcnJheSBvZiB0b2tlbnMgaW4gdGhlIHN1YnRyZWUgYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgYXRcbiAqIHdoaWNoIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhhdCBzZWN0aW9uIGJlZ2lucy5cbiAqXG4gKiBUb2tlbnMgZm9yIHBhcnRpYWxzIGFsc28gY29udGFpbiB0d28gbW9yZSBlbGVtZW50czogMSkgYSBzdHJpbmcgdmFsdWUgb2ZcbiAqIGluZGVuZGF0aW9uIHByaW9yIHRvIHRoYXQgdGFnIGFuZCAyKSB0aGUgaW5kZXggb2YgdGhhdCB0YWcgb24gdGhhdCBsaW5lIC1cbiAqIGVnIGEgdmFsdWUgb2YgMiBpbmRpY2F0ZXMgdGhlIHBhcnRpYWwgaXMgdGhlIHRoaXJkIHRhZyBvbiB0aGlzIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUgKHRlbXBsYXRlLCB0YWdzKSB7XG4gIGlmICghdGVtcGxhdGUpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgbGluZUhhc05vblNwYWNlID0gZmFsc2U7XG4gIHZhciBzZWN0aW9ucyA9IFtdOyAgICAgLy8gU3RhY2sgdG8gaG9sZCBzZWN0aW9uIHRva2Vuc1xuICB2YXIgdG9rZW5zID0gW107ICAgICAgIC8vIEJ1ZmZlciB0byBob2xkIHRoZSB0b2tlbnNcbiAgdmFyIHNwYWNlcyA9IFtdOyAgICAgICAvLyBJbmRpY2VzIG9mIHdoaXRlc3BhY2UgdG9rZW5zIG9uIHRoZSBjdXJyZW50IGxpbmVcbiAgdmFyIGhhc1RhZyA9IGZhbHNlOyAgICAvLyBJcyB0aGVyZSBhIHt7dGFnfX0gb24gdGhlIGN1cnJlbnQgbGluZT9cbiAgdmFyIG5vblNwYWNlID0gZmFsc2U7ICAvLyBJcyB0aGVyZSBhIG5vbi1zcGFjZSBjaGFyIG9uIHRoZSBjdXJyZW50IGxpbmU/XG4gIHZhciBpbmRlbnRhdGlvbiA9ICcnOyAgLy8gVHJhY2tzIGluZGVudGF0aW9uIGZvciB0YWdzIHRoYXQgdXNlIGl0XG4gIHZhciB0YWdJbmRleCA9IDA7ICAgICAgLy8gU3RvcmVzIGEgY291bnQgb2YgbnVtYmVyIG9mIHRhZ3MgZW5jb3VudGVyZWQgb24gYSBsaW5lXG5cbiAgLy8gU3RyaXBzIGFsbCB3aGl0ZXNwYWNlIHRva2VucyBhcnJheSBmb3IgdGhlIGN1cnJlbnQgbGluZVxuICAvLyBpZiB0aGVyZSB3YXMgYSB7eyN0YWd9fSBvbiBpdCBhbmQgb3RoZXJ3aXNlIG9ubHkgc3BhY2UuXG4gIGZ1bmN0aW9uIHN0cmlwU3BhY2UgKCkge1xuICAgIGlmIChoYXNUYWcgJiYgIW5vblNwYWNlKSB7XG4gICAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aClcbiAgICAgICAgZGVsZXRlIHRva2Vuc1tzcGFjZXMucG9wKCldO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcGFjZXMgPSBbXTtcbiAgICB9XG5cbiAgICBoYXNUYWcgPSBmYWxzZTtcbiAgICBub25TcGFjZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIG9wZW5pbmdUYWdSZSwgY2xvc2luZ1RhZ1JlLCBjbG9zaW5nQ3VybHlSZTtcbiAgZnVuY3Rpb24gY29tcGlsZVRhZ3MgKHRhZ3NUb0NvbXBpbGUpIHtcbiAgICBpZiAodHlwZW9mIHRhZ3NUb0NvbXBpbGUgPT09ICdzdHJpbmcnKVxuICAgICAgdGFnc1RvQ29tcGlsZSA9IHRhZ3NUb0NvbXBpbGUuc3BsaXQoc3BhY2VSZSwgMik7XG5cbiAgICBpZiAoIWlzQXJyYXkodGFnc1RvQ29tcGlsZSkgfHwgdGFnc1RvQ29tcGlsZS5sZW5ndGggIT09IDIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFnczogJyArIHRhZ3NUb0NvbXBpbGUpO1xuXG4gICAgb3BlbmluZ1RhZ1JlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodGFnc1RvQ29tcGlsZVswXSkgKyAnXFxcXHMqJyk7XG4gICAgY2xvc2luZ1RhZ1JlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgY2xvc2luZ0N1cmx5UmUgPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlUmVnRXhwKCd9JyArIHRhZ3NUb0NvbXBpbGVbMV0pKTtcbiAgfVxuXG4gIGNvbXBpbGVUYWdzKHRhZ3MgfHwgbXVzdGFjaGUudGFncyk7XG5cbiAgdmFyIHNjYW5uZXIgPSBuZXcgU2Nhbm5lcih0ZW1wbGF0ZSk7XG5cbiAgdmFyIHN0YXJ0LCB0eXBlLCB2YWx1ZSwgY2hyLCB0b2tlbiwgb3BlblNlY3Rpb247XG4gIHdoaWxlICghc2Nhbm5lci5lb3MoKSkge1xuICAgIHN0YXJ0ID0gc2Nhbm5lci5wb3M7XG5cbiAgICAvLyBNYXRjaCBhbnkgdGV4dCBiZXR3ZWVuIHRhZ3MuXG4gICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChvcGVuaW5nVGFnUmUpO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGkgPCB2YWx1ZUxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNociA9IHZhbHVlLmNoYXJBdChpKTtcblxuICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGNocikpIHtcbiAgICAgICAgICBzcGFjZXMucHVzaCh0b2tlbnMubGVuZ3RoKTtcbiAgICAgICAgICBpbmRlbnRhdGlvbiArPSBjaHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgICAgICAgIGxpbmVIYXNOb25TcGFjZSA9IHRydWU7XG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW5zLnB1c2goWyAndGV4dCcsIGNociwgc3RhcnQsIHN0YXJ0ICsgMSBdKTtcbiAgICAgICAgc3RhcnQgKz0gMTtcblxuICAgICAgICAvLyBDaGVjayBmb3Igd2hpdGVzcGFjZSBvbiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgICBpZiAoY2hyID09PSAnXFxuJykge1xuICAgICAgICAgIHN0cmlwU3BhY2UoKTtcbiAgICAgICAgICBpbmRlbnRhdGlvbiA9ICcnO1xuICAgICAgICAgIHRhZ0luZGV4ID0gMDtcbiAgICAgICAgICBsaW5lSGFzTm9uU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1hdGNoIHRoZSBvcGVuaW5nIHRhZy5cbiAgICBpZiAoIXNjYW5uZXIuc2NhbihvcGVuaW5nVGFnUmUpKVxuICAgICAgYnJlYWs7XG5cbiAgICBoYXNUYWcgPSB0cnVlO1xuXG4gICAgLy8gR2V0IHRoZSB0YWcgdHlwZS5cbiAgICB0eXBlID0gc2Nhbm5lci5zY2FuKHRhZ1JlKSB8fCAnbmFtZSc7XG4gICAgc2Nhbm5lci5zY2FuKHdoaXRlUmUpO1xuXG4gICAgLy8gR2V0IHRoZSB0YWcgdmFsdWUuXG4gICAgaWYgKHR5cGUgPT09ICc9Jykge1xuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChlcXVhbHNSZSk7XG4gICAgICBzY2FubmVyLnNjYW4oZXF1YWxzUmUpO1xuICAgICAgc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nQ3VybHlSZSk7XG4gICAgICBzY2FubmVyLnNjYW4oY3VybHlSZSk7XG4gICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgdHlwZSA9ICcmJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgIH1cblxuICAgIC8vIE1hdGNoIHRoZSBjbG9zaW5nIHRhZy5cbiAgICBpZiAoIXNjYW5uZXIuc2NhbihjbG9zaW5nVGFnUmUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCB0YWcgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgIGlmICh0eXBlID09ICc+Jykge1xuICAgICAgdG9rZW4gPSBbIHR5cGUsIHZhbHVlLCBzdGFydCwgc2Nhbm5lci5wb3MsIGluZGVudGF0aW9uLCB0YWdJbmRleCwgbGluZUhhc05vblNwYWNlIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuID0gWyB0eXBlLCB2YWx1ZSwgc3RhcnQsIHNjYW5uZXIucG9zIF07XG4gICAgfVxuICAgIHRhZ0luZGV4Kys7XG4gICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgaWYgKHR5cGUgPT09ICcjJyB8fCB0eXBlID09PSAnXicpIHtcbiAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJy8nKSB7XG4gICAgICAvLyBDaGVjayBzZWN0aW9uIG5lc3RpbmcuXG4gICAgICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gICAgICBpZiAoIW9wZW5TZWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vub3BlbmVkIHNlY3Rpb24gXCInICsgdmFsdWUgKyAnXCIgYXQgJyArIHN0YXJ0KTtcblxuICAgICAgaWYgKG9wZW5TZWN0aW9uWzFdICE9PSB2YWx1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzdGFydCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbmFtZScgfHwgdHlwZSA9PT0gJ3snIHx8IHR5cGUgPT09ICcmJykge1xuICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAvLyBTZXQgdGhlIHRhZ3MgZm9yIHRoZSBuZXh0IHRpbWUgYXJvdW5kLlxuICAgICAgY29tcGlsZVRhZ3ModmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHN0cmlwU3BhY2UoKTtcblxuICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIG9wZW4gc2VjdGlvbnMgd2hlbiB3ZSdyZSBkb25lLlxuICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gIGlmIChvcGVuU2VjdGlvbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICByZXR1cm4gbmVzdFRva2VucyhzcXVhc2hUb2tlbnModG9rZW5zKSk7XG59XG5cbi8qKlxuICogQ29tYmluZXMgdGhlIHZhbHVlcyBvZiBjb25zZWN1dGl2ZSB0ZXh0IHRva2VucyBpbiB0aGUgZ2l2ZW4gYHRva2Vuc2AgYXJyYXlcbiAqIHRvIGEgc2luZ2xlIHRva2VuLlxuICovXG5mdW5jdGlvbiBzcXVhc2hUb2tlbnMgKHRva2Vucykge1xuICB2YXIgc3F1YXNoZWRUb2tlbnMgPSBbXTtcblxuICB2YXIgdG9rZW4sIGxhc3RUb2tlbjtcbiAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBpZiAodG9rZW5bMF0gPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4gJiYgbGFzdFRva2VuWzBdID09PSAndGV4dCcpIHtcbiAgICAgICAgbGFzdFRva2VuWzFdICs9IHRva2VuWzFdO1xuICAgICAgICBsYXN0VG9rZW5bM10gPSB0b2tlblszXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNxdWFzaGVkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3F1YXNoZWRUb2tlbnM7XG59XG5cbi8qKlxuICogRm9ybXMgdGhlIGdpdmVuIGFycmF5IG9mIGB0b2tlbnNgIGludG8gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUgd2hlcmVcbiAqIHRva2VucyB0aGF0IHJlcHJlc2VudCBhIHNlY3Rpb24gaGF2ZSB0d28gYWRkaXRpb25hbCBpdGVtczogMSkgYW4gYXJyYXkgb2ZcbiAqIGFsbCB0b2tlbnMgdGhhdCBhcHBlYXIgaW4gdGhhdCBzZWN0aW9uIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsXG4gKiB0ZW1wbGF0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGVuZCBvZiB0aGF0IHNlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG5lc3RUb2tlbnMgKHRva2Vucykge1xuICB2YXIgbmVzdGVkVG9rZW5zID0gW107XG4gIHZhciBjb2xsZWN0b3IgPSBuZXN0ZWRUb2tlbnM7XG4gIHZhciBzZWN0aW9ucyA9IFtdO1xuXG4gIHZhciB0b2tlbiwgc2VjdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgY2FzZSAnIyc6XG4gICAgICBjYXNlICdeJzpcbiAgICAgICAgY29sbGVjdG9yLnB1c2godG9rZW4pO1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29sbGVjdG9yID0gdG9rZW5bNF0gPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcvJzpcbiAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuICAgICAgICBzZWN0aW9uWzVdID0gdG9rZW5bMl07XG4gICAgICAgIGNvbGxlY3RvciA9IHNlY3Rpb25zLmxlbmd0aCA+IDAgPyBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXVs0XSA6IG5lc3RlZFRva2VucztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lc3RlZFRva2Vucztcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBzdHJpbmcgc2Nhbm5lciB0aGF0IGlzIHVzZWQgYnkgdGhlIHRlbXBsYXRlIHBhcnNlciB0byBmaW5kXG4gKiB0b2tlbnMgaW4gdGVtcGxhdGUgc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gU2Nhbm5lciAoc3RyaW5nKSB7XG4gIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICB0aGlzLnRhaWwgPSBzdHJpbmc7XG4gIHRoaXMucG9zID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGFpbCBpcyBlbXB0eSAoZW5kIG9mIHN0cmluZykuXG4gKi9cblNjYW5uZXIucHJvdG90eXBlLmVvcyA9IGZ1bmN0aW9uIGVvcyAoKSB7XG4gIHJldHVybiB0aGlzLnRhaWwgPT09ICcnO1xufTtcblxuLyoqXG4gKiBUcmllcyB0byBtYXRjaCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICogUmV0dXJucyB0aGUgbWF0Y2hlZCB0ZXh0IGlmIGl0IGNhbiBtYXRjaCwgdGhlIGVtcHR5IHN0cmluZyBvdGhlcndpc2UuXG4gKi9cblNjYW5uZXIucHJvdG90eXBlLnNjYW4gPSBmdW5jdGlvbiBzY2FuIChyZSkge1xuICB2YXIgbWF0Y2ggPSB0aGlzLnRhaWwubWF0Y2gocmUpO1xuXG4gIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggIT09IDApXG4gICAgcmV0dXJuICcnO1xuXG4gIHZhciBzdHJpbmcgPSBtYXRjaFswXTtcblxuICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpO1xuICB0aGlzLnBvcyArPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIFNraXBzIGFsbCB0ZXh0IHVudGlsIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gY2FuIGJlIG1hdGNoZWQuIFJldHVybnNcbiAqIHRoZSBza2lwcGVkIHN0cmluZywgd2hpY2ggaXMgdGhlIGVudGlyZSB0YWlsIGlmIG5vIG1hdGNoIGNhbiBiZSBtYWRlLlxuICovXG5TY2FubmVyLnByb3RvdHlwZS5zY2FuVW50aWwgPSBmdW5jdGlvbiBzY2FuVW50aWwgKHJlKSB7XG4gIHZhciBpbmRleCA9IHRoaXMudGFpbC5zZWFyY2gocmUpLCBtYXRjaDtcblxuICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgY2FzZSAtMTpcbiAgICAgIG1hdGNoID0gdGhpcy50YWlsO1xuICAgICAgdGhpcy50YWlsID0gJyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDA6XG4gICAgICBtYXRjaCA9ICcnO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG1hdGNoID0gdGhpcy50YWlsLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKGluZGV4KTtcbiAgfVxuXG4gIHRoaXMucG9zICs9IG1hdGNoLmxlbmd0aDtcblxuICByZXR1cm4gbWF0Y2g7XG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSByZW5kZXJpbmcgY29udGV4dCBieSB3cmFwcGluZyBhIHZpZXcgb2JqZWN0IGFuZFxuICogbWFpbnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBDb250ZXh0ICh2aWV3LCBwYXJlbnRDb250ZXh0KSB7XG4gIHRoaXMudmlldyA9IHZpZXc7XG4gIHRoaXMuY2FjaGUgPSB7ICcuJzogdGhpcy52aWV3IH07XG4gIHRoaXMucGFyZW50ID0gcGFyZW50Q29udGV4dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNvbnRleHQgdXNpbmcgdGhlIGdpdmVuIHZpZXcgd2l0aCB0aGlzIGNvbnRleHRcbiAqIGFzIHRoZSBwYXJlbnQuXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoICh2aWV3KSB7XG4gIHJldHVybiBuZXcgQ29udGV4dCh2aWV3LCB0aGlzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIG5hbWUgaW4gdGhpcyBjb250ZXh0LCB0cmF2ZXJzaW5nXG4gKiB1cCB0aGUgY29udGV4dCBoaWVyYXJjaHkgaWYgdGhlIHZhbHVlIGlzIGFic2VudCBpbiB0aGlzIGNvbnRleHQncyB2aWV3LlxuICovXG5Db250ZXh0LnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiBsb29rdXAgKG5hbWUpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuICB2YXIgdmFsdWU7XG4gIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHZhbHVlID0gY2FjaGVbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLCBpbnRlcm1lZGlhdGVWYWx1ZSwgbmFtZXMsIGluZGV4LCBsb29rdXBIaXQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChjb250ZXh0KSB7XG4gICAgICBpZiAobmFtZS5pbmRleE9mKCcuJykgPiAwKSB7XG4gICAgICAgIGludGVybWVkaWF0ZVZhbHVlID0gY29udGV4dC52aWV3O1xuICAgICAgICBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgaW5kZXggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2luZyB0aGUgZG90IG5vdGlvbiBwYXRoIGluIGBuYW1lYCwgd2UgZGVzY2VuZCB0aHJvdWdoIHRoZVxuICAgICAgICAgKiBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gYmUgY2VydGFpbiB0aGF0IHRoZSBsb29rdXAgaGFzIGJlZW4gc3VjY2Vzc2Z1bCwgd2UgaGF2ZSB0b1xuICAgICAgICAgKiBjaGVjayBpZiB0aGUgbGFzdCBvYmplY3QgaW4gdGhlIHBhdGggYWN0dWFsbHkgaGFzIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgKiB3ZSBhcmUgbG9va2luZyBmb3IuIFdlIHN0b3JlIHRoZSByZXN1bHQgaW4gYGxvb2t1cEhpdGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgc3BlY2lhbGx5IG5lY2Vzc2FyeSBmb3Igd2hlbiB0aGUgdmFsdWUgaGFzIGJlZW4gc2V0IHRvXG4gICAgICAgICAqIGB1bmRlZmluZWRgIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGxvb2tpbmcgdXAgcGFyZW50IGNvbnRleHRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSBkb3Qgbm90YXRpb24gaXMgdXNlZCwgd2UgY29uc2lkZXIgdGhlIGxvb2t1cFxuICAgICAgICAgKiB0byBiZSBzdWNjZXNzZnVsIGV2ZW4gaWYgdGhlIGxhc3QgXCJvYmplY3RcIiBpbiB0aGUgcGF0aCBpc1xuICAgICAgICAgKiBub3QgYWN0dWFsbHkgYW4gb2JqZWN0IGJ1dCBhIHByaW1pdGl2ZSAoZS5nLiwgYSBzdHJpbmcsIG9yIGFuXG4gICAgICAgICAqIGludGVnZXIpLCBiZWNhdXNlIGl0IGlzIHNvbWV0aW1lcyB1c2VmdWwgdG8gYWNjZXNzIGEgcHJvcGVydHlcbiAgICAgICAgICogb2YgYW4gYXV0b2JveGVkIHByaW1pdGl2ZSwgc3VjaCBhcyB0aGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxuICAgICAgICAgKiovXG4gICAgICAgIHdoaWxlIChpbnRlcm1lZGlhdGVWYWx1ZSAhPSBudWxsICYmIGluZGV4IDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSBuYW1lcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgbG9va3VwSGl0ID0gKFxuICAgICAgICAgICAgICBoYXNQcm9wZXJ0eShpbnRlcm1lZGlhdGVWYWx1ZSwgbmFtZXNbaW5kZXhdKVxuICAgICAgICAgICAgICB8fCBwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eShpbnRlcm1lZGlhdGVWYWx1ZSwgbmFtZXNbaW5kZXhdKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIGludGVybWVkaWF0ZVZhbHVlID0gaW50ZXJtZWRpYXRlVmFsdWVbbmFtZXNbaW5kZXgrK11dO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZSA9IGNvbnRleHQudmlld1tuYW1lXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBjaGVja2luZyBhZ2FpbnN0IGBoYXNQcm9wZXJ0eWAsIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAgaWZcbiAgICAgICAgICogYGNvbnRleHQudmlld2AgaXMgbm90IGFuIG9iamVjdC4gRGVsaWJlcmF0ZWx5IG9taXR0aW5nIHRoZSBjaGVja1xuICAgICAgICAgKiBhZ2FpbnN0IGBwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eWAgaWYgZG90IG5vdGF0aW9uIGlzIG5vdCB1c2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb25zaWRlciB0aGlzIGV4YW1wbGU6XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBNdXN0YWNoZS5yZW5kZXIoXCJUaGUgbGVuZ3RoIG9mIGEgZm9vdGJhbGwgZmllbGQgaXMge3sjbGVuZ3RofX17e2xlbmd0aH19e3svbGVuZ3RofX0uXCIsIHtsZW5ndGg6IFwiMTAwIHlhcmRzXCJ9KVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogSWYgd2Ugd2VyZSB0byBjaGVjayBhbHNvIGFnYWluc3QgYHByaW1pdGl2ZUhhc093blByb3BlcnR5YCwgYXMgd2UgZG9cbiAgICAgICAgICogaW4gdGhlIGRvdCBub3RhdGlvbiBjYXNlLCB0aGVuIHJlbmRlciBjYWxsIHdvdWxkIHJldHVybjpcbiAgICAgICAgICpcbiAgICAgICAgICogXCJUaGUgbGVuZ3RoIG9mIGEgZm9vdGJhbGwgZmllbGQgaXMgOS5cIlxuICAgICAgICAgKlxuICAgICAgICAgKiByYXRoZXIgdGhhbiB0aGUgZXhwZWN0ZWQ6XG4gICAgICAgICAqXG4gICAgICAgICAqIFwiVGhlIGxlbmd0aCBvZiBhIGZvb3RiYWxsIGZpZWxkIGlzIDEwMCB5YXJkcy5cIlxuICAgICAgICAgKiovXG4gICAgICAgIGxvb2t1cEhpdCA9IGhhc1Byb3BlcnR5KGNvbnRleHQudmlldywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsb29rdXBIaXQpIHtcbiAgICAgICAgdmFsdWUgPSBpbnRlcm1lZGlhdGVWYWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICB9XG5cbiAgICBjYWNoZVtuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKVxuICAgIHZhbHVlID0gdmFsdWUuY2FsbCh0aGlzLnZpZXcpO1xuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogQSBXcml0ZXIga25vd3MgaG93IHRvIHRha2UgYSBzdHJlYW0gb2YgdG9rZW5zIGFuZCByZW5kZXIgdGhlbSB0byBhXG4gKiBzdHJpbmcsIGdpdmVuIGEgY29udGV4dC4gSXQgYWxzbyBtYWludGFpbnMgYSBjYWNoZSBvZiB0ZW1wbGF0ZXMgdG9cbiAqIGF2b2lkIHRoZSBuZWVkIHRvIHBhcnNlIHRoZSBzYW1lIHRlbXBsYXRlIHR3aWNlLlxuICovXG5mdW5jdGlvbiBXcml0ZXIgKCkge1xuICB0aGlzLnRlbXBsYXRlQ2FjaGUgPSB7XG4gICAgX2NhY2hlOiB7fSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5fY2FjaGVba2V5XSA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW2tleV07XG4gICAgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2xlYXJzIGFsbCBjYWNoZWQgdGVtcGxhdGVzIGluIHRoaXMgd3JpdGVyLlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLnRlbXBsYXRlQ2FjaGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy50ZW1wbGF0ZUNhY2hlLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBgdGFnc2Agb3JcbiAqIGBtdXN0YWNoZS50YWdzYCBpZiBgdGFnc2AgaXMgb21pdHRlZCwgIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiB0b2tlbnNcbiAqIHRoYXQgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHBhcnNlLlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMudGVtcGxhdGVDYWNoZTtcbiAgdmFyIGNhY2hlS2V5ID0gdGVtcGxhdGUgKyAnOicgKyAodGFncyB8fCBtdXN0YWNoZS50YWdzKS5qb2luKCc6Jyk7XG4gIHZhciBpc0NhY2hlRW5hYmxlZCA9IHR5cGVvZiBjYWNoZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciB0b2tlbnMgPSBpc0NhY2hlRW5hYmxlZCA/IGNhY2hlLmdldChjYWNoZUtleSkgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKHRva2VucyA9PSB1bmRlZmluZWQpIHtcbiAgICB0b2tlbnMgPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0YWdzKTtcbiAgICBpc0NhY2hlRW5hYmxlZCAmJiBjYWNoZS5zZXQoY2FjaGVLZXksIHRva2Vucyk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucztcbn07XG5cbi8qKlxuICogSGlnaC1sZXZlbCBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCB3aXRoXG4gKiB0aGUgZ2l2ZW4gYHZpZXdgLlxuICpcbiAqIFRoZSBvcHRpb25hbCBgcGFydGlhbHNgIGFyZ3VtZW50IG1heSBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcbiAqIG5hbWVzIGFuZCB0ZW1wbGF0ZXMgb2YgcGFydGlhbHMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGVtcGxhdGUuIEl0IG1heVxuICogYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBsb2FkIHBhcnRpYWwgdGVtcGxhdGVzIG9uIHRoZSBmbHlcbiAqIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQ6IHRoZSBuYW1lIG9mIHRoZSBwYXJ0aWFsLlxuICpcbiAqIElmIHRoZSBvcHRpb25hbCBgY29uZmlnYCBhcmd1bWVudCBpcyBnaXZlbiBoZXJlLCB0aGVuIGl0IHNob3VsZCBiZSBhblxuICogb2JqZWN0IHdpdGggYSBgdGFnc2AgYXR0cmlidXRlIG9yIGFuIGBlc2NhcGVgIGF0dHJpYnV0ZSBvciBib3RoLlxuICogSWYgYW4gYXJyYXkgaXMgcGFzc2VkLCB0aGVuIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgdGhlIHNhbWUgd2F5IGFzXG4gKiBhIGB0YWdzYCBhdHRyaWJ1dGUgb24gYSBgY29uZmlnYCBvYmplY3QuXG4gKlxuICogVGhlIGB0YWdzYCBhdHRyaWJ1dGUgb2YgYSBgY29uZmlnYCBvYmplY3QgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3b1xuICogc3RyaW5nIHZhbHVlczogdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSAoZS5nLlxuICogWyBcIjwlXCIsIFwiJT5cIiBdKS4gVGhlIGRlZmF1bHQgaXMgdG8gbXVzdGFjaGUudGFncy5cbiAqXG4gKiBUaGUgYGVzY2FwZWAgYXR0cmlidXRlIG9mIGEgYGNvbmZpZ2Agb2JqZWN0IG11c3QgYmUgYSBmdW5jdGlvbiB3aGljaFxuICogYWNjZXB0cyBhIHN0cmluZyBhcyBpbnB1dCBhbmQgb3V0cHV0cyBhIHNhZmVseSBlc2NhcGVkIHN0cmluZy5cbiAqIElmIGFuIGBlc2NhcGVgIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlbiBhbiBIVE1MLXNhZmUgc3RyaW5nXG4gKiBlc2NhcGluZyBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzLCBjb25maWcpIHtcbiAgdmFyIHRhZ3MgPSB0aGlzLmdldENvbmZpZ1RhZ3MoY29uZmlnKTtcbiAgdmFyIHRva2VucyA9IHRoaXMucGFyc2UodGVtcGxhdGUsIHRhZ3MpO1xuICB2YXIgY29udGV4dCA9ICh2aWV3IGluc3RhbmNlb2YgQ29udGV4dCkgPyB2aWV3IDogbmV3IENvbnRleHQodmlldywgdW5kZWZpbmVkKTtcbiAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIHRlbXBsYXRlLCBjb25maWcpO1xufTtcblxuLyoqXG4gKiBMb3ctbGV2ZWwgbWV0aG9kIHRoYXQgcmVuZGVycyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgdXNpbmdcbiAqIHRoZSBnaXZlbiBgY29udGV4dGAgYW5kIGBwYXJ0aWFsc2AuXG4gKlxuICogTm90ZTogVGhlIGBvcmlnaW5hbFRlbXBsYXRlYCBpcyBvbmx5IGV2ZXIgdXNlZCB0byBleHRyYWN0IHRoZSBwb3J0aW9uXG4gKiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB3YXMgY29udGFpbmVkIGluIGEgaGlnaGVyLW9yZGVyIHNlY3Rpb24uXG4gKiBJZiB0aGUgdGVtcGxhdGUgZG9lc24ndCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLCB0aGlzIGFyZ3VtZW50IG1heVxuICogYmUgb21pdHRlZC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbnMgPSBmdW5jdGlvbiByZW5kZXJUb2tlbnMgKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZykge1xuICB2YXIgYnVmZmVyID0gJyc7XG5cbiAgdmFyIHRva2VuLCBzeW1ib2wsIHZhbHVlO1xuICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgc3ltYm9sID0gdG9rZW5bMF07XG5cbiAgICBpZiAoc3ltYm9sID09PSAnIycpIHZhbHVlID0gdGhpcy5yZW5kZXJTZWN0aW9uKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbiAgICBlbHNlIGlmIChzeW1ib2wgPT09ICdeJykgdmFsdWUgPSB0aGlzLnJlbmRlckludmVydGVkKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbiAgICBlbHNlIGlmIChzeW1ib2wgPT09ICc+JykgdmFsdWUgPSB0aGlzLnJlbmRlclBhcnRpYWwodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBjb25maWcpO1xuICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJyYnKSB2YWx1ZSA9IHRoaXMudW5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ25hbWUnKSB2YWx1ZSA9IHRoaXMuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0LCBjb25maWcpO1xuICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ3RleHQnKSB2YWx1ZSA9IHRoaXMucmF3VmFsdWUodG9rZW4pO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICBidWZmZXIgKz0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJTZWN0aW9uID0gZnVuY3Rpb24gcmVuZGVyU2VjdGlvbiAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYnVmZmVyID0gJyc7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVuZGVyIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAvLyBpbiB0aGUgY3VycmVudCBjb250ZXh0IGJ5IGhpZ2hlci1vcmRlciBzZWN0aW9ucy5cbiAgZnVuY3Rpb24gc3ViUmVuZGVyICh0ZW1wbGF0ZSkge1xuICAgIHJldHVybiBzZWxmLnJlbmRlcih0ZW1wbGF0ZSwgY29udGV4dCwgcGFydGlhbHMsIGNvbmZpZyk7XG4gIH1cblxuICBpZiAoIXZhbHVlKSByZXR1cm47XG5cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBqIDwgdmFsdWVMZW5ndGg7ICsraikge1xuICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LnB1c2godmFsdWVbal0pLCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbFRlbXBsYXRlICE9PSAnc3RyaW5nJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMgd2l0aG91dCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUnKTtcblxuICAgIC8vIEV4dHJhY3QgdGhlIHBvcnRpb24gb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgdGhlIHNlY3Rpb24gY29udGFpbnMuXG4gICAgdmFsdWUgPSB2YWx1ZS5jYWxsKGNvbnRleHQudmlldywgb3JpZ2luYWxUZW1wbGF0ZS5zbGljZSh0b2tlblszXSwgdG9rZW5bNV0pLCBzdWJSZW5kZXIpO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICBidWZmZXIgKz0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJJbnZlcnRlZCA9IGZ1bmN0aW9uIHJlbmRlckludmVydGVkICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZykge1xuICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgLy8gVXNlIEphdmFTY3JpcHQncyBkZWZpbml0aW9uIG9mIGZhbHN5LiBJbmNsdWRlIGVtcHR5IGFycmF5cy5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8xODZcbiAgaWYgKCF2YWx1ZSB8fCAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSlcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5pbmRlbnRQYXJ0aWFsID0gZnVuY3Rpb24gaW5kZW50UGFydGlhbCAocGFydGlhbCwgaW5kZW50YXRpb24sIGxpbmVIYXNOb25TcGFjZSkge1xuICB2YXIgZmlsdGVyZWRJbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uLnJlcGxhY2UoL1teIFxcdF0vZywgJycpO1xuICB2YXIgcGFydGlhbEJ5TmwgPSBwYXJ0aWFsLnNwbGl0KCdcXG4nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWFsQnlObC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJ0aWFsQnlObFtpXS5sZW5ndGggJiYgKGkgPiAwIHx8ICFsaW5lSGFzTm9uU3BhY2UpKSB7XG4gICAgICBwYXJ0aWFsQnlObFtpXSA9IGZpbHRlcmVkSW5kZW50YXRpb24gKyBwYXJ0aWFsQnlObFtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRpYWxCeU5sLmpvaW4oJ1xcbicpO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJQYXJ0aWFsID0gZnVuY3Rpb24gcmVuZGVyUGFydGlhbCAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBjb25maWcpIHtcbiAgaWYgKCFwYXJ0aWFscykgcmV0dXJuO1xuICB2YXIgdGFncyA9IHRoaXMuZ2V0Q29uZmlnVGFncyhjb25maWcpO1xuXG4gIHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24ocGFydGlhbHMpID8gcGFydGlhbHModG9rZW5bMV0pIDogcGFydGlhbHNbdG9rZW5bMV1dO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHZhciBsaW5lSGFzTm9uU3BhY2UgPSB0b2tlbls2XTtcbiAgICB2YXIgdGFnSW5kZXggPSB0b2tlbls1XTtcbiAgICB2YXIgaW5kZW50YXRpb24gPSB0b2tlbls0XTtcbiAgICB2YXIgaW5kZW50ZWRWYWx1ZSA9IHZhbHVlO1xuICAgIGlmICh0YWdJbmRleCA9PSAwICYmIGluZGVudGF0aW9uKSB7XG4gICAgICBpbmRlbnRlZFZhbHVlID0gdGhpcy5pbmRlbnRQYXJ0aWFsKHZhbHVlLCBpbmRlbnRhdGlvbiwgbGluZUhhc05vblNwYWNlKTtcbiAgICB9XG4gICAgdmFyIHRva2VucyA9IHRoaXMucGFyc2UoaW5kZW50ZWRWYWx1ZSwgdGFncyk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIGluZGVudGVkVmFsdWUsIGNvbmZpZyk7XG4gIH1cbn07XG5cbldyaXRlci5wcm90b3R5cGUudW5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiB1bmVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQpIHtcbiAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLmVzY2FwZWRWYWx1ZSA9IGZ1bmN0aW9uIGVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQsIGNvbmZpZykge1xuICB2YXIgZXNjYXBlID0gdGhpcy5nZXRDb25maWdFc2NhcGUoY29uZmlnKSB8fCBtdXN0YWNoZS5lc2NhcGU7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcbiAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGVzY2FwZSA9PT0gbXVzdGFjaGUuZXNjYXBlKSA/IFN0cmluZyh2YWx1ZSkgOiBlc2NhcGUodmFsdWUpO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV07XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLmdldENvbmZpZ1RhZ3MgPSBmdW5jdGlvbiBnZXRDb25maWdUYWdzIChjb25maWcpIHtcbiAgaWYgKGlzQXJyYXkoY29uZmlnKSkge1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbiAgZWxzZSBpZiAoY29uZmlnICYmIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGNvbmZpZy50YWdzO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbldyaXRlci5wcm90b3R5cGUuZ2V0Q29uZmlnRXNjYXBlID0gZnVuY3Rpb24gZ2V0Q29uZmlnRXNjYXBlIChjb25maWcpIHtcbiAgaWYgKGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShjb25maWcpKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5lc2NhcGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxudmFyIG11c3RhY2hlID0ge1xuICBuYW1lOiAnbXVzdGFjaGUuanMnLFxuICB2ZXJzaW9uOiAnNC4yLjAnLFxuICB0YWdzOiBbICd7eycsICd9fScgXSxcbiAgY2xlYXJDYWNoZTogdW5kZWZpbmVkLFxuICBlc2NhcGU6IHVuZGVmaW5lZCxcbiAgcGFyc2U6IHVuZGVmaW5lZCxcbiAgcmVuZGVyOiB1bmRlZmluZWQsXG4gIFNjYW5uZXI6IHVuZGVmaW5lZCxcbiAgQ29udGV4dDogdW5kZWZpbmVkLFxuICBXcml0ZXI6IHVuZGVmaW5lZCxcbiAgLyoqXG4gICAqIEFsbG93cyBhIHVzZXIgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgY2FjaGluZyBzdHJhdGVneSwgYnkgcHJvdmlkaW5nIGFuXG4gICAqIG9iamVjdCB3aXRoIHNldCwgZ2V0IGFuZCBjbGVhciBtZXRob2RzLiBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gZGlzYWJsZVxuICAgKiB0aGUgY2FjaGUgYnkgc2V0dGluZyBpdCB0byB0aGUgbGl0ZXJhbCBgdW5kZWZpbmVkYC5cbiAgICovXG4gIHNldCB0ZW1wbGF0ZUNhY2hlIChjYWNoZSkge1xuICAgIGRlZmF1bHRXcml0ZXIudGVtcGxhdGVDYWNoZSA9IGNhY2hlO1xuICB9LFxuICAvKipcbiAgICogR2V0cyB0aGUgZGVmYXVsdCBvciBvdmVycmlkZGVuIGNhY2hpbmcgb2JqZWN0IGZyb20gdGhlIGRlZmF1bHQgd3JpdGVyLlxuICAgKi9cbiAgZ2V0IHRlbXBsYXRlQ2FjaGUgKCkge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLnRlbXBsYXRlQ2FjaGU7XG4gIH1cbn07XG5cbi8vIEFsbCBoaWdoLWxldmVsIG11c3RhY2hlLiogZnVuY3Rpb25zIHVzZSB0aGlzIHdyaXRlci5cbnZhciBkZWZhdWx0V3JpdGVyID0gbmV3IFdyaXRlcigpO1xuXG4vKipcbiAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGUgZGVmYXVsdCB3cml0ZXIuXG4gKi9cbm11c3RhY2hlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgcmV0dXJuIGRlZmF1bHRXcml0ZXIuY2xlYXJDYWNoZSgpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW5kIGNhY2hlcyB0aGUgZ2l2ZW4gdGVtcGxhdGUgaW4gdGhlIGRlZmF1bHQgd3JpdGVyIGFuZCByZXR1cm5zIHRoZVxuICogYXJyYXkgb2YgdG9rZW5zIGl0IGNvbnRhaW5zLiBEb2luZyB0aGlzIGFoZWFkIG9mIHRpbWUgYXZvaWRzIHRoZSBuZWVkIHRvXG4gKiBwYXJzZSB0ZW1wbGF0ZXMgb24gdGhlIGZseSBhcyB0aGV5IGFyZSByZW5kZXJlZC5cbiAqL1xubXVzdGFjaGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgcmV0dXJuIGRlZmF1bHRXcml0ZXIucGFyc2UodGVtcGxhdGUsIHRhZ3MpO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBgdGVtcGxhdGVgIHdpdGggdGhlIGdpdmVuIGB2aWV3YCwgYHBhcnRpYWxzYCwgYW5kIGBjb25maWdgXG4gKiB1c2luZyB0aGUgZGVmYXVsdCB3cml0ZXIuXG4gKi9cbm11c3RhY2hlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzLCBjb25maWcpIHtcbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRlbXBsYXRlISBUZW1wbGF0ZSBzaG91bGQgYmUgYSBcInN0cmluZ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1dCBcIicgKyB0eXBlU3RyKHRlbXBsYXRlKSArICdcIiB3YXMgZ2l2ZW4gYXMgdGhlIGZpcnN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50IGZvciBtdXN0YWNoZSNyZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKScpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRXcml0ZXIucmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgY29uZmlnKTtcbn07XG5cbi8vIEV4cG9ydCB0aGUgZXNjYXBpbmcgZnVuY3Rpb24gc28gdGhhdCB0aGUgdXNlciBtYXkgb3ZlcnJpZGUgaXQuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzI0NFxubXVzdGFjaGUuZXNjYXBlID0gZXNjYXBlSHRtbDtcblxuLy8gRXhwb3J0IHRoZXNlIG1haW5seSBmb3IgdGVzdGluZywgYnV0IGFsc28gZm9yIGFkdmFuY2VkIHVzYWdlLlxubXVzdGFjaGUuU2Nhbm5lciA9IFNjYW5uZXI7XG5tdXN0YWNoZS5Db250ZXh0ID0gQ29udGV4dDtcbm11c3RhY2hlLldyaXRlciA9IFdyaXRlcjtcblxuZXhwb3J0IGRlZmF1bHQgbXVzdGFjaGU7XG4iLCAiaW1wb3J0IE11c3RhY2hlIGZyb20gJ211c3RhY2hlJztcbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJ29ic2lkaWFuJztcblxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX1ZBUklBQkxFUyA9IGB7e3ByZV9jdXJzb3J9fVxcbnt7cG9zdF9jdXJzb3J9fSBcXG57e2FjdGl2ZV9zZW50ZW5jZX19IFxcbnt7bGFzdF9saW5lfX1gO1xuXG5pbnRlcmZhY2UgVGVtcGxhdGVBcmdzIHtcbiAgICBwcmVfY3Vyc29yOiBzdHJpbmc7XG4gICAgcG9zdF9jdXJzb3I6IHN0cmluZztcbiAgICBhY3RpdmVfc2VudGVuY2U6IHN0cmluZztcbiAgICBsYXN0X2xpbmU6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUHJvbXB0KHRlbXBsYXRlOiBzdHJpbmcsIGFyZ3M6IFRlbXBsYXRlQXJncyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIE11c3RhY2hlLnJlbmRlcih0ZW1wbGF0ZSwgYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlUHJvbXB0KGVkaXRvcjogRWRpdG9yLCB0ZW1wbGF0ZTogc3RyaW5nID0gVEVNUExBVEVfVkFSSUFCTEVTKTogc3RyaW5nIHtcbiAgICBjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgY29uc3QgcHJlQ3Vyc29yID0gZWRpdG9yLmdldFJhbmdlKHsgbGluZTogMCwgY2g6IDAgfSwgY3Vyc29yKTtcbiAgICBjb25zdCBwb3N0Q3Vyc29yID0gZWRpdG9yLmdldFJhbmdlKGN1cnNvciwgeyBsaW5lOiBlZGl0b3IubGFzdExpbmUoKSwgY2g6IGVkaXRvci5nZXRMaW5lKGVkaXRvci5sYXN0TGluZSgpKS5sZW5ndGggfSk7XG4gICAgY29uc3QgYWN0aXZlU2VudGVuY2UgPSBzZW50ZW5jZUF0Q3Vyc29yKGVkaXRvcik7XG4gICAgY29uc3QgbGFzdExpbmUgPSBlZGl0b3IuZ2V0TGluZShlZGl0b3IubGFzdExpbmUoKSk7XG5cbiAgICByZXR1cm4gYnVpbGRQcm9tcHQodGVtcGxhdGUsIHtcbiAgICAgICAgcHJlX2N1cnNvcjogcHJlQ3Vyc29yLFxuICAgICAgICBwb3N0X2N1cnNvcjogcG9zdEN1cnNvcixcbiAgICAgICAgYWN0aXZlX3NlbnRlbmNlOiBhY3RpdmVTZW50ZW5jZSxcbiAgICAgICAgbGFzdF9saW5lOiBsYXN0TGluZVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzZW50ZW5jZUF0Q3Vyc29yKGVkaXRvcjogRWRpdG9yKTogc3RyaW5nIHtcbiAgICBjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgbGV0IGN1cnJlbnRMaW5lID0gY3Vyc29yLmxpbmU7XG4gICAgbGV0IHNlbnRlbmNlTGluZXMgPSBbZWRpdG9yLmdldExpbmUoY3VycmVudExpbmUpXTtcblxuICAgIC8vIFNlYXJjaCBiYWNrd2FyZHMgdW50aWwgc2VudGVuY2Ugc3RhcnQgZm91bmRcbiAgICB3aGlsZSAoY3VycmVudExpbmUgPiAwKSB7XG4gICAgICAgIGN1cnJlbnRMaW5lLS07XG4gICAgICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShjdXJyZW50TGluZSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgcHJldmlvdXMgbGluZSBlbmRzIHdpdGggc2VudGVuY2UgZW5kaW5nXG4gICAgICAgIGlmICgvWy4hP11cXHMqJC8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzZW50ZW5jZUxpbmVzLnVuc2hpZnQobGluZSk7XG4gICAgfVxuXG4gICAgLy8gSm9pbiBsaW5lcyBhbmQgY2xlYW4gdXAgd2hpdGVzcGFjZVxuICAgIHJldHVybiBzZW50ZW5jZUxpbmVzXG4gICAgICAgIC5qb2luKCcgJylcbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKVxuICAgICAgICAudHJpbSgpO1xufSIsICJpbXBvcnQgeyBNb2RlbFJlc3BvbnNlLCBPbGxhbWEgfSBmcm9tIFwib2xsYW1hXCI7XG5pbXBvcnQgeyBTdWdnZXN0aW9uIH0gZnJvbSBcImNvZGVtaXJyb3ItY29tcGFuaW9uLWV4dGVuc2lvblwiO1xuaW1wb3J0IHsgT2xsYW1hU2V0dGluZ3MgfSBmcm9tIFwiLi9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgQ29tcGxldGVyLCBQcm92aWRlciB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBwcmVwYXJlUHJvbXB0IH0gZnJvbSBcInNyYy9jb21wbGV0aW9uL3Byb21wdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPbGxhbWFDb21wbGV0ZXIgaW1wbGVtZW50cyBDb21wbGV0ZXIge1xuICAgIGludGVncmF0aW9uOiBQcm92aWRlciA9IFByb3ZpZGVyLk9MTEFNQTtcbiAgICBjbGllbnQ6IE9sbGFtYVxuICAgIHNldHRpbmdzOiBPbGxhbWFTZXR0aW5ncztcbiAgICBhYm9ydGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5zOiBPbGxhbWFTZXR0aW5ncykge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGlucztcbiAgICAgICAgdGhpcy5jbGllbnQgPSBuZXcgT2xsYW1hKHsgaG9zdDogdGhpcy5zZXR0aW5ncy5ob3N0IH0pO1xuICAgIH1cblxuICAgIGFzeW5jICpnZW5lcmF0ZShlZGl0b3I6IEVkaXRvcik6IEFzeW5jR2VuZXJhdG9yPHN0cmluZz4ge1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gcHJlcGFyZVByb21wdChlZGl0b3IsIHRoaXMuc2V0dGluZ3MudXNlcl9wcm9tcHQpO1xuXG4gICAgICAgIGNvbnN0IGNvbXBsZXRpb25JdGVyYXRvciA9IGF3YWl0IHRoaXMuY2xpZW50LmdlbmVyYXRlKHtcbiAgICAgICAgICAgIG1vZGVsOiB0aGlzLnNldHRpbmdzLm1vZGVsLFxuICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHQsXG4gICAgICAgICAgICBzeXN0ZW06IHRoaXMuc2V0dGluZ3Muc3lzdGVtX3Byb21wdCxcbiAgICAgICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgaW5pdGlhbFBvc2l0aW9uID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICBsZXQgY29tcGxldGlvbiA9IFwiXCI7XG4gICAgICAgIGZvciBhd2FpdCAobGV0IHJlc3BvbnNlIG9mIGNvbXBsZXRpb25JdGVyYXRvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UG9zaXRpb24ubGluZSAhPT0gaW5pdGlhbFBvc2l0aW9uLmxpbmUgfHwgY3VycmVudFBvc2l0aW9uLmNoICE9PSBpbml0aWFsUG9zaXRpb24uY2gpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImN1cnNvciBtb3ZlZCwgYWJvcnRpbmcgY29tcGxldGlvblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcGxldGlvbiArPSByZXNwb25zZS5yZXNwb25zZTtcbiAgICAgICAgICAgIHlpZWxkIGNvbXBsZXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLmNsaWVudC5hYm9ydCgpO1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmxvZyhcImFib3J0ZWQgY29tcGxldGlvblwiKTtcbiAgICB9XG5cbiAgICBhc3luYyBhdmFpbGFibGVNb2RlbHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50Lmxpc3QoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1vZGVscy5tYXAoKG1vZGVsOiBNb2RlbFJlc3BvbnNlKSA9PiBtb2RlbC5uYW1lKTtcbiAgICB9XG59XG5cblxuIiwgImltcG9ydCB7IFNldHRpbmdzIH0gZnJvbSBcInNyYy9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgT3BlbkFJQ29tcGxldGVyIH0gZnJvbSBcIi4vb3BlbmFpL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBDb21wbGV0ZXIgfSBmcm9tIFwiLi9jb21wbGV0ZXJcIjtcbmltcG9ydCBPbGxhbWFDb21wbGV0ZXIgZnJvbSBcIi4vb2xsYW1hL2NvbXBsZXRlclwiO1xuXG5leHBvcnQgKiBmcm9tIFwiLi9jb21wbGV0ZXJcIjtcblxuZXhwb3J0IGVudW0gUHJvdmlkZXIge1xuICAgIE9MTEFNQSA9IFwib2xsYW1hXCIsXG4gICAgT1BFTkFJID0gXCJvcGVuYWlcIixcbn1cblxuLy8gYnVpbGRlciBmdW5jdGlvbiBmb3IgcHJvdmlkZXJcbmV4cG9ydCBjb25zdCBidWlsZENvbXBsZXRlciA9IChzZXR0aW5nczogU2V0dGluZ3MpOiBDb21wbGV0ZXIgPT4ge1xuICAgIHN3aXRjaCAoc2V0dGluZ3MucHJvdmlkZXIpIHtcbiAgICAgICAgY2FzZSBQcm92aWRlci5PTExBTUE6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9sbGFtYUNvbXBsZXRlcihzZXR0aW5ncy5wcm92aWRlcnMub2xsYW1hKTtcbiAgICAgICAgY2FzZSBQcm92aWRlci5PUEVOQUk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9wZW5BSUNvbXBsZXRlcihzZXR0aW5ncy5wcm92aWRlcnMub3BlbmFpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvdmlkZXJcIik7XG4gICAgfVxufVxuXG4iLCAiaW1wb3J0IHsgT2xsYW1hU2V0dGluZ3MgfSBmcm9tIFwic3JjL3Byb3ZpZGVycy9vbGxhbWFcIjtcbmltcG9ydCB7IE9wZW5BSVNldHRpbmdzIH0gZnJvbSBcInNyYy9wcm92aWRlcnMvb3BlbmFpXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJzcmMvcHJvdmlkZXJzXCI7XG5pbXBvcnQgeyBQbHVnaW5TZXR0aW5nVGFiLCBBcHAsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IFRFTVBMQVRFX1ZBUklBQkxFUyB9IGZyb20gXCJzcmMvY29tcGxldGlvbi9wcm9tcHRcIjtcbmltcG9ydCBJbnNjcmliZSBmcm9tIFwic3JjL21haW5cIjtcbmltcG9ydCB7IFNwbGl0U3RyYXRlZ3kgfSBmcm9tIFwic3JjL2V4dGVuc2lvblwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNldHRpbmdzIHtcbiAgICBwcm92aWRlcjogc3RyaW5nLFxuICAgIHByb3ZpZGVyczoge1xuICAgICAgICBvbGxhbWE6IE9sbGFtYVNldHRpbmdzLFxuICAgICAgICBvcGVuYWk6IE9wZW5BSVNldHRpbmdzLFxuICAgIH0sXG4gICAgZGVsYXlfbXM6IG51bWJlcixcbiAgICBzcGxpdFN0cmF0ZWd5OiBTcGxpdFN0cmF0ZWd5XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBQYXJ0aWFsPFNldHRpbmdzPiA9IHtcbiAgICBwcm92aWRlcjogXCJvbGxhbWFcIixcbiAgICBwcm92aWRlcnM6IHtcbiAgICAgICAgb3BlbmFpOiB7XG4gICAgICAgICAgICBpbnRlZ3JhdGlvbjogUHJvdmlkZXIuT1BFTkFJLFxuICAgICAgICAgICAgbmFtZTogXCJPcGVuIEFJXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJVc2UgT3BlbkFJIEFQSXMgdG8gZ2VuZXJhdGUgdGV4dC5cIixcbiAgICAgICAgICAgIGFwaUtleTogXCJcIixcbiAgICAgICAgICAgIG1vZGVsOiBcImdwdC00b1wiLFxuICAgICAgICAgICAgbW9kZWxzOiBbXCJncHQtNFwiLCBcImdwdC0zLjUtdHVyYm9cIiwgXCJncHQtMy41XCIsIFwiZ3B0LTNcIiwgXCJncHQtMlwiLCBcImdwdC0xXCJdLFxuICAgICAgICB9LFxuICAgICAgICBvbGxhbWE6IHtcbiAgICAgICAgICAgIGludGVncmF0aW9uOiBQcm92aWRlci5PTExBTUEsXG4gICAgICAgICAgICBuYW1lOiBcIk9sbGFtYVwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVXNlIHlvdXIgb3duIE9sbGFtYSBpbnN0YW5jZSB0byBnZW5lcmF0ZSB0ZXh0LlwiLFxuICAgICAgICAgICAgaG9zdDogXCJodHRwOi8vbG9jYWxob3N0OjExNDM0XCIsXG4gICAgICAgICAgICBtb2RlbDogXCJtaXN0cmFsLW5lbW9cIixcbiAgICAgICAgICAgIG1vZGVsczogW1wibGxhbWEzLjI6bGF0ZXN0XCIsIFwibWlzdHJhbC1uZW1vXCJdLFxuICAgICAgICAgICAgdXNlcl9wcm9tcHQ6ICdDb21wbGV0ZSBmb2xsb3dpbmcgdGV4dDpcXG4ge3twcmVfY3Vyc29yfX19JyxcbiAgICAgICAgICAgIHN5c3RlbV9wcm9tcHQ6IFwiWW91IGFyZSBhbiBoZWxwZnVsIEFJIGNvbXBsZXRlci4gRm9sbG93IGluc3RydWN0aW9uc1wiLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgZGVsYXlfbXM6IDUwMCxcbiAgICBzcGxpdFN0cmF0ZWd5OiBcIndvcmRcIixcbn1cblxuZXhwb3J0IGNsYXNzIEluc2NyaWJlU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcHJpdmF0ZSBwbHVnaW46IEluc2NyaWJlKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICB9XG5cbiAgICBhc3luYyBkaXNwbGF5KCkge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuZGlzcGxheUdlbmVyYWxTZXR0aW5ncygpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjYXNlIFByb3ZpZGVyLk9MTEFNQTpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc3BsYXlPbGxhbWFTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcm92aWRlci5PUEVOQUk6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNwbGF5T3BlbkFJU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBkaXNwbGF5R2VuZXJhbFNldHRpbmdzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIkdlbmVyYWxcIiB9KTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIkFJIFByb3ZpZGVyXCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkNob29zZSB5b3VyIHByZWZlcnJlZCBBSSBwcm92aWRlci5cIilcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlcnMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LCB2YWx1ZS5uYW1lXSkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVyKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIkRlbGF5IChtcylcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiU2V0IHRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIGZldGNoaW5nIHN1Z2dlc3Rpb25zLlwiKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0QXR0cnMoeyB0eXBlOiBcIm51bWJlclwiLCBtaW46IFwiMFwiIH0pO1xuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKHNldHRpbmdzLmRlbGF5X21zLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5kZWxheV9tcy50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWxheV9tcyA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIkFjY2VwdCBTdHJhdGVneVwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJDaG9vc2UgdGhlIGFjY2VwdCBzdHJhdGVneS5cIilcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIndvcmRcIjogXCJXb3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNlbnRlbmNlXCI6IFwiU2VudGVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicGFyYWdyYXBoXCI6IFwiUGFyYWdyYXBoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZ1bGxcIjogXCJGdWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zcGxpdFN0cmF0ZWd5KVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zcGxpdFN0cmF0ZWd5ID0gdmFsdWUgYXMgU3BsaXRTdHJhdGVneTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGRpc3BsYXlPbGxhbWFTZXR0aW5ncygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlcnMub2xsYW1hO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDNcIiwgeyB0ZXh0OiBcIk9sbGFtYSBTZXR0aW5nc1wiIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJIb3N0XCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkVudGVyIHRoZSBPbGxhbWEgaG9zdC5cIilcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKHNldHRpbmdzLmhvc3QpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLmhvc3QpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5ob3N0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiTW9kZWxcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiQ2hvb3NlIHRoZSBPbGxhbWEgbW9kZWwuXCIpXG4gICAgICAgICAgICAuYWRkRXh0cmFCdXR0b24oKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRUb29sdGlwKFwiUmVmcmVzaCBtb2RlbCBsaXN0XCIpLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tb2RlbHMgPSBhd2FpdCB0aGlzLnBsdWdpbi5jb21wbGV0ZXIuYXZhaWxhYmxlTW9kZWxzKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oKGRyb3Bkb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbnMoT2JqZWN0LmZyb21FbnRyaWVzKHNldHRpbmdzLm1vZGVscy5tYXAobW9kZWwgPT4gW21vZGVsLCBtb2RlbF0pKSlcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLm1vZGVsKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlVzZXIgUHJvbXB0XCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkVudGVyIHRoZSB1c2VyIHByb21wdC5cIilcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbigoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnNldFRvb2x0aXAoXCJJbnNlcnQgdmFyaWFibGVzXCIpLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy51c2VyX3Byb21wdCA9IGAke3NldHRpbmdzLnVzZXJfcHJvbXB0fVxcbiR7VEVNUExBVEVfVkFSSUFCTEVTfWA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hZGRUZXh0QXJlYSgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5zZXRBdHRyKFwicm93c1wiLCBcIjVcIik7XG4gICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnNldENzc1N0eWxlcyh7IHdpZHRoOiBcIjEwMCVcIiwgcmVzaXplOiBcInZlcnRpY2FsXCIsIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIgfSk7XG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoc2V0dGluZ3MudXNlcl9wcm9tcHQpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy51c2VyX3Byb21wdClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudXNlcl9wcm9tcHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJTeXN0ZW0gUHJvbXB0XCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkVudGVyIHRoZSBzeXN0ZW0gcHJvbXB0LlwiKVxuICAgICAgICAgICAgLmFkZFRleHRBcmVhKCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnNldEF0dHIoXCJyb3dzXCIsIFwiMlwiKTtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0Q3NzU3R5bGVzKHsgd2lkdGg6IFwiMTAwJVwiLCByZXNpemU6IFwidmVydGljYWxcIiwgcG9zaXRpb246IFwicmVsYXRpdmVcIiB9KTtcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihzZXR0aW5ncy5zeXN0ZW1fcHJvbXB0KVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3Muc3lzdGVtX3Byb21wdClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Muc3lzdGVtX3Byb21wdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzcGxheU9wZW5BSVNldHRpbmdzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVycy5vcGVuYWk7XG5cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IFwiT3BlbkFJIFNldHRpbmdzXCIgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIkFQSSBLZXlcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiRW50ZXIgdGhlIE9wZW5BSSBBUEkga2V5LlwiKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoc2V0dGluZ3MuYXBpS2V5KVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5hcGlLZXkpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hcGlLZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJNb2RlbFwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJDaG9vc2UgdGhlIE9wZW5BSSBtb2RlbC5cIilcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9ucyhPYmplY3QuZnJvbUVudHJpZXMoc2V0dGluZ3MubW9kZWxzLm1hcChtb2RlbCA9PiBbbW9kZWwsIG1vZGVsXSkpKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MubW9kZWwpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG5cbiIsICJpbXBvcnQgeyBFZGl0b3IgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IFNwbGl0U3RyYXRlZ3ksIFN1Z2dlc3Rpb24gfSBmcm9tIFwic3JjL2V4dGVuc2lvblwiO1xuaW1wb3J0IHsgQ29tcGxldGVyIH0gZnJvbSBcInNyYy9wcm92aWRlcnNcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0ZUNvbXBsZXRpb24oZWRpdG9yOiBFZGl0b3IsIGNvbXBsZXRlcjogQ29tcGxldGVyLCBzcGxpdFN0cmF0ZWd5OiBTcGxpdFN0cmF0ZWd5KTogQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj4ge1xuICAgIGNvbXBsZXRlci5hYm9ydCgpO1xuICAgIGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblxuICAgIC8vIElmIHRoZSBjdXJyZW50IGxpbmUgaXMgZW1wdHksIGRvbid0IHN1Z2dlc3QgYW55dGhpbmcuXG4gICAgY29uc3QgY3VycmVudExpbmUgPSBlZGl0b3IuZ2V0TGluZShjdXJzb3IubGluZSk7XG4gICAgaWYgKCFjdXJyZW50TGluZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE9ubHkgaWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgc3BhY2Ugb3IgZG90LCBzdWdnZXN0IGNvbXBsZXRpb25zLlxuICAgIGNvbnN0IGxhc3RDaGFyID0gY3VycmVudExpbmVbY3Vyc29yLmNoIC0gMV07XG4gICAgaWYgKGxhc3RDaGFyICE9PSBcIiBcIikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIGF3YWl0IChjb25zdCB0ZXh0IG9mIGNvbXBsZXRlci5nZW5lcmF0ZShlZGl0b3IpKSB7XG4gICAgICAgIHlpZWxkIHsgdGV4dDogdGV4dCwgc3BsaXRTdHJhdGVneTogc3BsaXRTdHJhdGVneSB9O1xuICAgIH1cbn1cblxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxtQkFBdUI7OztBQ0t2QixrQkFBbUY7QUFDbkYsbUJBQWtGO0FBS2xGLElBQU0sa0JBQWtCO0FBQUE7QUFBQSxFQUVwQixNQUFNLENBQUMsY0FBc0I7QUFDekIsVUFBTSxhQUFhLFVBQVUsUUFBUSxHQUFHO0FBQ3hDLFdBQU8sZUFBZSxLQUNoQixFQUFFLFFBQVEsV0FBVyxXQUFXLEdBQUcsSUFDbkMsRUFBRSxRQUFRLFVBQVUsTUFBTSxHQUFHLGFBQWEsQ0FBQyxHQUFHLFdBQVcsVUFBVSxNQUFNLGFBQWEsQ0FBQyxFQUFFO0FBQUEsRUFDbkc7QUFBQTtBQUFBLEVBR0EsVUFBVSxDQUFDLGNBQXNCO0FBQzdCLFVBQU0sY0FBYyxVQUFVLE1BQU0sVUFBVTtBQUM5QyxXQUFPLGNBQ0QsRUFBRSxRQUFRLFVBQVUsTUFBTSxHQUFHLFlBQVksUUFBUyxDQUFDLEdBQUcsV0FBVyxVQUFVLE1BQU0sWUFBWSxRQUFTLENBQUMsRUFBRSxJQUN6RyxFQUFFLFFBQVEsV0FBVyxXQUFXLEdBQUc7QUFBQSxFQUM3QztBQUFBO0FBQUEsRUFHQSxXQUFXLENBQUMsY0FBc0I7QUFDOUIsVUFBTSxlQUFlLFVBQVUsUUFBUSxNQUFNO0FBQzdDLFdBQU8saUJBQWlCLEtBQ2xCLEVBQUUsUUFBUSxXQUFXLFdBQVcsR0FBRyxJQUNuQyxFQUFFLFFBQVEsVUFBVSxNQUFNLEdBQUcsZUFBZSxDQUFDLEdBQUcsV0FBVyxVQUFVLE1BQU0sZUFBZSxDQUFDLEVBQUU7QUFBQSxFQUN2RztBQUFBO0FBQUEsRUFHQSxNQUFNLENBQUMsZUFBdUIsRUFBRSxRQUFRLFdBQVcsV0FBVyxHQUFHO0FBQ3JFO0FB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QW1CLFFBQWdCLFdBQXNCLGVBQTBEO0FBQ3RJLFlBQVUsTUFBTTtBQUNoQixRQUFNLFNBQVMsT0FBTyxVQUFVO0FBR2hDLFFBQU0sY0FBYyxPQUFPLFFBQVEsT0FBTyxJQUFJO0FBQzlDLE1BQUksQ0FBQyxZQUFZLFFBQVE7QUFDckI7QUFBQSxFQUNKO0FBR0EsUUFBTSxXQUFXLFlBQVksT0FBTyxLQUFLLENBQUM7QUFDMUMsTUFBSSxhQUFhLEtBQUs7QUFDbEI7QUFBQSxFQUNKO0FBRUEsbUJBQWlCLFFBQVEsVUFBVSxTQUFTLE1BQU0sR0FBRztBQUNqRCxVQUFNLEVBQUUsTUFBWSxjQUE2QjtBQUFBLEVBQ3JEO0FBQ0o7OztBWGhCQSxJQUFxQixXQUFyQixjQUFzQyx3QkFBTztBQUFBLEVBSTVDLE1BQU0sU0FBUztBQUNkLFVBQU0sS0FBSyxhQUFhO0FBQ3hCLFVBQU0sS0FBSyxjQUFjO0FBQ3pCLFVBQU0sS0FBSyxlQUFlO0FBQzFCLFNBQUssY0FBYyxJQUFJLG9CQUFvQixLQUFLLEtBQUssSUFBSSxDQUFDO0FBQUEsRUFDM0Q7QUFBQSxFQUVBLE1BQU0sZ0JBQWdCO0FBQ3JCLFNBQUssWUFBWSxlQUFlLEtBQUssUUFBUTtBQUFBLEVBQzlDO0FBQUEsRUFFQSxNQUFNLGlCQUFpQjtBQUN0QixVQUFNLFlBQVksaUJBQWlCO0FBQUEsTUFDbEMsU0FBUyxNQUFNLEtBQUssaUJBQWlCO0FBQUEsTUFDckMsU0FBUyxLQUFLLFNBQVM7QUFBQSxJQUN4QixDQUFDO0FBQ0QsU0FBSyx3QkFBd0IsU0FBUztBQUFBLEVBQ3ZDO0FBQUEsRUFFQSxPQUFRLG1CQUErQztBQUN0RCxVQUFNLGVBQWUsS0FBSyxJQUFJLFVBQVU7QUFDeEMsUUFBSSxDQUFDO0FBQWM7QUFDbkIsUUFBSSxDQUFDLGFBQWE7QUFBUTtBQUUxQixXQUFPLG1CQUFtQixhQUFhLFFBQVEsS0FBSyxXQUFXLEtBQUssU0FBUyxhQUFhO0FBQUEsRUFDM0Y7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNwQixTQUFLLFdBQVcsT0FBTztBQUFBLE1BQ3RCLENBQUM7QUFBQSxNQUNEO0FBQUEsTUFDQSxNQUFNLEtBQUssU0FBUztBQUFBLElBQ3JCO0FBQUEsRUFDRDtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUNqQyxVQUFNLEtBQUssY0FBYztBQUFBLEVBQzFCO0FBQ0Q7IiwKICAibmFtZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJyZXNvbHZlIiwgInJlc29sdmUiLCAiZmV0Y2giLCAiZmV0Y2giLCAiX19kZWZQcm9wIiwgIk9sbGFtYSIsICJmcyIsICJpbmRleCIsICJnZXQiLCAic2VsZiIsICJjbGVhckNhY2hlIiwgInBhcnNlIiwgInJlbmRlciIsICJPbGxhbWEiXQp9Cg==
