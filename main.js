/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Inscribe
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// node_modules/codemirror-companion-extension/dist/extension.js
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");

// node_modules/codemirror-companion-extension/dist/lib/utils.js
function a(n, i, t = void 0) {
  const c2 = {
    force: () => {
    }
  };
  let e = null;
  async function* f(...u2) {
    e && clearTimeout(e);
    let r2 = null;
    try {
      await new Promise((o) => {
        r2 = e = setTimeout(() => o(), i), c2.force = () => {
          e && clearTimeout(e), o();
        };
      });
    } catch (e2) {
      if (t !== void 0)
        throw t;
    }
    for await (const o of n(...u2)) {
      if (r2 !== e)
        break;
      yield o;
    }
  }
  return { debounced: f, force: () => c2.force() };
}

// node_modules/codemirror-companion-extension/dist/extension.js
var F = Object.defineProperty;
var I = (n, t, e) => t in n ? F(n, t, { enumerable: true, configurable: true, writable: true, value: e }) : n[t] = e;
var c = (n, t, e) => (I(n, typeof t != "symbol" ? t + "" : t, e), e);
var r = import_state.StateField.define({
  create() {
    return { suggestion: null };
  },
  update(n, t) {
    const e = t.effects.find(
      (s) => s.is(d)
    );
    return t.state.doc && e && (e.value.doc == null || t.state.doc == e.value.doc) ? { suggestion: e.value.suggestion } : { suggestion: null };
  }
});
var d = import_state.StateEffect.define();
function E(n, t) {
  const e = n.state.selection.main.head, s = [], o = import_view.Decoration.widget({
    widget: new P(t),
    side: 1
  });
  return s.push(o.range(e)), import_view.Decoration.set(s);
}
var P = class extends import_view.WidgetType {
  constructor(e) {
    super();
    c(this, "suggestion");
    this.suggestion = e;
  }
  toDOM() {
    const e = document.createElement("span");
    return e.style.opacity = "0.4", e.className = "cm-inline-suggestion", e.textContent = this.suggestion, e;
  }
};
var g = (n) => {
  let t = 0;
  return import_view.ViewPlugin.fromClass(
    class {
      async update(s) {
        const o = s.state.doc;
        if (!s.docChanged)
          return;
        const i = ++t;
        for await (const a2 of n(s.state)) {
          if (i != t)
            return;
          s.view.dispatch({
            effects: d.of({
              suggestion: a2,
              doc: o
            })
          });
        }
      }
    }
  );
};
var T = class {
  constructor() {
    c(this, "decorations");
    this.decorations = import_view.Decoration.none;
  }
  update(t) {
    var s;
    const e = (s = t.state.field(
      r
    )) == null ? void 0 : s.suggestion;
    if (!e) {
      this.decorations = import_view.Decoration.none;
      return;
    }
    this.decorations = E(
      t.view,
      e.display_suggestion
    );
  }
};
var l = import_view.ViewPlugin.fromClass(T, {
  decorations: (n) => n.decorations
});
var _ = class {
  constructor(t, e) {
    c(this, "suggestFn");
    c(this, "keymap");
    c(this, "completionId");
    c(this, "run", (t2) => {
      var o, i;
      const e2 = (o = t2.state.field(
        r
      )) == null ? void 0 : o.suggestion;
      return e2 ? (t2.dispatch({
        ...x(
          t2.state,
          e2.complete_suggestion,
          t2.state.selection.main.head,
          t2.state.selection.main.head
        )
      }), (i = e2.accept_hook) == null || i.call(e2), (async () => {
        if (this.suggestFn == null)
          return;
        const a2 = ++this.completionId;
        for await (const f of this.suggestFn(t2.state)) {
          if (a2 != this.completionId)
            return;
          t2.dispatch({
            effects: d.of({
              suggestion: {
                complete_suggestion: f.complete_suggestion,
                display_suggestion: f.display_suggestion,
                accept_hook: f.accept_hook
              },
              doc: null
            })
          });
        }
      })(), true) : false;
    });
    this.suggestFn = t, this.keymap = import_state.Prec.highest(
      import_view.keymap.of([
        {
          key: e,
          run: (s) => this.run(s)
        }
      ])
    ), this.completionId = 0;
  }
};
function x(n, t, e, s) {
  return {
    ...n.changeByRange((o) => {
      if (o == n.selection.main)
        return {
          changes: { from: e, to: s, insert: t },
          range: import_state.EditorSelection.cursor(e + t.length)
        };
      const i = s - e;
      return !o.empty || i && n.sliceDoc(o.from - i, o.from) != n.sliceDoc(e, s) ? { range: o } : {
        changes: { from: o.from - i, to: o.from, insert: t },
        range: import_state.EditorSelection.cursor(o.from - i + t.length)
      };
    }),
    userEvent: "input.complete"
  };
}
function p(n) {
  return typeof n == "string" ? {
    complete_suggestion: n,
    display_suggestion: n
  } : n;
}
function S(n) {
  return async function* (t) {
    const e = await n(t);
    if (typeof e == "string" || "complete_suggestion" in e) {
      yield p(e);
      return;
    }
    for await (const s of e)
      yield p(s);
  };
}
function G(n) {
  const { delay: t = 500, accept_shortcut: e = "Tab" } = n, s = S(n.fetchFn), { debounced: o } = a(
    s,
    t
  );
  return e ? [
    r,
    g(o),
    l,
    new _(
      n.continue_suggesting ? s : null,
      e
    ).keymap
  ] : [
    r,
    g(o),
    l
  ];
}

// src/settings/settings.ts
var import_obsidian3 = require("obsidian");

// src/providers/ollama/completer.ts
var OllamaCompleter = class {
  constructor(settins, client) {
    this.settings = settins;
    this.client = client;
  }
  async *generate(prefix, suffix) {
    console.log("fetching completion");
    const promiseIterator = await this.client.generate({
      model: this.settings.model,
      prompt: prefix,
      stream: true
    });
    let completion = "";
    for await (let response of promiseIterator) {
      completion += response.response;
      yield { complete_suggestion: completion, display_suggestion: completion };
    }
  }
  async abort() {
    console.log("canceling completion");
    this.client.abort();
  }
};

// src/providers/ollama/provider.ts
var import_obsidian = require("obsidian");

// node_modules/whatwg-fetch/fetch.js
var g2 = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g2,
  iterable: "Symbol" in g2 && "iterator" in Symbol,
  blob: "FileReader" in g2 && "Blob" in g2 && function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: "FormData" in g2,
  arrayBuffer: "ArrayBuffer" in g2
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve2, reject) {
    reader.onload = function() {
      resolve2(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g2) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};
Response.error = function() {
  var response = new Response(null, { status: 200, statusText: "" });
  response.ok = false;
  response.status = 0;
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response(null, { status, headers: { location: url } });
};
var DOMException = g2.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch2(input, init) {
  return new Promise(function(resolve2, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve2(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g2.location.href ? g2.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g2.Headers && init.headers instanceof g2.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch2.polyfill = true;
if (!g2.fetch) {
  g2.fetch = fetch2;
  g2.Headers = Headers;
  g2.Request = Request;
  g2.Response = Response;
}

// node_modules/ollama/dist/shared/ollama.cddbc85b.mjs
var version = "0.5.11";
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ResponseError = class extends Error {
  constructor(error, status_code) {
    super(error);
    this.error = error;
    this.status_code = status_code;
    this.name = "ResponseError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ResponseError);
    }
  }
};
var AbortableAsyncIterator = class {
  constructor(abortController, itr, doneCallback) {
    __publicField$1(this, "abortController");
    __publicField$1(this, "itr");
    __publicField$1(this, "doneCallback");
    this.abortController = abortController;
    this.itr = itr;
    this.doneCallback = doneCallback;
  }
  abort() {
    this.abortController.abort();
  }
  async *[Symbol.asyncIterator]() {
    for await (const message of this.itr) {
      if ("error" in message) {
        throw new Error(message.error);
      }
      yield message;
      if (message.done || message.status === "success") {
        this.doneCallback();
        return;
      }
    }
    throw new Error("Did not receive done or success response in stream.");
  }
};
var checkOk = async (response) => {
  var _a;
  if (response.ok) {
    return;
  }
  let message = `Error ${response.status}: ${response.statusText}`;
  let errorData = null;
  if ((_a = response.headers.get("content-type")) == null ? void 0 : _a.includes("application/json")) {
    try {
      errorData = await response.json();
      message = errorData.error || message;
    } catch (error) {
      console.log("Failed to parse error response as JSON");
    }
  } else {
    try {
      console.log("Getting text from response");
      const textResponse = await response.text();
      message = textResponse || message;
    } catch (error) {
      console.log("Failed to get text from error response");
    }
  }
  throw new ResponseError(message, response.status);
};
function getPlatform() {
  if (typeof window !== "undefined" && window.navigator) {
    return `${window.navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;
  } else if (typeof process !== "undefined") {
    return `${process.arch} ${process.platform} Node.js/${process.version}`;
  }
  return "";
}
var fetchWithHeaders = async (fetch3, url, options = {}) => {
  const defaultHeaders = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "User-Agent": `ollama-js/${version} (${getPlatform()})`
  };
  if (!options.headers) {
    options.headers = {};
  }
  const customHeaders = Object.fromEntries(
    Object.entries(options.headers).filter(([key]) => !Object.keys(defaultHeaders).some((defaultKey) => defaultKey.toLowerCase() === key.toLowerCase()))
  );
  options.headers = {
    ...defaultHeaders,
    ...customHeaders
  };
  return fetch3(url, options);
};
var get = async (fetch3, host, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var head = async (fetch3, host) => {
  const response = await fetchWithHeaders(fetch3, host, {
    method: "HEAD"
  });
  await checkOk(response);
  return response;
};
var post = async (fetch3, host, data, options) => {
  const isRecord = (input) => {
    return input !== null && typeof input === "object" && !Array.isArray(input);
  };
  const formattedData = isRecord(data) ? JSON.stringify(data) : data;
  const response = await fetchWithHeaders(fetch3, host, {
    method: "POST",
    body: formattedData,
    signal: options == null ? void 0 : options.signal,
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var del = async (fetch3, host, data, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    method: "DELETE",
    body: JSON.stringify(data),
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var parseJSON = async function* (itr) {
  var _a;
  const decoder = new TextDecoder("utf-8");
  let buffer = "";
  const reader = itr.getReader();
  while (true) {
    const { done, value: chunk } = await reader.read();
    if (done) {
      break;
    }
    buffer += decoder.decode(chunk);
    const parts = buffer.split("\n");
    buffer = (_a = parts.pop()) != null ? _a : "";
    for (const part of parts) {
      try {
        yield JSON.parse(part);
      } catch (error) {
        console.warn("invalid json: ", part);
      }
    }
  }
  for (const part of buffer.split("\n").filter((p2) => p2 !== "")) {
    try {
      yield JSON.parse(part);
    } catch (error) {
      console.warn("invalid json: ", part);
    }
  }
};
var formatHost = (host) => {
  if (!host) {
    return "http://127.0.0.1:11434";
  }
  let isExplicitProtocol = host.includes("://");
  if (host.startsWith(":")) {
    host = `http://127.0.0.1${host}`;
    isExplicitProtocol = true;
  }
  if (!isExplicitProtocol) {
    host = `http://${host}`;
  }
  const url = new URL(host);
  let port = url.port;
  if (!port) {
    if (!isExplicitProtocol) {
      port = "11434";
    } else {
      port = url.protocol === "https:" ? "443" : "80";
    }
  }
  let formattedHost = `${url.protocol}//${url.hostname}:${port}${url.pathname}`;
  if (formattedHost.endsWith("/")) {
    formattedHost = formattedHost.slice(0, -1);
  }
  return formattedHost;
};
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var Ollama$1 = class Ollama {
  constructor(config) {
    var _a, _b;
    __publicField(this, "config");
    __publicField(this, "fetch");
    __publicField(this, "ongoingStreamedRequests", []);
    this.config = {
      host: "",
      headers: config == null ? void 0 : config.headers
    };
    if (!(config == null ? void 0 : config.proxy)) {
      this.config.host = formatHost((_a = config == null ? void 0 : config.host) != null ? _a : "http://127.0.0.1:11434");
    }
    this.fetch = (_b = config == null ? void 0 : config.fetch) != null ? _b : fetch;
  }
  // Abort any ongoing streamed requests to Ollama
  abort() {
    for (const request of this.ongoingStreamedRequests) {
      request.abort();
    }
    this.ongoingStreamedRequests.length = 0;
  }
  /**
   * Processes a request to the Ollama server. If the request is streamable, it will return a
   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
   * object.
   * @param endpoint {string} - The endpoint to send the request to.
   * @param request {object} - The request object to send to the endpoint.
   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
   * response messages.
   * @throws {Error} - If the response body is missing or if the response is an error.
   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
   */
  async processStreamableRequest(endpoint, request) {
    var _a;
    request.stream = (_a = request.stream) != null ? _a : false;
    const host = `${this.config.host}/api/${endpoint}`;
    if (request.stream) {
      const abortController = new AbortController();
      const response2 = await post(this.fetch, host, request, {
        signal: abortController.signal,
        headers: this.config.headers
      });
      if (!response2.body) {
        throw new Error("Missing body");
      }
      const itr = parseJSON(response2.body);
      const abortableAsyncIterator = new AbortableAsyncIterator(
        abortController,
        itr,
        () => {
          const i = this.ongoingStreamedRequests.indexOf(abortableAsyncIterator);
          if (i > -1) {
            this.ongoingStreamedRequests.splice(i, 1);
          }
        }
      );
      this.ongoingStreamedRequests.push(abortableAsyncIterator);
      return abortableAsyncIterator;
    }
    const response = await post(this.fetch, host, request, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
  * Encodes an image to base64 if it is a Uint8Array.
  * @param image {Uint8Array | string} - The image to encode.
  * @returns {Promise<string>} - The base64 encoded image.
  */
  async encodeImage(image) {
    if (typeof image !== "string") {
      const uint8Array = new Uint8Array(image);
      let byteString = "";
      const len = uint8Array.byteLength;
      for (let i = 0; i < len; i++) {
        byteString += String.fromCharCode(uint8Array[i]);
      }
      return btoa(byteString);
    }
    return image;
  }
  /**
   * Generates a response from a text prompt.
   * @param request {GenerateRequest} - The request object.
   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async generate(request) {
    if (request.images) {
      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));
    }
    return this.processStreamableRequest("generate", request);
  }
  /**
   * Chats with the model. The request object can contain messages with images that are either
   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
   * request.
   * @param request {ChatRequest} - The request object.
   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
   * AbortableAsyncIterator that yields response messages.
   */
  async chat(request) {
    if (request.messages) {
      for (const message of request.messages) {
        if (message.images) {
          message.images = await Promise.all(
            message.images.map(this.encodeImage.bind(this))
          );
        }
      }
    }
    return this.processStreamableRequest("chat", request);
  }
  /**
   * Creates a new model from a stream of data.
   * @param request {CreateRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
   */
  async create(request) {
    return this.processStreamableRequest("create", {
      name: request.model,
      stream: request.stream,
      modelfile: request.modelfile,
      quantize: request.quantize
    });
  }
  /**
   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PullRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async pull(request) {
    return this.processStreamableRequest("pull", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PushRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async push(request) {
    return this.processStreamableRequest("push", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Deletes a model from the server. The request object should contain the name of the model to
   * delete.
   * @param request {DeleteRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async delete(request) {
    await del(
      this.fetch,
      `${this.config.host}/api/delete`,
      { name: request.model },
      { headers: this.config.headers }
    );
    return { status: "success" };
  }
  /**
   * Copies a model from one name to another. The request object should contain the name of the
   * model to copy and the new name.
   * @param request {CopyRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async copy(request) {
    await post(this.fetch, `${this.config.host}/api/copy`, { ...request }, {
      headers: this.config.headers
    });
    return { status: "success" };
  }
  /**
   * Lists the models on the server.
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async list() {
    const response = await get(this.fetch, `${this.config.host}/api/tags`, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Shows the metadata of a model. The request object should contain the name of the model.
   * @param request {ShowRequest} - The request object.
   * @returns {Promise<ShowResponse>} - The response object.
   */
  async show(request) {
    const response = await post(this.fetch, `${this.config.host}/api/show`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds text input into vectors.
   * @param request {EmbedRequest} - The request object.
   * @returns {Promise<EmbedResponse>} - The response object.
   */
  async embed(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embed`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds a text prompt into a vector.
   * @param request {EmbeddingsRequest} - The request object.
   * @returns {Promise<EmbeddingsResponse>} - The response object.
   */
  async embeddings(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Lists the running models on the server
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async ps() {
    const response = await get(this.fetch, `${this.config.host}/api/ps`, {
      headers: this.config.headers
    });
    return await response.json();
  }
};
var browser = new Ollama$1();

// node_modules/ollama/dist/index.mjs
var import_fs = __toESM(require("fs"), 1);
var import_path = require("path");
var import_crypto = require("crypto");
var import_os = require("os");
var Ollama2 = class extends Ollama$1 {
  async encodeImage(image) {
    if (typeof image !== "string") {
      return Buffer.from(image).toString("base64");
    }
    try {
      if (import_fs.default.existsSync(image)) {
        const fileBuffer = await import_fs.promises.readFile((0, import_path.resolve)(image));
        return Buffer.from(fileBuffer).toString("base64");
      }
    } catch (e) {
    }
    return image;
  }
  /**
   * Parse the modelfile and replace the FROM and ADAPTER commands with the corresponding blob hashes.
   * @param modelfile {string} - The modelfile content
   * @param mfDir {string} - The directory of the modelfile
   * @private @internal
   */
  async parseModelfile(modelfile, mfDir = process.cwd()) {
    const out = [];
    const lines = modelfile.split("\n");
    for (const line of lines) {
      const [command, args] = line.split(" ", 2);
      if (["FROM", "ADAPTER"].includes(command.toUpperCase())) {
        const path = this.resolvePath(args.trim(), mfDir);
        if (await this.fileExists(path)) {
          out.push(`${command} @${await this.createBlob(path)}`);
        } else {
          out.push(`${command} ${args}`);
        }
      } else {
        out.push(line);
      }
    }
    return out.join("\n");
  }
  /**
   * Resolve the path to an absolute path.
   * @param inputPath {string} - The input path
   * @param mfDir {string} - The directory of the modelfile
   * @private @internal
   */
  resolvePath(inputPath, mfDir) {
    if (inputPath.startsWith("~")) {
      return (0, import_path.join)((0, import_os.homedir)(), inputPath.slice(1));
    }
    return (0, import_path.resolve)(mfDir, inputPath);
  }
  /**
   * checks if a file exists
   * @param path {string} - The path to the file
   * @private @internal
   * @returns {Promise<boolean>} - Whether the file exists or not
   */
  async fileExists(path) {
    try {
      await import_fs.promises.access(path);
      return true;
    } catch (e) {
      return false;
    }
  }
  async createBlob(path) {
    if (typeof ReadableStream === "undefined") {
      throw new Error("Streaming uploads are not supported in this environment.");
    }
    const fileStream = (0, import_fs.createReadStream)(path);
    const sha256sum = await new Promise((resolve2, reject) => {
      const hash = (0, import_crypto.createHash)("sha256");
      fileStream.on("data", (data) => hash.update(data));
      fileStream.on("end", () => resolve2(hash.digest("hex")));
      fileStream.on("error", reject);
    });
    const digest = `sha256:${sha256sum}`;
    try {
      await head(this.fetch, `${this.config.host}/api/blobs/${digest}`);
    } catch (e) {
      if (e instanceof Error && e.message.includes("404")) {
        const readableStream = new ReadableStream({
          start(controller) {
            fileStream.on("data", (chunk) => {
              controller.enqueue(chunk);
            });
            fileStream.on("end", () => {
              controller.close();
            });
            fileStream.on("error", (err) => {
              controller.error(err);
            });
          }
        });
        await post(
          this.fetch,
          `${this.config.host}/api/blobs/${digest}`,
          readableStream
        );
      } else {
        throw e;
      }
    }
    return digest;
  }
  async create(request) {
    let modelfileContent = "";
    if (request.path) {
      modelfileContent = await import_fs.promises.readFile(request.path, { encoding: "utf8" });
      modelfileContent = await this.parseModelfile(
        modelfileContent,
        (0, import_path.dirname)(request.path)
      );
    } else if (request.modelfile) {
      modelfileContent = await this.parseModelfile(request.modelfile);
    } else {
      throw new Error("Must provide either path or modelfile to create a model");
    }
    request.modelfile = modelfileContent;
    if (request.stream) {
      return super.create(request);
    } else {
      return super.create(request);
    }
  }
};
var index = new Ollama2();

// src/providers/ollama/provider.ts
var OllamaProvider = class {
  constructor(settings) {
    this.integration = "ollama" /* OLLAMA */;
    this.name = "Ollama";
    this.settings = settings;
    this.client = new Ollama2({ host: this.settings.host });
  }
  async loadCompleter() {
    console.log("loading ollama completer");
    this.completer = new OllamaCompleter(this.settings, this.client);
  }
  async availableModels() {
    const response = await this.client.list();
    return response.models.map((model) => model.name);
  }
  displaySettings(plugin, containerEl, display) {
    containerEl.createEl("h3", { text: "Ollama Settings" });
    new import_obsidian.Setting(containerEl).setName("Host").setDesc("Enter the Ollama host.").addText(
      (text) => text.setPlaceholder(this.settings.host).setValue(this.settings.host).onChange(async (value) => {
        this.settings.host = value;
        await plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Model").setDesc("Choose the Ollama model.").addExtraButton((button) => {
      button.setTooltip("Refresh model list").onClick(async () => {
        this.settings.models = await this.availableModels();
        await plugin.saveSettings();
        display();
      });
    }).addDropdown((dropdown) => {
      dropdown.addOptions(Object.fromEntries(this.settings.models.map((model) => [model, model]))).setValue(this.settings.model).onChange(async (value) => {
        this.settings.model = value;
        await plugin.saveSettings();
        display();
      });
    });
  }
};

// src/providers/openai/provider.ts
var import_obsidian2 = require("obsidian");
var OpenAIProvider = class {
  constructor(settings) {
    this.integration = "openai" /* OPENAI */;
    this.name = "Open AI";
    this.loadCompleter = async () => {
    };
    this.settings = settings;
  }
  displaySettings(plugin, containerEl) {
    containerEl.createEl("h3", { text: "OpenAI Settings" });
    new import_obsidian2.Setting(containerEl).setName("API Key").setDesc("Enter the OpenAI API key.").addText(
      (text) => text.setPlaceholder(this.settings.apiKey).setValue(this.settings.apiKey).onChange(async (value) => {
        this.settings.apiKey = value;
        await plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Model").setDesc("Choose the OpenAI model.").addDropdown((dropdown) => {
      dropdown.addOption("gpt-4", "GPT-4").addOption("davinci", "Davinci").setValue(this.settings.model).onChange(async (value) => {
        this.settings.model = value;
        await plugin.saveSettings();
      });
    });
  }
  availableModels() {
    return ["gpt-4", "davinci"];
  }
};

// src/providers/index.ts
var buildProviders = (settings) => {
  return [
    new OllamaProvider(settings.providers.ollama),
    new OpenAIProvider(settings.providers.openai)
  ];
};

// src/settings/settings.ts
var DEFAULT_SETTINGS = {
  provider: "ollama",
  providers: {
    openai: {
      integration: "openai" /* OPENAI */,
      name: "Open AI",
      description: "OpenAI is an artificial intelligence research laboratory consisting of the for-profit OpenAI LP and the non-profit OpenAI Inc.",
      apiKey: "",
      model: "gpt-4"
    },
    ollama: {
      integration: "ollama" /* OLLAMA */,
      name: "Ollama",
      description: "Ollama is an AI provider that offers a variety of models for different use cases.",
      host: "http://localhost:11434",
      model: "mistral-nemo",
      models: ["llama3.2:latest"]
    }
  },
  promtty: true
};
var InscribeSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Provider Settings" });
    new import_obsidian3.Setting(containerEl).setName("AI Provider").setDesc("Choose your preferred AI provider.").addDropdown((dropdown) => {
      dropdown.addOptions(
        Object.fromEntries(Object.entries(this.plugin.settings.providers).map(([key, value]) => [key, value.name]))
      );
      dropdown.setValue(this.plugin.settings.provider).onChange(async (value) => {
        this.plugin.settings.provider = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    switch (this.plugin.settings.provider) {
      case "ollama" /* OLLAMA */:
        await this.displayOllamaSettings();
        break;
      case "openai" /* OPENAI */:
        await this.displayOpenAISettings();
        break;
      default:
        break;
    }
  }
  async displayOllamaSettings() {
    const { containerEl } = this;
    const settings = this.plugin.settings.providers.ollama;
    containerEl.createEl("h3", { text: "Ollama Settings" });
    new import_obsidian3.Setting(containerEl).setName("Host").setDesc("Enter the Ollama host.").addText(
      (text) => text.setPlaceholder(settings.host).setValue(settings.host).onChange(async (value) => {
        settings.host = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Model").setDesc("Choose the Ollama model.").addExtraButton((button) => {
      button.setTooltip("Refresh model list").onClick(async () => {
        settings.models = await this.plugin.provider.availableModels();
        await this.plugin.saveSettings();
        this.display();
      });
    }).addDropdown((dropdown) => {
      dropdown.addOptions(Object.fromEntries(settings.models.map((model) => [model, model]))).setValue(settings.model).onChange(async (value) => {
        settings.model = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
  }
  async displayOpenAISettings() {
    const { containerEl } = this;
    const settings = this.plugin.settings.providers.openai;
    containerEl.createEl("h3", { text: "OpenAI Settings" });
    new import_obsidian3.Setting(containerEl).setName("API Key").setDesc("Enter the OpenAI API key.").addText(
      (text) => text.setPlaceholder(settings.apiKey).setValue(settings.apiKey).onChange(async (value) => {
        settings.apiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Model").setDesc("Choose the OpenAI model.").addDropdown((dropdown) => {
      dropdown.addOption("gpt-4", "GPT-4").addOption("davinci", "Davinci").setValue(settings.model).onChange(async (value) => {
        settings.model = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/main.ts
var Inscribe = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    await this.buildProviders();
    await this.setupExtention();
    this.addSettingTab(new InscribeSettingsTab(this.app, this));
  }
  async buildProviders() {
    this.providers = buildProviders(this.settings);
    const selectedProvider = this.providers.find((provider) => provider.integration === this.settings.provider);
    if (selectedProvider) {
      selectedProvider.loadCompleter();
      this.provider = selectedProvider;
    }
  }
  async setupExtention() {
    const extension = G({
      fetchFn: () => this.generateSuggestions(),
      delay: 500,
      continue_suggesting: false,
      accept_shortcut: "Tab"
    });
    this.registerEditorExtension(extension);
  }
  async *generateSuggestions() {
    let markdownFileInfo = this.app.workspace.activeEditor;
    if (!markdownFileInfo)
      return;
    const editor = markdownFileInfo.editor;
    const cursor = editor.getCursor();
    const currentLine = editor.getLine(cursor.line);
    if (!currentLine.length) {
      yield {
        display_suggestion: "",
        complete_suggestion: ""
      };
      return;
    }
    const lastChar = currentLine[cursor.ch - 1];
    if (lastChar !== " ") {
      yield { display_suggestion: "", complete_suggestion: "" };
      return;
    }
    const afterCursor = editor.getRange(
      cursor,
      { line: editor.lastLine(), ch: editor.getLine(editor.lastLine()).length }
    );
    if (afterCursor.length > 0) {
      yield { display_suggestion: "", complete_suggestion: "" };
      return;
    }
    const beforeCursor = editor.getRange({ line: 0, ch: 0 }, cursor);
    this.provider.completer.abort();
    yield* this.provider.completer.generate(beforeCursor, afterCursor);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.buildProviders();
    console.log(this.settings.providers.ollama.description);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAibm9kZV9tb2R1bGVzL2NvZGVtaXJyb3ItY29tcGFuaW9uLWV4dGVuc2lvbi9zcmMvbGliL3V0aWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9jb2RlbWlycm9yLWNvbXBhbmlvbi1leHRlbnNpb24vc3JjL2V4dGVuc2lvbi50cyIsICJzcmMvc2V0dGluZ3Mvc2V0dGluZ3MudHMiLCAic3JjL3Byb3ZpZGVycy9vbGxhbWEvY29tcGxldGVyLnRzIiwgInNyYy9wcm92aWRlcnMvb2xsYW1hL3Byb3ZpZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCAibm9kZV9tb2R1bGVzL29sbGFtYS9kaXN0L3NoYXJlZC9vbGxhbWEuY2RkYmM4NWIubWpzIiwgIm5vZGVfbW9kdWxlcy9vbGxhbWEvZGlzdC9pbmRleC5tanMiLCAic3JjL3Byb3ZpZGVycy9vcGVuYWkvcHJvdmlkZXIudHMiLCAic3JjL3Byb3ZpZGVycy9pbmRleC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgRWRpdG9yLCBQbHVnaW4gfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBpbmxpbmVTdWdnZXN0aW9uLCBTdWdnZXN0aW9uIH0gZnJvbSBcImNvZGVtaXJyb3ItY29tcGFuaW9uLWV4dGVuc2lvblwiO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9wcm92aWRlcic7XG5pbXBvcnQgeyBTZXR0aW5ncywgREVGQVVMVF9TRVRUSU5HUywgSW5zY3JpYmVTZXR0aW5nc1RhYiB9IGZyb20gJy4vc2V0dGluZ3Mvc2V0dGluZ3MnO1xuaW1wb3J0IHsgYnVpbGRQcm92aWRlcnMgfSBmcm9tICcuL3Byb3ZpZGVycyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluc2NyaWJlIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IFNldHRpbmdzO1xuXHRwcm92aWRlcjogUHJvdmlkZXJcblx0cHJvdmlkZXJzOiBQcm92aWRlcltdXG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cdFx0YXdhaXQgdGhpcy5idWlsZFByb3ZpZGVycygpO1xuXHRcdGF3YWl0IHRoaXMuc2V0dXBFeHRlbnRpb24oKTtcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IEluc2NyaWJlU2V0dGluZ3NUYWIodGhpcy5hcHAsIHRoaXMpKTtcblx0fVxuXG5cdGFzeW5jIGJ1aWxkUHJvdmlkZXJzKCkge1xuXHRcdHRoaXMucHJvdmlkZXJzID0gYnVpbGRQcm92aWRlcnModGhpcy5zZXR0aW5ncyk7XG5cdFx0Y29uc3Qgc2VsZWN0ZWRQcm92aWRlciA9IHRoaXMucHJvdmlkZXJzLmZpbmQocHJvdmlkZXIgPT4gcHJvdmlkZXIuaW50ZWdyYXRpb24gPT09IHRoaXMuc2V0dGluZ3MucHJvdmlkZXIpO1xuXHRcdGlmIChzZWxlY3RlZFByb3ZpZGVyKSB7XG5cdFx0XHRzZWxlY3RlZFByb3ZpZGVyLmxvYWRDb21wbGV0ZXIoKTtcblx0XHRcdHRoaXMucHJvdmlkZXIgPSBzZWxlY3RlZFByb3ZpZGVyO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIHNldHVwRXh0ZW50aW9uKCkge1xuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IGlubGluZVN1Z2dlc3Rpb24oe1xuXHRcdFx0ZmV0Y2hGbjogKCkgPT4gdGhpcy5nZW5lcmF0ZVN1Z2dlc3Rpb25zKCksXG5cdFx0XHRkZWxheTogNTAwLFxuXHRcdFx0Y29udGludWVfc3VnZ2VzdGluZzogZmFsc2UsXG5cdFx0XHRhY2NlcHRfc2hvcnRjdXQ6ICdUYWInLFxuXHRcdH0pO1xuXHRcdHRoaXMucmVnaXN0ZXJFZGl0b3JFeHRlbnNpb24oZXh0ZW5zaW9uKTtcblx0fVxuXG5cdGFzeW5jICpnZW5lcmF0ZVN1Z2dlc3Rpb25zKCk6IEFzeW5jR2VuZXJhdG9yPFN1Z2dlc3Rpb24sIHZvaWQsIHVua25vd24+IHtcblx0XHRsZXQgbWFya2Rvd25GaWxlSW5mbyA9IHRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVFZGl0b3I7XG5cdFx0aWYgKCFtYXJrZG93bkZpbGVJbmZvKSByZXR1cm47XG5cblx0XHRjb25zdCBlZGl0b3IgPSBtYXJrZG93bkZpbGVJbmZvLmVkaXRvciBhcyBFZGl0b3I7XG5cdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXG5cdFx0Ly8gSWYgdGhlIGN1cnJlbnQgbGluZSBpcyBlbXB0eSwgZG9uJ3Qgc3VnZ2VzdCBhbnl0aGluZy5cblx0XHRjb25zdCBjdXJyZW50TGluZSA9IGVkaXRvci5nZXRMaW5lKGN1cnNvci5saW5lKTtcblx0XHRpZiAoIWN1cnJlbnRMaW5lLmxlbmd0aCkge1xuXHRcdFx0eWllbGQge1xuXHRcdFx0XHRkaXNwbGF5X3N1Z2dlc3Rpb246IFwiXCIsXG5cdFx0XHRcdGNvbXBsZXRlX3N1Z2dlc3Rpb246IFwiXCIsXG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9ubHkgaWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgc3BhY2Ugb3IgZG90LCBzdWdnZXN0IGNvbXBsZXRpb25zLlxuXHRcdGNvbnN0IGxhc3RDaGFyID0gY3VycmVudExpbmVbY3Vyc29yLmNoIC0gMV07XG5cdFx0aWYgKGxhc3RDaGFyICE9PSBcIiBcIikge1xuXHRcdFx0eWllbGQgeyBkaXNwbGF5X3N1Z2dlc3Rpb246IFwiXCIsIGNvbXBsZXRlX3N1Z2dlc3Rpb246IFwiXCIgfTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBhZnRlckN1cnNvciA9IGVkaXRvci5nZXRSYW5nZShjdXJzb3IsXG5cdFx0XHR7IGxpbmU6IGVkaXRvci5sYXN0TGluZSgpLCBjaDogZWRpdG9yLmdldExpbmUoZWRpdG9yLmxhc3RMaW5lKCkpLmxlbmd0aCB9KTtcblxuXHRcdGlmIChhZnRlckN1cnNvci5sZW5ndGggPiAwKSB7XG5cdFx0XHR5aWVsZCB7IGRpc3BsYXlfc3VnZ2VzdGlvbjogXCJcIiwgY29tcGxldGVfc3VnZ2VzdGlvbjogXCJcIiB9O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGJlZm9yZUN1cnNvciA9IGVkaXRvci5nZXRSYW5nZSh7IGxpbmU6IDAsIGNoOiAwIH0sIGN1cnNvcik7XG5cblx0XHR0aGlzLnByb3ZpZGVyLmNvbXBsZXRlci5hYm9ydCgpO1xuXHRcdHlpZWxkKiB0aGlzLnByb3ZpZGVyLmNvbXBsZXRlci5nZW5lcmF0ZShiZWZvcmVDdXJzb3IsIGFmdGVyQ3Vyc29yKTtcblx0fVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihcblx0XHRcdHt9LFxuXHRcdFx0REVGQVVMVF9TRVRUSU5HUyxcblx0XHRcdGF3YWl0IHRoaXMubG9hZERhdGEoKVxuXHRcdCk7XG5cdH1cblxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcblx0XHRhd2FpdCB0aGlzLmJ1aWxkUHJvdmlkZXJzKCk7XG5cdFx0Y29uc29sZS5sb2codGhpcy5zZXR0aW5ncy5wcm92aWRlcnMub2xsYW1hLmRlc2NyaXB0aW9uKTtcblx0fVxufVxuIiwgIi8qKlxuICogQHBhcmFtIGYgY2FsbGJhY2tcbiAqIEBwYXJhbSB3YWl0IG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGFib3J0VmFsdWUgaWYgaGFzIGFib3J0VmFsdWUsIHByb21pc2Ugd2lsbCByZWplY3QgaXQgaWZcbiAqIEByZXR1cm5zIGRlYm91bmNlZDogUHJvbWlzZSwgZm9yY2U6ICgpID0+IHZvaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlUHJvbWlzZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuICBmbjogVCxcbiAgd2FpdDogbnVtYmVyLFxuICBhYm9ydFZhbHVlOiBhbnkgPSB1bmRlZmluZWRcbik6IHtcbiAgZGVib3VuY2VkOiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4gUHJvbWlzZTxBd2FpdGVkPFJldHVyblR5cGU8VD4+PjtcbiAgZm9yY2U6ICgpID0+IHZvaWQ7XG59IHtcbiAgbGV0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH07XG4gIGNvbnN0IGZvcmNlID0ge1xuICAgIGZvcmNlOiAoKSA9PiB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfSxcbiAgfTtcbiAgLy8gdHlwZSBBd2FpdGVkPFQ+ID0gVCBleHRlbmRzIFByb21pc2VMaWtlPGluZmVyIFU+ID8gVSA6IFRcbiAgdHlwZSBSZXR1cm5UID0gQXdhaXRlZDxSZXR1cm5UeXBlPFQ+PjtcbiAgY29uc3Qgd3JhcEZ1bmMgPSAoLi4uYXJnczogUGFyYW1ldGVyczxUPik6IFByb21pc2U8UmV0dXJuVD4gPT4ge1xuICAgIGNhbmNlbCgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShmbiguLi5hcmdzKSksIHdhaXQpO1xuICAgICAgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBpZiAoYWJvcnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVqZWN0KGFib3J0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9yY2UuZm9yY2UgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4geyBkZWJvdW5jZWQ6IHdyYXBGdW5jLCBmb3JjZTogKCkgPT4gZm9yY2UuZm9yY2UoKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2VBc3luY0dlbmVyYXRvcjxUUGFyYW1zLCBUPihcbiAgZm46ICguLi5hcmdzOiBUUGFyYW1zW10pID0+IEFzeW5jR2VuZXJhdG9yPFQsIHZvaWQsIHZvaWQ+LFxuICB3YWl0OiBudW1iZXIsXG4gIGFib3J0VmFsdWU6IGFueSA9IHVuZGVmaW5lZFxuKToge1xuICBkZWJvdW5jZWQ6ICguLi5hcmdzOiBUUGFyYW1zW10pID0+IEFzeW5jR2VuZXJhdG9yPFQsIHZvaWQsIHZvaWQ+O1xuICBmb3JjZTogKCkgPT4gdm9pZDtcbn0ge1xuICBjb25zdCBmb3JjZSA9IHtcbiAgICBmb3JjZTogKCkgPT4ge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH0sXG4gIH07XG4gIGxldCB0aW1lcjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgYXN5bmMgZnVuY3Rpb24qIHdyYXBGdW5jKC4uLmFyZ3M6IFRQYXJhbXNbXSk6IEFzeW5jR2VuZXJhdG9yPFQsIHZvaWQsIHZvaWQ+IHtcbiAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIGxldCBvd25fdGltZXI6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgIG93bl90aW1lciA9IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIHdhaXQpO1xuICAgICAgICBmb3JjZS5mb3JjZSA9ICgpID0+IHtcbiAgICAgICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChhYm9ydFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgYWJvcnRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgZm4oLi4uYXJncykpIHtcbiAgICAgIGlmIChvd25fdGltZXIgIT09IHRpbWVyKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgeWllbGQgaXRlbTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgZGVib3VuY2VkOiB3cmFwRnVuYywgZm9yY2U6ICgpID0+IGZvcmNlLmZvcmNlKCkgfTtcbn1cbiIsICJpbXBvcnQge1xuICBWaWV3UGx1Z2luLFxuICBEZWNvcmF0aW9uU2V0LFxuICBFZGl0b3JWaWV3LFxuICBWaWV3VXBkYXRlLFxuICBEZWNvcmF0aW9uLFxuICBXaWRnZXRUeXBlLFxuICBrZXltYXAsXG59IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHtcbiAgU3RhdGVFZmZlY3QsXG4gIFRleHQsXG4gIFByZWMsXG4gIFN0YXRlRmllbGQsXG4gIEVkaXRvclN0YXRlLFxuICBFZGl0b3JTZWxlY3Rpb24sXG4gIFRyYW5zYWN0aW9uU3BlYyxcbn0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgZGVib3VuY2VBc3luY0dlbmVyYXRvciB9IGZyb20gJy4vbGliL3V0aWxzJztcblxuLy8gU3BsaXR0aW5nIHRoaXMgdXAgdG8gYWxsb3cgIHNvbWVvbmUgdG8gZGlzcGxheSBhIHdob2xlIHNlbnRlbmNlIGFzIGEgc3VnZ2VzdGlvblxuLy8gd2hpbGUgb25seSBsZXR0aW5nIHRoZSB0YWIga2V5IGluc2VydCB0aGUgbmV4dCB3b3JkIGV0Yy5cbmV4cG9ydCB0eXBlIFN1Z2dlc3Rpb24gPSB7XG4gIGNvbXBsZXRlX3N1Z2dlc3Rpb246IHN0cmluZztcbiAgZGlzcGxheV9zdWdnZXN0aW9uOiBzdHJpbmc7XG4gIGFjY2VwdF9ob29rPzogKCkgPT4gdm9pZDtcbn07XG5cbi8vIEN1cnJlbnQgc3RhdGUgb2YgdGhlIGF1dG9zdWdnZXN0aW9uXG5jb25zdCBJbmxpbmVTdWdnZXN0aW9uU3RhdGUgPSBTdGF0ZUZpZWxkLmRlZmluZTx7XG4gIHN1Z2dlc3Rpb246IG51bGwgfCBTdWdnZXN0aW9uO1xufT4oe1xuICBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHsgc3VnZ2VzdGlvbjogbnVsbCB9O1xuICB9LFxuICB1cGRhdGUoX186IGFueSwgdHI6IGFueSkge1xuICAgIGNvbnN0IGlubGluZVN1Z2dlc3Rpb24gPSB0ci5lZmZlY3RzLmZpbmQoKGU6IGFueSkgPT5cbiAgICAgIGUuaXMoSW5saW5lU3VnZ2VzdGlvbkVmZmVjdClcbiAgICApO1xuICAgIGlmICh0ci5zdGF0ZS5kb2MpXG4gICAgICBpZiAoXG4gICAgICAgIGlubGluZVN1Z2dlc3Rpb24gJiZcbiAgICAgICAgKGlubGluZVN1Z2dlc3Rpb24udmFsdWUuZG9jID09IG51bGwgfHxcbiAgICAgICAgICB0ci5zdGF0ZS5kb2MgPT0gaW5saW5lU3VnZ2VzdGlvbi52YWx1ZS5kb2MpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHsgc3VnZ2VzdGlvbjogaW5saW5lU3VnZ2VzdGlvbi52YWx1ZS5zdWdnZXN0aW9uIH07XG4gICAgICB9XG4gICAgcmV0dXJuIHsgc3VnZ2VzdGlvbjogbnVsbCB9O1xuICB9LFxufSk7XG5cbmNvbnN0IElubGluZVN1Z2dlc3Rpb25FZmZlY3QgPSBTdGF0ZUVmZmVjdC5kZWZpbmU8e1xuICBzdWdnZXN0aW9uOiBTdWdnZXN0aW9uIHwgbnVsbDtcbiAgZG9jOiBUZXh0IHwgbnVsbDtcbn0+KCk7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBzdWdnZXN0aW9uIGZvciB0aGUgbmV4dCB3b3JkXG4gKi9cbmZ1bmN0aW9uIGlubGluZVN1Z2dlc3Rpb25EZWNvcmF0aW9uKHZpZXc6IEVkaXRvclZpZXcsIHByZWZpeDogc3RyaW5nKSB7XG4gIGNvbnN0IHBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgY29uc3Qgd2lkZ2V0cyA9IFtdO1xuICBjb25zdCB3ID0gRGVjb3JhdGlvbi53aWRnZXQoe1xuICAgIHdpZGdldDogbmV3IElubGluZVN1Z2dlc3Rpb25XaWRnZXQocHJlZml4KSxcbiAgICBzaWRlOiAxLFxuICB9KTtcbiAgd2lkZ2V0cy5wdXNoKHcucmFuZ2UocG9zKSk7XG4gIHJldHVybiBEZWNvcmF0aW9uLnNldCh3aWRnZXRzKTtcbn1cblxuY2xhc3MgSW5saW5lU3VnZ2VzdGlvbldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICBzdWdnZXN0aW9uOiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKHN1Z2dlc3Rpb246IHN0cmluZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zdWdnZXN0aW9uID0gc3VnZ2VzdGlvbjtcbiAgfVxuICB0b0RPTSgpIHtcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgZGl2LnN0eWxlLm9wYWNpdHkgPSAnMC40JztcbiAgICBkaXYuY2xhc3NOYW1lID0gJ2NtLWlubGluZS1zdWdnZXN0aW9uJztcbiAgICBkaXYudGV4dENvbnRlbnQgPSB0aGlzLnN1Z2dlc3Rpb247XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxufVxuXG50eXBlIElubGluZUZldGNoRm4gPSAoc3RhdGU6IEVkaXRvclN0YXRlKSA9PiBBc3luY0dlbmVyYXRvcjxTdWdnZXN0aW9uPjtcblxuZXhwb3J0IGNvbnN0IGZldGNoU3VnZ2VzdGlvbiA9IChmZXRjaEZuOiBJbmxpbmVGZXRjaEZuKSA9PiB7XG4gIGxldCBzdWdnZXN0aW9uSWQgPSAwO1xuICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoXG4gICAgY2xhc3MgRmV0Y2hQbHVnaW4ge1xuICAgICAgYXN5bmMgdXBkYXRlKHVwZGF0ZTogVmlld1VwZGF0ZSkge1xuICAgICAgICBjb25zdCBkb2MgPSB1cGRhdGUuc3RhdGUuZG9jO1xuICAgICAgICAvLyBPbmx5IGZldGNoIGlmIHRoZSBkb2N1bWVudCBoYXMgY2hhbmdlZFxuICAgICAgICBpZiAoIXVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdWdnZXN0aW9uSWQgPSArK3N1Z2dlc3Rpb25JZDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCByZXN1bHQgb2YgZmV0Y2hGbih1cGRhdGUuc3RhdGUpKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTdWdnZXN0aW9uSWQgIT0gc3VnZ2VzdGlvbklkKSByZXR1cm47XG4gICAgICAgICAgdXBkYXRlLnZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgZWZmZWN0czogSW5saW5lU3VnZ2VzdGlvbkVmZmVjdC5vZih7XG4gICAgICAgICAgICAgIHN1Z2dlc3Rpb246IHJlc3VsdCxcbiAgICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgKTtcbn07XG5cbmNsYXNzIFJlbmRlclBsdWdpbiB7XG4gIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uU2V0O1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBFbXB0eSBkZWNvcmF0aW9uc1xuICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBEZWNvcmF0aW9uLm5vbmU7XG4gIH1cbiAgdXBkYXRlKHVwZGF0ZTogVmlld1VwZGF0ZSkge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb246IFN1Z2dlc3Rpb24gfCBudWxsID0gdXBkYXRlLnN0YXRlLmZpZWxkKFxuICAgICAgSW5saW5lU3VnZ2VzdGlvblN0YXRlXG4gICAgKT8uc3VnZ2VzdGlvbjtcbiAgICBpZiAoIXN1Z2dlc3Rpb24pIHtcbiAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBpbmxpbmVTdWdnZXN0aW9uRGVjb3JhdGlvbihcbiAgICAgIHVwZGF0ZS52aWV3LFxuICAgICAgc3VnZ2VzdGlvbi5kaXNwbGF5X3N1Z2dlc3Rpb25cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHJlbmRlcklubGluZVN1Z2dlc3Rpb25QbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhSZW5kZXJQbHVnaW4sIHtcbiAgZGVjb3JhdGlvbnM6ICh2OiBSZW5kZXJQbHVnaW4pID0+IHYuZGVjb3JhdGlvbnMsXG59KTtcblxuY2xhc3MgaW5saW5lU3VnZ2VzdGlvbktleW1hcCB7XG4gIHN1Z2dlc3RGbjogSW5saW5lRmV0Y2hGbiB8IG51bGw7XG4gIGtleW1hcDogYW55O1xuICBjb21wbGV0aW9uSWQ6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihzdWdnZXN0Rm46IElubGluZUZldGNoRm4gfCBudWxsLCBhY2NlcHRfc2hvcnRjdXQ6IHN0cmluZykge1xuICAgIHRoaXMuc3VnZ2VzdEZuID0gc3VnZ2VzdEZuO1xuICAgIHRoaXMua2V5bWFwID0gUHJlYy5oaWdoZXN0KFxuICAgICAga2V5bWFwLm9mKFtcbiAgICAgICAge1xuICAgICAgICAgIGtleTogYWNjZXB0X3Nob3J0Y3V0LFxuICAgICAgICAgIHJ1bjogKHZpZXc6IEVkaXRvclZpZXcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bih2aWV3KTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgXSlcbiAgICApO1xuICAgIHRoaXMuY29tcGxldGlvbklkID0gMDtcbiAgfVxuXG4gIHJ1biA9ICh2aWV3OiBFZGl0b3JWaWV3KSA9PiB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbjogU3VnZ2VzdGlvbiB8IG51bGwgPSB2aWV3LnN0YXRlLmZpZWxkKFxuICAgICAgSW5saW5lU3VnZ2VzdGlvblN0YXRlXG4gICAgKT8uc3VnZ2VzdGlvbjtcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIHN1Z2dlc3Rpb24sIGRvIG5vdGhpbmcgYW5kIGxldCB0aGUgZGVmYXVsdCBrZXltYXAgaGFuZGxlIGl0XG4gICAgaWYgKCFzdWdnZXN0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAuLi5pbnNlcnRDb21wbGV0aW9uVGV4dChcbiAgICAgICAgdmlldy5zdGF0ZSxcbiAgICAgICAgc3VnZ2VzdGlvbi5jb21wbGV0ZV9zdWdnZXN0aW9uLFxuICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQsXG4gICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZFxuICAgICAgKSxcbiAgICB9KTtcbiAgICBzdWdnZXN0aW9uLmFjY2VwdF9ob29rPy4oKTtcblxuICAgIC8vIFJlLXRyaWdnZXIgdGhlIHN1Z2dlc3Rpb25cbiAgICBjb25zdCByZXRyaWdnZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdWdnZXN0Rm4gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgY29uc3QgY29tcGxldGlvbklkID0gKyt0aGlzLmNvbXBsZXRpb25JZDtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgcmVzdWx0IG9mIHRoaXMuc3VnZ2VzdEZuKHZpZXcuc3RhdGUpKSB7XG4gICAgICAgIGlmIChjb21wbGV0aW9uSWQgIT0gdGhpcy5jb21wbGV0aW9uSWQpIHJldHVybjtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgZWZmZWN0czogSW5saW5lU3VnZ2VzdGlvbkVmZmVjdC5vZih7XG4gICAgICAgICAgICBzdWdnZXN0aW9uOiB7XG4gICAgICAgICAgICAgIGNvbXBsZXRlX3N1Z2dlc3Rpb246IHJlc3VsdC5jb21wbGV0ZV9zdWdnZXN0aW9uLFxuICAgICAgICAgICAgICBkaXNwbGF5X3N1Z2dlc3Rpb246IHJlc3VsdC5kaXNwbGF5X3N1Z2dlc3Rpb24sXG4gICAgICAgICAgICAgIGFjY2VwdF9ob29rOiByZXN1bHQuYWNjZXB0X2hvb2ssXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9jOiBudWxsLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHJpZ2dlcigpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc2VydENvbXBsZXRpb25UZXh0KFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHRleHQ6IHN0cmluZyxcbiAgZnJvbTogbnVtYmVyLFxuICB0bzogbnVtYmVyXG4pOiBUcmFuc2FjdGlvblNwZWMge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLmNoYW5nZUJ5UmFuZ2UoKHJhbmdlKSA9PiB7XG4gICAgICBpZiAocmFuZ2UgPT0gc3RhdGUuc2VsZWN0aW9uLm1haW4pXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhbmdlczogeyBmcm9tOiBmcm9tLCB0bzogdG8sIGluc2VydDogdGV4dCB9LFxuICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20gKyB0ZXh0Lmxlbmd0aCksXG4gICAgICAgIH07XG4gICAgICBjb25zdCBsZW4gPSB0byAtIGZyb207XG4gICAgICBpZiAoXG4gICAgICAgICFyYW5nZS5lbXB0eSB8fFxuICAgICAgICAobGVuICYmXG4gICAgICAgICAgc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSAtIGxlbiwgcmFuZ2UuZnJvbSkgIT1cbiAgICAgICAgICAgIHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSAtIGxlbiwgdG86IHJhbmdlLmZyb20sIGluc2VydDogdGV4dCB9LFxuICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tIC0gbGVuICsgdGV4dC5sZW5ndGgpLFxuICAgICAgfTtcbiAgICB9KSxcbiAgICB1c2VyRXZlbnQ6ICdpbnB1dC5jb21wbGV0ZScsXG4gIH07XG59XG5cbnR5cGUgSW5saW5lU3VnZ2VzdGlvbk9wdGlvbnMgPSB7XG4gIGZldGNoRm46IChcbiAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgKSA9PiBQcm9taXNlPHN0cmluZyB8IFN1Z2dlc3Rpb24+IHwgQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj47XG4gIGRlbGF5PzogbnVtYmVyO1xuICBjb250aW51ZV9zdWdnZXN0aW5nPzogYm9vbGVhbjtcbiAgYWNjZXB0X3Nob3J0Y3V0Pzogc3RyaW5nIHwgbnVsbDtcbn07XG5cbi8vIFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5mdW5jdGlvbiB0b1N1Z2dlc3Rpb24oc3VnZ2VzdGlvbjogc3RyaW5nIHwgU3VnZ2VzdGlvbik6IFN1Z2dlc3Rpb24ge1xuICBpZiAodHlwZW9mIHN1Z2dlc3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBsZXRlX3N1Z2dlc3Rpb246IHN1Z2dlc3Rpb24sXG4gICAgICBkaXNwbGF5X3N1Z2dlc3Rpb246IHN1Z2dlc3Rpb24sXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3VnZ2VzdGlvbjtcbn1cblxuZnVuY3Rpb24gdG9TdWdnZXN0aW9uRm4oXG4gIGZldGNoRm46IChcbiAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgKSA9PiBQcm9taXNlPHN0cmluZyB8IFN1Z2dlc3Rpb24+IHwgQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj5cbik6IElubGluZUZldGNoRm4ge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24qIChzdGF0ZTogRWRpdG9yU3RhdGUpIHtcbiAgICBjb25zdCBzdWdnZXN0aW9uID0gYXdhaXQgZmV0Y2hGbihzdGF0ZSk7XG5cbiAgICAvLyBJZiBpdCdzIGEgc3RyaW5nIG9yIGEgU3VnZ2VzdGlvblxuICAgIGlmICh0eXBlb2Ygc3VnZ2VzdGlvbiA9PT0gJ3N0cmluZycgfHwgJ2NvbXBsZXRlX3N1Z2dlc3Rpb24nIGluIHN1Z2dlc3Rpb24pIHtcbiAgICAgIHlpZWxkIHRvU3VnZ2VzdGlvbihzdWdnZXN0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IHMgb2Ygc3VnZ2VzdGlvbikge1xuICAgICAgeWllbGQgdG9TdWdnZXN0aW9uKHMpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlubGluZVN1Z2dlc3Rpb24ob3B0aW9uczogSW5saW5lU3VnZ2VzdGlvbk9wdGlvbnMpIHtcbiAgY29uc3QgeyBkZWxheSA9IDUwMCwgYWNjZXB0X3Nob3J0Y3V0ID0gJ1RhYicgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZldGNoRm4gPSB0b1N1Z2dlc3Rpb25GbihvcHRpb25zLmZldGNoRm4pO1xuICBjb25zdCB7IGRlYm91bmNlZDogZGVib3VuY2VkX2ZldGNoRm4gfSA9IGRlYm91bmNlQXN5bmNHZW5lcmF0b3IoXG4gICAgZmV0Y2hGbixcbiAgICBkZWxheVxuICApO1xuICByZXR1cm4gYWNjZXB0X3Nob3J0Y3V0XG4gICAgPyBbXG4gICAgICAgIElubGluZVN1Z2dlc3Rpb25TdGF0ZSxcbiAgICAgICAgZmV0Y2hTdWdnZXN0aW9uKGRlYm91bmNlZF9mZXRjaEZuKSxcbiAgICAgICAgcmVuZGVySW5saW5lU3VnZ2VzdGlvblBsdWdpbixcbiAgICAgICAgbmV3IGlubGluZVN1Z2dlc3Rpb25LZXltYXAoXG4gICAgICAgICAgb3B0aW9ucy5jb250aW51ZV9zdWdnZXN0aW5nID8gZmV0Y2hGbiA6IG51bGwsXG4gICAgICAgICAgYWNjZXB0X3Nob3J0Y3V0XG4gICAgICAgICkua2V5bWFwLFxuICAgICAgXVxuICAgIDogW1xuICAgICAgICBJbmxpbmVTdWdnZXN0aW9uU3RhdGUsXG4gICAgICAgIGZldGNoU3VnZ2VzdGlvbihkZWJvdW5jZWRfZmV0Y2hGbiksXG4gICAgICAgIHJlbmRlcklubGluZVN1Z2dlc3Rpb25QbHVnaW4sXG4gICAgICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yY2VhYmxlSW5saW5lU3VnZ2VzdGlvbihvcHRpb25zOiBJbmxpbmVTdWdnZXN0aW9uT3B0aW9ucykge1xuICBjb25zdCB7IGRlbGF5ID0gNTAwLCBhY2NlcHRfc2hvcnRjdXQgPSAnVGFiJyB9ID0gb3B0aW9ucztcbiAgY29uc3QgZmV0Y2hGbiA9IHRvU3VnZ2VzdGlvbkZuKG9wdGlvbnMuZmV0Y2hGbik7XG4gIGNvbnN0IHsgZGVib3VuY2VkOiBkZWJvdW5jZWRfZmV0Y2hGbiwgZm9yY2U6IGZvcmNlX2ZldGNoIH0gPVxuICAgIGRlYm91bmNlQXN5bmNHZW5lcmF0b3IoZmV0Y2hGbiwgZGVsYXkpO1xuICByZXR1cm4ge1xuICAgIGV4dGVuc2lvbjogYWNjZXB0X3Nob3J0Y3V0XG4gICAgICA/IFtcbiAgICAgICAgICBJbmxpbmVTdWdnZXN0aW9uU3RhdGUsXG4gICAgICAgICAgZmV0Y2hTdWdnZXN0aW9uKGRlYm91bmNlZF9mZXRjaEZuKSxcbiAgICAgICAgICByZW5kZXJJbmxpbmVTdWdnZXN0aW9uUGx1Z2luLFxuICAgICAgICAgIG5ldyBpbmxpbmVTdWdnZXN0aW9uS2V5bWFwKFxuICAgICAgICAgICAgb3B0aW9ucy5jb250aW51ZV9zdWdnZXN0aW5nID8gZmV0Y2hGbiA6IG51bGwsXG4gICAgICAgICAgICBhY2NlcHRfc2hvcnRjdXRcbiAgICAgICAgICApLmtleW1hcCxcbiAgICAgICAgXVxuICAgICAgOiBbXG4gICAgICAgICAgSW5saW5lU3VnZ2VzdGlvblN0YXRlLFxuICAgICAgICAgIGZldGNoU3VnZ2VzdGlvbihkZWJvdW5jZWRfZmV0Y2hGbiksXG4gICAgICAgICAgcmVuZGVySW5saW5lU3VnZ2VzdGlvblBsdWdpbixcbiAgICAgICAgXSxcbiAgICBmb3JjZV9mZXRjaDogZm9yY2VfZmV0Y2gsXG4gIH07XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBPbGxhbWFTZXR0aW5ncyB9IGZyb20gXCJzcmMvcHJvdmlkZXJzL29sbGFtYVwiO1xuaW1wb3J0IEluc2NyaWJlIGZyb20gXCJzcmMvbWFpblwiO1xuaW1wb3J0IHsgT3BlbkFJU2V0dGluZ3MgfSBmcm9tIFwic3JjL3Byb3ZpZGVycy9vcGVuYWlcIjtcbmltcG9ydCB7IEludGVncmF0aW9uIH0gZnJvbSBcInNyYy9wcm92aWRlcnNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBTZXR0aW5ncyB7XG4gICAgcHJvdmlkZXI6IHN0cmluZyxcbiAgICBwcm92aWRlcnM6IHtcbiAgICAgICAgb2xsYW1hOiBPbGxhbWFTZXR0aW5ncyxcbiAgICAgICAgb3BlbmFpOiBPcGVuQUlTZXR0aW5ncyxcbiAgICB9LFxuICAgIHByb210dHk6IGJvb2xlYW4sXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBTZXR0aW5ncyA9IHtcbiAgICBwcm92aWRlcjogXCJvbGxhbWFcIixcbiAgICBwcm92aWRlcnM6IHtcbiAgICAgICAgb3BlbmFpOiB7XG4gICAgICAgICAgICBpbnRlZ3JhdGlvbjogSW50ZWdyYXRpb24uT1BFTkFJLFxuICAgICAgICAgICAgbmFtZTogXCJPcGVuIEFJXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJPcGVuQUkgaXMgYW4gYXJ0aWZpY2lhbCBpbnRlbGxpZ2VuY2UgcmVzZWFyY2ggbGFib3JhdG9yeSBjb25zaXN0aW5nIG9mIHRoZSBmb3ItcHJvZml0IE9wZW5BSSBMUCBhbmQgdGhlIG5vbi1wcm9maXQgT3BlbkFJIEluYy5cIixcbiAgICAgICAgICAgIGFwaUtleTogXCJcIixcbiAgICAgICAgICAgIG1vZGVsOiBcImdwdC00XCJcbiAgICAgICAgfSxcbiAgICAgICAgb2xsYW1hOiB7XG4gICAgICAgICAgICBpbnRlZ3JhdGlvbjogSW50ZWdyYXRpb24uT0xMQU1BLFxuICAgICAgICAgICAgbmFtZTogXCJPbGxhbWFcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIk9sbGFtYSBpcyBhbiBBSSBwcm92aWRlciB0aGF0IG9mZmVycyBhIHZhcmlldHkgb2YgbW9kZWxzIGZvciBkaWZmZXJlbnQgdXNlIGNhc2VzLlwiLFxuICAgICAgICAgICAgaG9zdDogXCJodHRwOi8vbG9jYWxob3N0OjExNDM0XCIsXG4gICAgICAgICAgICBtb2RlbDogXCJtaXN0cmFsLW5lbW9cIixcbiAgICAgICAgICAgIG1vZGVsczogW1wibGxhbWEzLjI6bGF0ZXN0XCJdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgcHJvbXR0eTogdHJ1ZSxcbn1cblxuZXhwb3J0IGNsYXNzIEluc2NyaWJlU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcHJpdmF0ZSBwbHVnaW46IEluc2NyaWJlKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICB9XG5cbiAgICBhc3luYyBkaXNwbGF5KCkge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgICAgIC8vIEFJIFBST1ZJREVSIFNFTEVDVE9SXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIlByb3ZpZGVyIFNldHRpbmdzXCIgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIkFJIFByb3ZpZGVyXCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkNob29zZSB5b3VyIHByZWZlcnJlZCBBSSBwcm92aWRlci5cIilcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlcnMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LCB2YWx1ZS5uYW1lXSkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVyKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlciA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNhc2UgSW50ZWdyYXRpb24uT0xMQU1BOlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzcGxheU9sbGFtYVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEludGVncmF0aW9uLk9QRU5BSTpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc3BsYXlPcGVuQUlTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGRpc3BsYXlPbGxhbWFTZXR0aW5ncygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlcnMub2xsYW1hO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDNcIiwgeyB0ZXh0OiBcIk9sbGFtYSBTZXR0aW5nc1wiIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJIb3N0XCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkVudGVyIHRoZSBPbGxhbWEgaG9zdC5cIilcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKHNldHRpbmdzLmhvc3QpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5ob3N0KVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5ob3N0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIk1vZGVsXCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkNob29zZSB0aGUgT2xsYW1hIG1vZGVsLlwiKVxuICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKChidXR0b24pID0+IHtcbiAgICAgICAgICAgICAgICBidXR0b24uc2V0VG9vbHRpcChcIlJlZnJlc2ggbW9kZWwgbGlzdFwiKS5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubW9kZWxzID0gYXdhaXQgdGhpcy5wbHVnaW4ucHJvdmlkZXIuYXZhaWxhYmxlTW9kZWxzKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oKGRyb3Bkb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbnMoT2JqZWN0LmZyb21FbnRyaWVzKHNldHRpbmdzLm1vZGVscy5tYXAobW9kZWwgPT4gW21vZGVsLCBtb2RlbF0pKSlcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLm1vZGVsKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGRpc3BsYXlPcGVuQUlTZXR0aW5ncygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlcnMub3BlbmFpO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDNcIiwgeyB0ZXh0OiBcIk9wZW5BSSBTZXR0aW5nc1wiIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJBUEkgS2V5XCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkVudGVyIHRoZSBPcGVuQUkgQVBJIGtleS5cIilcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKHNldHRpbmdzLmFwaUtleSlcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLmFwaUtleSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYXBpS2V5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJNb2RlbFwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJDaG9vc2UgdGhlIE9wZW5BSSBtb2RlbC5cIilcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwiZ3B0LTRcIiwgXCJHUFQtNFwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwiZGF2aW5jaVwiLCBcIkRhdmluY2lcIilcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLm1vZGVsKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cbiIsICJpbXBvcnQgeyBMaXN0UmVzcG9uc2UsIE1vZGVsUmVzcG9uc2UsIE9sbGFtYSB9IGZyb20gXCJvbGxhbWFcIjtcbmltcG9ydCB7IFN1Z2dlc3Rpb24gfSBmcm9tIFwiY29kZW1pcnJvci1jb21wYW5pb24tZXh0ZW5zaW9uXCI7XG5pbXBvcnQgeyBPbGxhbWFTZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBDb21wbGV0ZXIgfSBmcm9tIFwiLi5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2xsYW1hQ29tcGxldGVyIGltcGxlbWVudHMgQ29tcGxldGVyIHtcbiAgICBjbGllbnQ6IE9sbGFtYVxuICAgIHNldHRpbmdzOiBPbGxhbWFTZXR0aW5ncztcblxuICAgIGNvbnN0cnVjdG9yKHNldHRpbnM6IE9sbGFtYVNldHRpbmdzLCBjbGllbnQ6IE9sbGFtYSkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGlucztcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuXG4gICAgYXN5bmMgKmdlbmVyYXRlKHByZWZpeDogc3RyaW5nLCBzdWZmaXg6IHN0cmluZyk6IEFzeW5jR2VuZXJhdG9yPFN1Z2dlc3Rpb24+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJmZXRjaGluZyBjb21wbGV0aW9uXCIpO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VJdGVyYXRvciA9IGF3YWl0IHRoaXMuY2xpZW50LmdlbmVyYXRlKHtcbiAgICAgICAgICAgIG1vZGVsOiB0aGlzLnNldHRpbmdzLm1vZGVsLFxuICAgICAgICAgICAgcHJvbXB0OiBwcmVmaXgsXG4gICAgICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBjb21wbGV0aW9uID0gXCJcIjtcbiAgICAgICAgZm9yIGF3YWl0IChsZXQgcmVzcG9uc2Ugb2YgcHJvbWlzZUl0ZXJhdG9yKSB7XG4gICAgICAgICAgICBjb21wbGV0aW9uICs9IHJlc3BvbnNlLnJlc3BvbnNlO1xuICAgICAgICAgICAgeWllbGQgeyBjb21wbGV0ZV9zdWdnZXN0aW9uOiBjb21wbGV0aW9uLCBkaXNwbGF5X3N1Z2dlc3Rpb246IGNvbXBsZXRpb24gfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgYWJvcnQoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY2FuY2VsaW5nIGNvbXBsZXRpb25cIik7XG4gICAgICAgIHRoaXMuY2xpZW50LmFib3J0KCk7XG4gICAgfVxufVxuXG5cbiIsICJpbXBvcnQgeyBhZGRJY29uLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBJbnRlZ3JhdGlvbiB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tIFwiLi4vcHJvdmlkZXJcIjtcbmltcG9ydCBPbGxhbWFDb21wbGV0ZXIgZnJvbSBcIi4vY29tcGxldGVyXCI7XG5pbXBvcnQgeyBPbGxhbWFTZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCI7XG5pbXBvcnQgSW5zY3JpYmUgZnJvbSBcInNyYy9tYWluXCI7XG5pbXBvcnQgeyBMaXN0UmVzcG9uc2UsIE1vZGVsUmVzcG9uc2UsIE9sbGFtYSB9IGZyb20gXCJvbGxhbWFcIjtcblxuZXhwb3J0IGNsYXNzIE9sbGFtYVByb3ZpZGVyIGltcGxlbWVudHMgUHJvdmlkZXIge1xuICAgIGludGVncmF0aW9uOiBJbnRlZ3JhdGlvbiA9IEludGVncmF0aW9uLk9MTEFNQTtcbiAgICBuYW1lOiBzdHJpbmcgPSBcIk9sbGFtYVwiO1xuICAgIGRlc2NyaXB0aW9uOiBcIk9sbGFtYSBpcyBhIGxhbmd1YWdlIG1vZGVsIHRoYXQgY2FuIGdlbmVyYXRlIHRleHQgYmFzZWQgb24gYSBwcm9tcHQuXCI7XG4gICAgc2V0dGluZ3M6IE9sbGFtYVNldHRpbmdzO1xuICAgIGNvbXBsZXRlcjogT2xsYW1hQ29tcGxldGVyO1xuICAgIGNsaWVudDogT2xsYW1hO1xuXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IE9sbGFtYVNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5jbGllbnQgPSBuZXcgT2xsYW1hKHsgaG9zdDogdGhpcy5zZXR0aW5ncy5ob3N0IH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWRDb21wbGV0ZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibG9hZGluZyBvbGxhbWEgY29tcGxldGVyXCIpO1xuICAgICAgICB0aGlzLmNvbXBsZXRlciA9IG5ldyBPbGxhbWFDb21wbGV0ZXIodGhpcy5zZXR0aW5ncywgdGhpcy5jbGllbnQpO1xuICAgIH1cblxuICAgIGFzeW5jIGF2YWlsYWJsZU1vZGVscygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlOiBMaXN0UmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5saXN0KCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5tb2RlbHMubWFwKChtb2RlbDogTW9kZWxSZXNwb25zZSkgPT4gbW9kZWwubmFtZSk7XG4gICAgfVxuXG4gICAgZGlzcGxheVNldHRpbmdzKHBsdWdpbjogSW5zY3JpYmUsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgZGlzcGxheTogKCkgPT4gUHJvbWlzZTx2b2lkPik6IHZvaWQge1xuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJPbGxhbWEgU2V0dGluZ3NcIiB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiSG9zdFwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJFbnRlciB0aGUgT2xsYW1hIGhvc3QuXCIpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcih0aGlzLnNldHRpbmdzLmhvc3QpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLmhvc3QpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaG9zdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiTW9kZWxcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiQ2hvb3NlIHRoZSBPbGxhbWEgbW9kZWwuXCIpXG4gICAgICAgICAgICAuYWRkRXh0cmFCdXR0b24oKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRUb29sdGlwKFwiUmVmcmVzaCBtb2RlbCBsaXN0XCIpLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1vZGVscyA9IGF3YWl0IHRoaXMuYXZhaWxhYmxlTW9kZWxzKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9ucyhPYmplY3QuZnJvbUVudHJpZXModGhpcy5zZXR0aW5ncy5tb2RlbHMubWFwKG1vZGVsID0+IFttb2RlbCwgbW9kZWxdKSkpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLm1vZGVsKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICB9XG59IiwgIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xudmFyIGcgPVxuICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMpIHx8XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpIHx8XG4gIHt9XG5cbnZhciBzdXBwb3J0ID0ge1xuICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIGcsXG4gIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBnICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICBibG9iOlxuICAgICdGaWxlUmVhZGVyJyBpbiBnICYmXG4gICAgJ0Jsb2InIGluIGcgJiZcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIGcsXG4gIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIGdcbn1cblxuZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG59XG5cbmlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICBdXG5cbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gIH1cbiAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH4hXS9pLnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZTogXCInICsgbmFtZSArICdcIicpXG4gIH1cbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKVxuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3Jcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICB0aGlzLm1hcCA9IHt9XG5cbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICBpZiAoaGVhZGVyLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlcnMgY29uc3RydWN0b3I6IGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQnICsgaGVhZGVyLmxlbmd0aClcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICB9LCB0aGlzKVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdXG4gIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbkhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2gobmFtZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaXRlbXMucHVzaCh2YWx1ZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5pZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xufVxuXG5mdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gIGlmIChib2R5Ll9ub0JvZHkpIHJldHVyblxuICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgfVxuICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgfVxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHZhciBtYXRjaCA9IC9jaGFyc2V0PShbQS1aYS16MC05Xy1dKykvLmV4ZWMoYmxvYi50eXBlKVxuICB2YXIgZW5jb2RpbmcgPSBtYXRjaCA/IG1hdGNoWzFdIDogJ3V0Zi04J1xuICByZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZylcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgaWYgKGJ1Zi5zbGljZSkge1xuICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gIH1cbn1cblxuZnVuY3Rpb24gQm9keSgpIHtcbiAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgLypcbiAgICAgIGZldGNoLW1vY2sgd3JhcHMgdGhlIFJlc3BvbnNlIG9iamVjdCBpbiBhbiBFUzYgUHJveHkgdG9cbiAgICAgIHByb3ZpZGUgdXNlZnVsIHRlc3QgaGFybmVzcyBmZWF0dXJlcyBzdWNoIGFzIGZsdXNoLiBIb3dldmVyLCBvblxuICAgICAgRVM1IGJyb3dzZXJzIHdpdGhvdXQgZmV0Y2ggb3IgUHJveHkgc3VwcG9ydCBwb2xseWZpbGxzIG11c3QgYmUgdXNlZDtcbiAgICAgIHRoZSBwcm94eS1wb2xseWZpbGwgaXMgdW5hYmxlIHRvIHByb3h5IGFuIGF0dHJpYnV0ZSB1bmxlc3MgaXQgZXhpc3RzXG4gICAgICBvbiB0aGUgb2JqZWN0IGJlZm9yZSB0aGUgUHJveHkgaXMgY3JlYXRlZC4gVGhpcyBjaGFuZ2UgZW5zdXJlc1xuICAgICAgUmVzcG9uc2UuYm9keVVzZWQgZXhpc3RzIG9uIHRoZSBpbnN0YW5jZSwgd2hpbGUgbWFpbnRhaW5pbmcgdGhlXG4gICAgICBzZW1hbnRpYyBvZiBzZXR0aW5nIFJlcXVlc3QuYm9keVVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgX2luaXRCb2R5IGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIHRoaXMuYm9keVVzZWQgPSB0aGlzLmJvZHlVc2VkXG4gICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aGlzLl9ub0JvZHkgPSB0cnVlO1xuICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBpc0NvbnN1bWVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChpc0NvbnN1bWVkKSB7XG4gICAgICAgIHJldHVybiBpc0NvbnN1bWVkXG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQgKyB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBhcyBBcnJheUJ1ZmZlcicpXG4gICAgfVxuICB9XG5cbiAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3RlZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxudmFyIG1ldGhvZHMgPSBbJ0NPTk5FQ1QnLCAnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUEFUQ0gnLCAnUE9TVCcsICdQVVQnLCAnVFJBQ0UnXVxuXG5mdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgfVxuICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsXG4gICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpXG4gIH1cblxuICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbidcbiAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB9XG4gIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbCB8fCAoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnQWJvcnRDb250cm9sbGVyJyBpbiBnKSB7XG4gICAgICB2YXIgY3RybCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHJldHVybiBjdHJsLnNpZ25hbDtcbiAgICB9XG4gIH0oKSk7XG4gIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgfVxuICB0aGlzLl9pbml0Qm9keShib2R5KVxuXG4gIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgIGlmIChvcHRpb25zLmNhY2hlID09PSAnbm8tc3RvcmUnIHx8IG9wdGlvbnMuY2FjaGUgPT09ICduby1jYWNoZScpIHtcbiAgICAgIC8vIFNlYXJjaCBmb3IgYSAnXycgcGFyYW1ldGVyIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgIHZhciByZVBhcmFtU2VhcmNoID0gLyhbPyZdKV89W14mXSovXG4gICAgICBpZiAocmVQYXJhbVNlYXJjaC50ZXN0KHRoaXMudXJsKSkge1xuICAgICAgICAvLyBJZiBpdCBhbHJlYWR5IGV4aXN0cyB0aGVuIHNldCB0aGUgdmFsdWUgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHRoaXMudXJsID0gdGhpcy51cmwucmVwbGFjZShyZVBhcmFtU2VhcmNoLCAnJDFfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBhZGQgYSBuZXcgJ18nIHBhcmFtZXRlciB0byB0aGUgZW5kIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB2YXIgcmVRdWVyeVN0cmluZyA9IC9cXD8vXG4gICAgICAgIHRoaXMudXJsICs9IChyZVF1ZXJ5U3RyaW5nLnRlc3QodGhpcy51cmwpID8gJyYnIDogJz8nKSArICdfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBib2R5XG4gICAgLnRyaW0oKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBmb3JtXG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpXG4gIC8vIEF2b2lkaW5nIHNwbGl0IHZpYSByZWdleCB0byB3b3JrIGFyb3VuZCBhIGNvbW1vbiBJRTExIGJ1ZyB3aXRoIHRoZSBjb3JlLWpzIDMuNi4wIHJlZ2V4IHBvbHlmaWxsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvaXNzdWVzLzc0OFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNzUxXG4gIHByZVByb2Nlc3NlZEhlYWRlcnNcbiAgICAuc3BsaXQoJ1xccicpXG4gICAgLm1hcChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHJldHVybiBoZWFkZXIuaW5kZXhPZignXFxuJykgPT09IDAgPyBoZWFkZXIuc3Vic3RyKDEsIGhlYWRlci5sZW5ndGgpIDogaGVhZGVyXG4gICAgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Jlc3BvbnNlICcgKyBlcnJvci5tZXNzYWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG5leHBvcnQgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1c1xuICBpZiAodGhpcy5zdGF0dXMgPCAyMDAgfHwgdGhpcy5zdGF0dXMgPiA1OTkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Jlc3BvbnNlJzogVGhlIHN0YXR1cyBwcm92aWRlZCAoMCkgaXMgb3V0c2lkZSB0aGUgcmFuZ2UgWzIwMCwgNTk5XS5cIilcbiAgfVxuICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiAnJyArIG9wdGlvbnMuc3RhdHVzVGV4dFxuICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG59XG5cbkJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cblJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICB1cmw6IHRoaXMudXJsXG4gIH0pXG59XG5cblJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAyMDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgcmVzcG9uc2Uub2sgPSBmYWxzZVxuICByZXNwb25zZS5zdGF0dXMgPSAwXG4gIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gIHJldHVybiByZXNwb25zZVxufVxuXG52YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG59XG5cbmV4cG9ydCB2YXIgRE9NRXhjZXB0aW9uID0gZy5ET01FeGNlcHRpb25cbnRyeSB7XG4gIG5ldyBET01FeGNlcHRpb24oKVxufSBjYXRjaCAoZXJyKSB7XG4gIERPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpXG4gICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrXG4gIH1cbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuICBET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRE9NRXhjZXB0aW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgIH1cblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICB4aHIuYWJvcnQoKVxuICAgIH1cblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgY2hlY2sgaWYgc3BlY2lmaWNhbGx5IGZvciB3aGVuIGEgdXNlciBmZXRjaGVzIGEgZmlsZSBsb2NhbGx5IGZyb20gdGhlIGZpbGUgc3lzdGVtXG4gICAgICAvLyBPbmx5IGlmIHRoZSBzdGF0dXMgaXMgb3V0IG9mIGEgbm9ybWFsIHJhbmdlXG4gICAgICBpZiAocmVxdWVzdC51cmwuaW5kZXhPZignZmlsZTovLycpID09PSAwICYmICh4aHIuc3RhdHVzIDwgMjAwIHx8IHhoci5zdGF0dXMgPiA1OTkpKSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0gMjAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCB0aW1lZCBvdXQnKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4VXJsKHVybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVybCA9PT0gJycgJiYgZy5sb2NhdGlvbi5ocmVmID8gZy5sb2NhdGlvbi5ocmVmIDogdXJsXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1cmxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgZml4VXJsKHJlcXVlc3QudXJsKSwgdHJ1ZSlcblxuICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpIHtcbiAgICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgc3VwcG9ydC5hcnJheUJ1ZmZlclxuICAgICAgKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaXQgJiYgdHlwZW9mIGluaXQuaGVhZGVycyA9PT0gJ29iamVjdCcgJiYgIShpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzIHx8IChnLkhlYWRlcnMgJiYgaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgZy5IZWFkZXJzKSkpIHtcbiAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5pdC5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZXMucHVzaChub3JtYWxpemVOYW1lKG5hbWUpKVxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBub3JtYWxpemVWYWx1ZShpbml0LmhlYWRlcnNbbmFtZV0pKVxuICAgICAgfSlcbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsKSB7XG4gICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gIH0pXG59XG5cbmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxuXG5pZiAoIWcuZmV0Y2gpIHtcbiAgZy5mZXRjaCA9IGZldGNoXG4gIGcuSGVhZGVycyA9IEhlYWRlcnNcbiAgZy5SZXF1ZXN0ID0gUmVxdWVzdFxuICBnLlJlc3BvbnNlID0gUmVzcG9uc2Vcbn1cbiIsICJpbXBvcnQgJ3doYXR3Zy1mZXRjaCc7XG5cbmNvbnN0IHZlcnNpb24gPSBcIjAuNS4xMVwiO1xuXG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgUmVzcG9uc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3IsIHN0YXR1c19jb2RlKSB7XG4gICAgc3VwZXIoZXJyb3IpO1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLnN0YXR1c19jb2RlID0gc3RhdHVzX2NvZGU7XG4gICAgdGhpcy5uYW1lID0gXCJSZXNwb25zZUVycm9yXCI7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXNwb25zZUVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFib3J0YWJsZUFzeW5jSXRlcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihhYm9ydENvbnRyb2xsZXIsIGl0ciwgZG9uZUNhbGxiYWNrKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiYWJvcnRDb250cm9sbGVyXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIml0clwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJkb25lQ2FsbGJhY2tcIik7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgdGhpcy5pdHIgPSBpdHI7XG4gICAgdGhpcy5kb25lQ2FsbGJhY2sgPSBkb25lQ2FsbGJhY2s7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IG1lc3NhZ2Ugb2YgdGhpcy5pdHIpIHtcbiAgICAgIGlmIChcImVycm9yXCIgaW4gbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgICB9XG4gICAgICB5aWVsZCBtZXNzYWdlO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9uZSB8fCBtZXNzYWdlLnN0YXR1cyA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgdGhpcy5kb25lQ2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWQgbm90IHJlY2VpdmUgZG9uZSBvciBzdWNjZXNzIHJlc3BvbnNlIGluIHN0cmVhbS5cIik7XG4gIH1cbn1cbmNvbnN0IGNoZWNrT2sgPSBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBtZXNzYWdlID0gYEVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XG4gIGxldCBlcnJvckRhdGEgPSBudWxsO1xuICBpZiAocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik/LmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgIHRyeSB7XG4gICAgICBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBtZXNzYWdlID0gZXJyb3JEYXRhLmVycm9yIHx8IG1lc3NhZ2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIHBhcnNlIGVycm9yIHJlc3BvbnNlIGFzIEpTT05cIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkdldHRpbmcgdGV4dCBmcm9tIHJlc3BvbnNlXCIpO1xuICAgICAgY29uc3QgdGV4dFJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgbWVzc2FnZSA9IHRleHRSZXNwb25zZSB8fCBtZXNzYWdlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBnZXQgdGV4dCBmcm9tIGVycm9yIHJlc3BvbnNlXCIpO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgUmVzcG9uc2VFcnJvcihtZXNzYWdlLCByZXNwb25zZS5zdGF0dXMpO1xufTtcbmZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIGAke3dpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0udG9Mb3dlckNhc2UoKX0gQnJvd3Nlci8ke25hdmlnYXRvci51c2VyQWdlbnR9O2A7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gYCR7cHJvY2Vzcy5hcmNofSAke3Byb2Nlc3MucGxhdGZvcm19IE5vZGUuanMvJHtwcm9jZXNzLnZlcnNpb259YDtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmNvbnN0IGZldGNoV2l0aEhlYWRlcnMgPSBhc3luYyAoZmV0Y2gsIHVybCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGRlZmF1bHRIZWFkZXJzID0ge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgXCJVc2VyLUFnZW50XCI6IGBvbGxhbWEtanMvJHt2ZXJzaW9ufSAoJHtnZXRQbGF0Zm9ybSgpfSlgXG4gIH07XG4gIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgb3B0aW9ucy5oZWFkZXJzID0ge307XG4gIH1cbiAgY29uc3QgY3VzdG9tSGVhZGVycyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhvcHRpb25zLmhlYWRlcnMpLmZpbHRlcigoW2tleV0pID0+ICFPYmplY3Qua2V5cyhkZWZhdWx0SGVhZGVycykuc29tZSgoZGVmYXVsdEtleSkgPT4gZGVmYXVsdEtleS50b0xvd2VyQ2FzZSgpID09PSBrZXkudG9Mb3dlckNhc2UoKSkpXG4gICk7XG4gIG9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAuLi5kZWZhdWx0SGVhZGVycyxcbiAgICAuLi5jdXN0b21IZWFkZXJzXG4gIH07XG4gIHJldHVybiBmZXRjaCh1cmwsIG9wdGlvbnMpO1xufTtcbmNvbnN0IGdldCA9IGFzeW5jIChmZXRjaCwgaG9zdCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aEhlYWRlcnMoZmV0Y2gsIGhvc3QsIHtcbiAgICBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzXG4gIH0pO1xuICBhd2FpdCBjaGVja09rKHJlc3BvbnNlKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbmNvbnN0IGhlYWQgPSBhc3luYyAoZmV0Y2gsIGhvc3QpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhIZWFkZXJzKGZldGNoLCBob3N0LCB7XG4gICAgbWV0aG9kOiBcIkhFQURcIlxuICB9KTtcbiAgYXdhaXQgY2hlY2tPayhyZXNwb25zZSk7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG5jb25zdCBwb3N0ID0gYXN5bmMgKGZldGNoLCBob3N0LCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGlzUmVjb3JkID0gKGlucHV0KSA9PiB7XG4gICAgcmV0dXJuIGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShpbnB1dCk7XG4gIH07XG4gIGNvbnN0IGZvcm1hdHRlZERhdGEgPSBpc1JlY29yZChkYXRhKSA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogZGF0YTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhIZWFkZXJzKGZldGNoLCBob3N0LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBmb3JtYXR0ZWREYXRhLFxuICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsLFxuICAgIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnNcbiAgfSk7XG4gIGF3YWl0IGNoZWNrT2socmVzcG9uc2UpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuY29uc3QgZGVsID0gYXN5bmMgKGZldGNoLCBob3N0LCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoSGVhZGVycyhmZXRjaCwgaG9zdCwge1xuICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzXG4gIH0pO1xuICBhd2FpdCBjaGVja09rKHJlc3BvbnNlKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbmNvbnN0IHBhcnNlSlNPTiA9IGFzeW5jIGZ1bmN0aW9uKiAoaXRyKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIGNvbnN0IHJlYWRlciA9IGl0ci5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlOiBjaHVuayB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJ1ZmZlciArPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgY29uc3QgcGFydHMgPSBidWZmZXIuc3BsaXQoXCJcXG5cIik7XG4gICAgYnVmZmVyID0gcGFydHMucG9wKCkgPz8gXCJcIjtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIEpTT04ucGFyc2UocGFydCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJpbnZhbGlkIGpzb246IFwiLCBwYXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBwYXJ0IG9mIGJ1ZmZlci5zcGxpdChcIlxcblwiKS5maWx0ZXIoKHApID0+IHAgIT09IFwiXCIpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHlpZWxkIEpTT04ucGFyc2UocGFydCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImludmFsaWQganNvbjogXCIsIHBhcnQpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGZvcm1hdEhvc3QgPSAoaG9zdCkgPT4ge1xuICBpZiAoIWhvc3QpIHtcbiAgICByZXR1cm4gXCJodHRwOi8vMTI3LjAuMC4xOjExNDM0XCI7XG4gIH1cbiAgbGV0IGlzRXhwbGljaXRQcm90b2NvbCA9IGhvc3QuaW5jbHVkZXMoXCI6Ly9cIik7XG4gIGlmIChob3N0LnN0YXJ0c1dpdGgoXCI6XCIpKSB7XG4gICAgaG9zdCA9IGBodHRwOi8vMTI3LjAuMC4xJHtob3N0fWA7XG4gICAgaXNFeHBsaWNpdFByb3RvY29sID0gdHJ1ZTtcbiAgfVxuICBpZiAoIWlzRXhwbGljaXRQcm90b2NvbCkge1xuICAgIGhvc3QgPSBgaHR0cDovLyR7aG9zdH1gO1xuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoaG9zdCk7XG4gIGxldCBwb3J0ID0gdXJsLnBvcnQ7XG4gIGlmICghcG9ydCkge1xuICAgIGlmICghaXNFeHBsaWNpdFByb3RvY29sKSB7XG4gICAgICBwb3J0ID0gXCIxMTQzNFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3J0ID0gdXJsLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCI0NDNcIiA6IFwiODBcIjtcbiAgICB9XG4gIH1cbiAgbGV0IGZvcm1hdHRlZEhvc3QgPSBgJHt1cmwucHJvdG9jb2x9Ly8ke3VybC5ob3N0bmFtZX06JHtwb3J0fSR7dXJsLnBhdGhuYW1lfWA7XG4gIGlmIChmb3JtYXR0ZWRIb3N0LmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIGZvcm1hdHRlZEhvc3QgPSBmb3JtYXR0ZWRIb3N0LnNsaWNlKDAsIC0xKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVkSG9zdDtcbn07XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmxldCBPbGxhbWEkMSA9IGNsYXNzIE9sbGFtYSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb25maWdcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZldGNoXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvbmdvaW5nU3RyZWFtZWRSZXF1ZXN0c1wiLCBbXSk7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBob3N0OiBcIlwiLFxuICAgICAgaGVhZGVyczogY29uZmlnPy5oZWFkZXJzXG4gICAgfTtcbiAgICBpZiAoIWNvbmZpZz8ucHJveHkpIHtcbiAgICAgIHRoaXMuY29uZmlnLmhvc3QgPSBmb3JtYXRIb3N0KGNvbmZpZz8uaG9zdCA/PyBcImh0dHA6Ly8xMjcuMC4wLjE6MTE0MzRcIik7XG4gICAgfVxuICAgIHRoaXMuZmV0Y2ggPSBjb25maWc/LmZldGNoID8/IGZldGNoO1xuICB9XG4gIC8vIEFib3J0IGFueSBvbmdvaW5nIHN0cmVhbWVkIHJlcXVlc3RzIHRvIE9sbGFtYVxuICBhYm9ydCgpIHtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIHJlcXVlc3QgdG8gdGhlIE9sbGFtYSBzZXJ2ZXIuIElmIHRoZSByZXF1ZXN0IGlzIHN0cmVhbWFibGUsIGl0IHdpbGwgcmV0dXJuIGFcbiAgICogQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyB0aGUgcmVzcG9uc2UgbWVzc2FnZXMuIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIHJlc3BvbnNlXG4gICAqIG9iamVjdC5cbiAgICogQHBhcmFtIGVuZHBvaW50IHtzdHJpbmd9IC0gVGhlIGVuZHBvaW50IHRvIHNlbmQgdGhlIHJlcXVlc3QgdG8uXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtvYmplY3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0IHRvIHNlbmQgdG8gdGhlIGVuZHBvaW50LlxuICAgKiBAcHJvdGVjdGVkIHtUIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxUPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGEgQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkc1xuICAgKiByZXNwb25zZSBtZXNzYWdlcy5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZyBvciBpZiB0aGUgcmVzcG9uc2UgaXMgYW4gZXJyb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFQgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFQ+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGEgQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyB0aGUgc3RyZWFtZWQgcmVzcG9uc2UuXG4gICAqL1xuICBhc3luYyBwcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoZW5kcG9pbnQsIHJlcXVlc3QpIHtcbiAgICByZXF1ZXN0LnN0cmVhbSA9IHJlcXVlc3Quc3RyZWFtID8/IGZhbHNlO1xuICAgIGNvbnN0IGhvc3QgPSBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvJHtlbmRwb2ludH1gO1xuICAgIGlmIChyZXF1ZXN0LnN0cmVhbSkge1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBob3N0LCByZXF1ZXN0LCB7XG4gICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlMi5ib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYm9keVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ciA9IHBhcnNlSlNPTihyZXNwb25zZTIuYm9keSk7XG4gICAgICBjb25zdCBhYm9ydGFibGVBc3luY0l0ZXJhdG9yID0gbmV3IEFib3J0YWJsZUFzeW5jSXRlcmF0b3IoXG4gICAgICAgIGFib3J0Q29udHJvbGxlcixcbiAgICAgICAgaXRyLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMuaW5kZXhPZihhYm9ydGFibGVBc3luY0l0ZXJhdG9yKTtcbiAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzLnB1c2goYWJvcnRhYmxlQXN5bmNJdGVyYXRvcik7XG4gICAgICByZXR1cm4gYWJvcnRhYmxlQXN5bmNJdGVyYXRvcjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGhvc3QsIHJlcXVlc3QsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAqIEVuY29kZXMgYW4gaW1hZ2UgdG8gYmFzZTY0IGlmIGl0IGlzIGEgVWludDhBcnJheS5cbiAgKiBAcGFyYW0gaW1hZ2Uge1VpbnQ4QXJyYXkgfCBzdHJpbmd9IC0gVGhlIGltYWdlIHRvIGVuY29kZS5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIFRoZSBiYXNlNjQgZW5jb2RlZCBpbWFnZS5cbiAgKi9cbiAgYXN5bmMgZW5jb2RlSW1hZ2UoaW1hZ2UpIHtcbiAgICBpZiAodHlwZW9mIGltYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaW1hZ2UpO1xuICAgICAgbGV0IGJ5dGVTdHJpbmcgPSBcIlwiO1xuICAgICAgY29uc3QgbGVuID0gdWludDhBcnJheS5ieXRlTGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBieXRlU3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhBcnJheVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnRvYShieXRlU3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSByZXNwb25zZSBmcm9tIGEgdGV4dCBwcm9tcHQuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtHZW5lcmF0ZVJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZW5lcmF0ZVJlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxHZW5lcmF0ZVJlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvclxuICAgKiBhbiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGUocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0LmltYWdlcykge1xuICAgICAgcmVxdWVzdC5pbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0LmltYWdlcy5tYXAodGhpcy5lbmNvZGVJbWFnZS5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcImdlbmVyYXRlXCIsIHJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBDaGF0cyB3aXRoIHRoZSBtb2RlbC4gVGhlIHJlcXVlc3Qgb2JqZWN0IGNhbiBjb250YWluIG1lc3NhZ2VzIHdpdGggaW1hZ2VzIHRoYXQgYXJlIGVpdGhlclxuICAgKiBVaW50OEFycmF5cyBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzLiBUaGUgaW1hZ2VzIHdpbGwgYmUgYmFzZTY0IGVuY29kZWQgYmVmb3JlIHNlbmRpbmcgdGhlXG4gICAqIHJlcXVlc3QuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtDaGF0UmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENoYXRSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8Q2hhdFJlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvciBhblxuICAgKiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgY2hhdChyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QubWVzc2FnZXMpIHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiByZXF1ZXN0Lm1lc3NhZ2VzKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmltYWdlcykge1xuICAgICAgICAgIG1lc3NhZ2UuaW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBtZXNzYWdlLmltYWdlcy5tYXAodGhpcy5lbmNvZGVJbWFnZS5iaW5kKHRoaXMpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwiY2hhdFwiLCByZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBtb2RlbCBmcm9tIGEgc3RyZWFtIG9mIGRhdGEuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtDcmVhdGVSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8UHJvZ3Jlc3NSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8UHJvZ3Jlc3NSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYSBzdHJlYW0gb2YgcHJvZ3Jlc3MgcmVzcG9uc2VzLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJjcmVhdGVcIiwge1xuICAgICAgbmFtZTogcmVxdWVzdC5tb2RlbCxcbiAgICAgIHN0cmVhbTogcmVxdWVzdC5zdHJlYW0sXG4gICAgICBtb2RlbGZpbGU6IHJlcXVlc3QubW9kZWxmaWxlLFxuICAgICAgcXVhbnRpemU6IHJlcXVlc3QucXVhbnRpemVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHVsbHMgYSBtb2RlbCBmcm9tIHRoZSBPbGxhbWEgcmVnaXN0cnkuIFRoZSByZXF1ZXN0IG9iamVjdCBjYW4gY29udGFpbiBhIHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIGlmIHRoZVxuICAgKiByZXNwb25zZSBzaG91bGQgYmUgc3RyZWFtZWQuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtQdWxsUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFByb2dyZXNzUmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFByb2dyZXNzUmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yXG4gICAqIGFuIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgcmVzcG9uc2UgbWVzc2FnZXMuXG4gICAqL1xuICBhc3luYyBwdWxsKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJwdWxsXCIsIHtcbiAgICAgIG5hbWU6IHJlcXVlc3QubW9kZWwsXG4gICAgICBzdHJlYW06IHJlcXVlc3Quc3RyZWFtLFxuICAgICAgaW5zZWN1cmU6IHJlcXVlc3QuaW5zZWN1cmVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHVzaGVzIGEgbW9kZWwgdG8gdGhlIE9sbGFtYSByZWdpc3RyeS4gVGhlIHJlcXVlc3Qgb2JqZWN0IGNhbiBjb250YWluIGEgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlXG4gICAqIHJlc3BvbnNlIHNob3VsZCBiZSBzdHJlYW1lZC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge1B1c2hSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8UHJvZ3Jlc3NSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8UHJvZ3Jlc3NSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3JcbiAgICogYW4gQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIHB1c2gocmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcInB1c2hcIiwge1xuICAgICAgbmFtZTogcmVxdWVzdC5tb2RlbCxcbiAgICAgIHN0cmVhbTogcmVxdWVzdC5zdHJlYW0sXG4gICAgICBpbnNlY3VyZTogcmVxdWVzdC5pbnNlY3VyZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbW9kZWwgZnJvbSB0aGUgc2VydmVyLiBUaGUgcmVxdWVzdCBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRvXG4gICAqIGRlbGV0ZS5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0RlbGV0ZVJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdGF0dXNSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZShyZXF1ZXN0KSB7XG4gICAgYXdhaXQgZGVsKFxuICAgICAgdGhpcy5mZXRjaCxcbiAgICAgIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9kZWxldGVgLFxuICAgICAgeyBuYW1lOiByZXF1ZXN0Lm1vZGVsIH0sXG4gICAgICB7IGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnMgfVxuICAgICk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9O1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYSBtb2RlbCBmcm9tIG9uZSBuYW1lIHRvIGFub3RoZXIuIFRoZSByZXF1ZXN0IG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgbmFtZSBvZiB0aGVcbiAgICogbW9kZWwgdG8gY29weSBhbmQgdGhlIG5ldyBuYW1lLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7Q29weVJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdGF0dXNSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGNvcHkocmVxdWVzdCkge1xuICAgIGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2NvcHlgLCB7IC4uLnJlcXVlc3QgfSwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIgfTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgdGhlIG1vZGVscyBvbiB0aGUgc2VydmVyLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMaXN0UmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIHRoZSByZXNwb25zZSBib2R5IGlzIG1pc3NpbmcuXG4gICAqL1xuICBhc3luYyBsaXN0KCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS90YWdzYCwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBtZXRhZGF0YSBvZiBhIG1vZGVsLiBUaGUgcmVxdWVzdCBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG5hbWUgb2YgdGhlIG1vZGVsLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7U2hvd1JlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaG93UmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBzaG93KHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL3Nob3dgLCB7XG4gICAgICAuLi5yZXF1ZXN0XG4gICAgfSwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVtYmVkcyB0ZXh0IGlucHV0IGludG8gdmVjdG9ycy5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0VtYmVkUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEVtYmVkUmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBlbWJlZChyZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9lbWJlZGAsIHtcbiAgICAgIC4uLnJlcXVlc3RcbiAgICB9LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRW1iZWRzIGEgdGV4dCBwcm9tcHQgaW50byBhIHZlY3Rvci5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0VtYmVkZGluZ3NSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8RW1iZWRkaW5nc1Jlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgZW1iZWRkaW5ncyhyZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9lbWJlZGRpbmdzYCwge1xuICAgICAgLi4ucmVxdWVzdFxuICAgIH0sIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgcnVubmluZyBtb2RlbHMgb24gdGhlIHNlcnZlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMaXN0UmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIHRoZSByZXNwb25zZSBib2R5IGlzIG1pc3NpbmcuXG4gICAqL1xuICBhc3luYyBwcygpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvcHNgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxufTtcbmNvbnN0IGJyb3dzZXIgPSBuZXcgT2xsYW1hJDEoKTtcblxuZXhwb3J0IHsgT2xsYW1hJDEgYXMgTywgYnJvd3NlciBhcyBiLCBoZWFkIGFzIGgsIHBvc3QgYXMgcCB9O1xuIiwgImltcG9ydCB7IE8gYXMgT2xsYW1hJDEsIGggYXMgaGVhZCwgcCBhcyBwb3N0IH0gZnJvbSAnLi9zaGFyZWQvb2xsYW1hLmNkZGJjODViLm1qcyc7XG5pbXBvcnQgZnMsIHsgcHJvbWlzZXMsIGNyZWF0ZVJlYWRTdHJlYW0gfSBmcm9tICdmcyc7XG5pbXBvcnQgeyByZXNvbHZlLCBqb2luLCBkaXJuYW1lIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IGhvbWVkaXIgfSBmcm9tICdvcyc7XG5pbXBvcnQgJ3doYXR3Zy1mZXRjaCc7XG5cbmNsYXNzIE9sbGFtYSBleHRlbmRzIE9sbGFtYSQxIHtcbiAgYXN5bmMgZW5jb2RlSW1hZ2UoaW1hZ2UpIHtcbiAgICBpZiAodHlwZW9mIGltYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oaW1hZ2UpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoaW1hZ2UpKSB7XG4gICAgICAgIGNvbnN0IGZpbGVCdWZmZXIgPSBhd2FpdCBwcm9taXNlcy5yZWFkRmlsZShyZXNvbHZlKGltYWdlKSk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShmaWxlQnVmZmVyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbW9kZWxmaWxlIGFuZCByZXBsYWNlIHRoZSBGUk9NIGFuZCBBREFQVEVSIGNvbW1hbmRzIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgYmxvYiBoYXNoZXMuXG4gICAqIEBwYXJhbSBtb2RlbGZpbGUge3N0cmluZ30gLSBUaGUgbW9kZWxmaWxlIGNvbnRlbnRcbiAgICogQHBhcmFtIG1mRGlyIHtzdHJpbmd9IC0gVGhlIGRpcmVjdG9yeSBvZiB0aGUgbW9kZWxmaWxlXG4gICAqIEBwcml2YXRlIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgcGFyc2VNb2RlbGZpbGUobW9kZWxmaWxlLCBtZkRpciA9IHByb2Nlc3MuY3dkKCkpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBjb25zdCBsaW5lcyA9IG1vZGVsZmlsZS5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGNvbnN0IFtjb21tYW5kLCBhcmdzXSA9IGxpbmUuc3BsaXQoXCIgXCIsIDIpO1xuICAgICAgaWYgKFtcIkZST01cIiwgXCJBREFQVEVSXCJdLmluY2x1ZGVzKGNvbW1hbmQudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMucmVzb2x2ZVBhdGgoYXJncy50cmltKCksIG1mRGlyKTtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuZmlsZUV4aXN0cyhwYXRoKSkge1xuICAgICAgICAgIG91dC5wdXNoKGAke2NvbW1hbmR9IEAke2F3YWl0IHRoaXMuY3JlYXRlQmxvYihwYXRoKX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQucHVzaChgJHtjb21tYW5kfSAke2FyZ3N9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dC5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0LmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmUgdGhlIHBhdGggdG8gYW4gYWJzb2x1dGUgcGF0aC5cbiAgICogQHBhcmFtIGlucHV0UGF0aCB7c3RyaW5nfSAtIFRoZSBpbnB1dCBwYXRoXG4gICAqIEBwYXJhbSBtZkRpciB7c3RyaW5nfSAtIFRoZSBkaXJlY3Rvcnkgb2YgdGhlIG1vZGVsZmlsZVxuICAgKiBAcHJpdmF0ZSBAaW50ZXJuYWxcbiAgICovXG4gIHJlc29sdmVQYXRoKGlucHV0UGF0aCwgbWZEaXIpIHtcbiAgICBpZiAoaW5wdXRQYXRoLnN0YXJ0c1dpdGgoXCJ+XCIpKSB7XG4gICAgICByZXR1cm4gam9pbihob21lZGlyKCksIGlucHV0UGF0aC5zbGljZSgxKSk7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlKG1mRGlyLCBpbnB1dFBhdGgpO1xuICB9XG4gIC8qKlxuICAgKiBjaGVja3MgaWYgYSBmaWxlIGV4aXN0c1xuICAgKiBAcGFyYW0gcGF0aCB7c3RyaW5nfSAtIFRoZSBwYXRoIHRvIHRoZSBmaWxlXG4gICAqIEBwcml2YXRlIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gLSBXaGV0aGVyIHRoZSBmaWxlIGV4aXN0cyBvciBub3RcbiAgICovXG4gIGFzeW5jIGZpbGVFeGlzdHMocGF0aCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm9taXNlcy5hY2Nlc3MocGF0aCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlQmxvYihwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtaW5nIHVwbG9hZHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVTdHJlYW0gPSBjcmVhdGVSZWFkU3RyZWFtKHBhdGgpO1xuICAgIGNvbnN0IHNoYTI1NnN1bSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlMiwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBoYXNoID0gY3JlYXRlSGFzaChcInNoYTI1NlwiKTtcbiAgICAgIGZpbGVTdHJlYW0ub24oXCJkYXRhXCIsIChkYXRhKSA9PiBoYXNoLnVwZGF0ZShkYXRhKSk7XG4gICAgICBmaWxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHJlc29sdmUyKGhhc2guZGlnZXN0KFwiaGV4XCIpKSk7XG4gICAgICBmaWxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICB9KTtcbiAgICBjb25zdCBkaWdlc3QgPSBgc2hhMjU2OiR7c2hhMjU2c3VtfWA7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGhlYWQodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2Jsb2JzLyR7ZGlnZXN0fWApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmluY2x1ZGVzKFwiNDA0XCIpKSB7XG4gICAgICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBmaWxlU3RyZWFtLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmlsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmlsZVN0cmVhbS5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcG9zdChcbiAgICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICAgIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9ibG9icy8ke2RpZ2VzdH1gLFxuICAgICAgICAgIHJlYWRhYmxlU3RyZWFtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlnZXN0O1xuICB9XG4gIGFzeW5jIGNyZWF0ZShyZXF1ZXN0KSB7XG4gICAgbGV0IG1vZGVsZmlsZUNvbnRlbnQgPSBcIlwiO1xuICAgIGlmIChyZXF1ZXN0LnBhdGgpIHtcbiAgICAgIG1vZGVsZmlsZUNvbnRlbnQgPSBhd2FpdCBwcm9taXNlcy5yZWFkRmlsZShyZXF1ZXN0LnBhdGgsIHsgZW5jb2Rpbmc6IFwidXRmOFwiIH0pO1xuICAgICAgbW9kZWxmaWxlQ29udGVudCA9IGF3YWl0IHRoaXMucGFyc2VNb2RlbGZpbGUoXG4gICAgICAgIG1vZGVsZmlsZUNvbnRlbnQsXG4gICAgICAgIGRpcm5hbWUocmVxdWVzdC5wYXRoKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QubW9kZWxmaWxlKSB7XG4gICAgICBtb2RlbGZpbGVDb250ZW50ID0gYXdhaXQgdGhpcy5wYXJzZU1vZGVsZmlsZShyZXF1ZXN0Lm1vZGVsZmlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcGF0aCBvciBtb2RlbGZpbGUgdG8gY3JlYXRlIGEgbW9kZWxcIik7XG4gICAgfVxuICAgIHJlcXVlc3QubW9kZWxmaWxlID0gbW9kZWxmaWxlQ29udGVudDtcbiAgICBpZiAocmVxdWVzdC5zdHJlYW0pIHtcbiAgICAgIHJldHVybiBzdXBlci5jcmVhdGUocmVxdWVzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5jcmVhdGUocmVxdWVzdCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBpbmRleCA9IG5ldyBPbGxhbWEoKTtcblxuZXhwb3J0IHsgT2xsYW1hLCBpbmRleCBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IEluc2NyaWJlIGZyb20gXCJzcmMvbWFpblwiO1xuaW1wb3J0IHsgQ29tcGxldGVyLCBJbnRlZ3JhdGlvbiwgUHJvdmlkZXIgfSBmcm9tIFwiLi5cIjtcbmltcG9ydCB7IFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IE9wZW5BSVNldHRpbmdzIH0gZnJvbSBcIi5cIjtcblxuZXhwb3J0IGNsYXNzIE9wZW5BSVByb3ZpZGVyIGltcGxlbWVudHMgUHJvdmlkZXIge1xuICAgIGludGVncmF0aW9uOiBJbnRlZ3JhdGlvbiA9IEludGVncmF0aW9uLk9QRU5BSTtcbiAgICBuYW1lOiBzdHJpbmcgPSBcIk9wZW4gQUlcIjtcbiAgICBkZXNjcmlwdGlvbjogXCJPcGVuQUkgdGhlIGV2aWxlc3QgY29tcGFueSBpbiB0aGUgd29ybGRcIjtcbiAgICBzZXR0aW5nczogT3BlbkFJU2V0dGluZ3NcbiAgICBjb21wbGV0ZXI6IENvbXBsZXRlcjtcbiAgICBtb2RlbHM6IHN0cmluZ1tdO1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzOiBPcGVuQUlTZXR0aW5ncykge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfVxuICAgIGxvYWRDb21wbGV0ZXI6ICgpID0+IFByb21pc2U8dm9pZD4gPSBhc3luYyAoKSA9PiB7IH07XG4gICAgZGlzcGxheVNldHRpbmdzKHBsdWdpbjogSW5zY3JpYmUsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJPcGVuQUkgU2V0dGluZ3NcIiB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQVBJIEtleVwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJFbnRlciB0aGUgT3BlbkFJIEFQSSBrZXkuXCIpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcih0aGlzLnNldHRpbmdzLmFwaUtleSlcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuc2V0dGluZ3MuYXBpS2V5KVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmFwaUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIk1vZGVsXCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkNob29zZSB0aGUgT3BlbkFJIG1vZGVsLlwiKVxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKChkcm9wZG93bikgPT4ge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oXCJncHQtNFwiLCBcIkdQVC00XCIpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oXCJkYXZpbmNpXCIsIFwiRGF2aW5jaVwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5tb2RlbClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5tb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGF2YWlsYWJsZU1vZGVscygpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiBbXCJncHQtNFwiLCBcImRhdmluY2lcIl07XG4gICAgfVxufSIsICJpbXBvcnQgeyBTZXR0aW5ncyB9IGZyb20gXCJzcmMvc2V0dGluZ3Mvc2V0dGluZ3NcIjtcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXJcIjtcbmltcG9ydCB7IE9sbGFtYVByb3ZpZGVyIH0gZnJvbSBcIi4vb2xsYW1hXCI7XG5pbXBvcnQgeyBPcGVuQUlQcm92aWRlciB9IGZyb20gXCIuL29wZW5haS9wcm92aWRlclwiO1xuXG5leHBvcnQgKiBmcm9tIFwiLi9wcm92aWRlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vY29tcGxldGVyXCI7XG5cbmV4cG9ydCBlbnVtIEludGVncmF0aW9uIHtcbiAgICBPTExBTUEgPSBcIm9sbGFtYVwiLFxuICAgIE9QRU5BSSA9IFwib3BlbmFpXCIsXG59XG5cbi8vIGJ1aWxkZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGVyc1xuZXhwb3J0IGNvbnN0IGJ1aWxkUHJvdmlkZXJzID0gKHNldHRpbmdzOiBTZXR0aW5ncyk6IFByb3ZpZGVyW10gPT4ge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBPbGxhbWFQcm92aWRlcihzZXR0aW5ncy5wcm92aWRlcnMub2xsYW1hKSxcbiAgICAgICAgbmV3IE9wZW5BSVByb3ZpZGVyKHNldHRpbmdzLnByb3ZpZGVycy5vcGVuYWkpLFxuICAgIF07XG59XG5cbi8vIGJ1aWxkZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGVyXG5leHBvcnQgY29uc3QgY3JlYXRlUHJvdmlkZXIgPSAoc2V0dGluZ3M6IFNldHRpbmdzKTogUHJvdmlkZXIgPT4ge1xuICAgIHN3aXRjaCAoc2V0dGluZ3MucHJvdmlkZXIpIHtcbiAgICAgICAgY2FzZSBJbnRlZ3JhdGlvbi5PTExBTUE6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9sbGFtYVByb3ZpZGVyKHNldHRpbmdzLnByb3ZpZGVycy5vbGxhbWEpO1xuICAgICAgICBjYXNlIEludGVncmF0aW9uLk9QRU5BSTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3BlbkFJUHJvdmlkZXIoc2V0dGluZ3MucHJvdmlkZXJzLm9wZW5haSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3ZpZGVyXCIpO1xuICAgIH1cbn1cblxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxtQkFBK0I7Ozs7Ozs7QUM0Q3hCLFNBQVNDLEVBQ2RDLEdBQ0FDLEdBQ0FDLElBQWtCLFFBSWxCO0FBQ0EsUUFBTUMsS0FBUTtJQUNaLE9B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QVUsTUFBTTtBQUM5QixXQUFPLEtBQUssU0FBUyxVQUFVLFNBQVMsY0FBYyxXQUFXO0FBQUEsRUFDbEU7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNwQixTQUFLLFdBQVcsT0FBTztBQUFBLE1BQ3RCLENBQUM7QUFBQSxNQUNEO0FBQUEsTUFDQSxNQUFNLEtBQUssU0FBUztBQUFBLElBQ3JCO0FBQUEsRUFDRDtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUNqQyxVQUFNLEtBQUssZUFBZTtBQUMxQixZQUFRLElBQUksS0FBSyxTQUFTLFVBQVUsT0FBTyxXQUFXO0FBQUEsRUFDdkQ7QUFDRDsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgImRlYm91bmNlQXN5bmNHZW5lcmF0b3IiLCAiZm4iLCAid2FpdCIsICJhYm9ydFZhbHVlIiwgImZvcmNlIiwgInRpbWVyIiwgIndyYXBGdW5jIiwgImFyZ3MiLCAib3duX3RpbWVyIiwgInJlc29sdmUiLCAiZSIsICJpdGVtIiwgIklubGluZVN1Z2dlc3Rpb25TdGF0ZSIsICJTdGF0ZUZpZWxkIiwgIl9fIiwgInRyIiwgImlubGluZVN1Z2dlc3Rpb24iLCAiZSIsICJJbmxpbmVTdWdnZXN0aW9uRWZmZWN0IiwgIlN0YXRlRWZmZWN0IiwgImlubGluZVN1Z2dlc3Rpb25EZWNvcmF0aW9uIiwgInZpZXciLCAicHJlZml4IiwgInBvcyIsICJ3aWRnZXRzIiwgInciLCAiRGVjb3JhdGlvbiIsICJJbmxpbmVTdWdnZXN0aW9uV2lkZ2V0IiwgIldpZGdldFR5cGUiLCAic3VnZ2VzdGlvbiIsICJfX3B1YmxpY0ZpZWxkIiwgImRpdiIsICJmZXRjaFN1Z2dlc3Rpb24iLCAiZmV0Y2hGbiIsICJzdWdnZXN0aW9uSWQiLCAiVmlld1BsdWdpbiIsICJ1cGRhdGUiLCAiZG9jIiwgImN1cnJlbnRTdWdnZXN0aW9uSWQiLCAicmVzdWx0IiwgIlJlbmRlclBsdWdpbiIsICJfYSIsICJyZW5kZXJJbmxpbmVTdWdnZXN0aW9uUGx1Z2luIiwgInYiLCAiaW5saW5lU3VnZ2VzdGlvbktleW1hcCIsICJzdWdnZXN0Rm4iLCAiYWNjZXB0X3Nob3J0Y3V0IiwgImluc2VydENvbXBsZXRpb25UZXh0IiwgIl9iIiwgImNvbXBsZXRpb25JZCIsICJQcmVjIiwgImtleW1hcCIsICJzdGF0ZSIsICJ0ZXh0IiwgImZyb20iLCAidG8iLCAicmFuZ2UiLCAiRWRpdG9yU2VsZWN0aW9uIiwgImxlbiIsICJ0b1N1Z2dlc3Rpb24iLCAidG9TdWdnZXN0aW9uRm4iLCAib3B0aW9ucyIsICJkZWxheSIsICJkZWJvdW5jZWRfZmV0Y2hGbiIsICJkZWJvdW5jZUFzeW5jR2VuZXJhdG9yIiwgImltcG9ydF9vYnNpZGlhbiIsICJnIiwgInJlc29sdmUiLCAiZmV0Y2giLCAiZmV0Y2giLCAicCIsICJfX2RlZlByb3AiLCAiT2xsYW1hIiwgImZzIiwgIk9sbGFtYSIsICJpbXBvcnRfb2JzaWRpYW4iXQp9Cg==
