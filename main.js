/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Inscribe
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// node_modules/codemirror-companion-extension/dist/extension.js
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");

// node_modules/codemirror-companion-extension/dist/lib/utils.js
function a(n, i, t = void 0) {
  const c2 = {
    force: () => {
    }
  };
  let e = null;
  async function* f(...u2) {
    e && clearTimeout(e);
    let r2 = null;
    try {
      await new Promise((o) => {
        r2 = e = setTimeout(() => o(), i), c2.force = () => {
          e && clearTimeout(e), o();
        };
      });
    } catch (e2) {
      if (t !== void 0)
        throw t;
    }
    for await (const o of n(...u2)) {
      if (r2 !== e)
        break;
      yield o;
    }
  }
  return { debounced: f, force: () => c2.force() };
}

// node_modules/codemirror-companion-extension/dist/extension.js
var F = Object.defineProperty;
var I = (n, t, e) => t in n ? F(n, t, { enumerable: true, configurable: true, writable: true, value: e }) : n[t] = e;
var c = (n, t, e) => (I(n, typeof t != "symbol" ? t + "" : t, e), e);
var r = import_state.StateField.define({
  create() {
    return { suggestion: null };
  },
  update(n, t) {
    const e = t.effects.find(
      (s) => s.is(d)
    );
    return t.state.doc && e && (e.value.doc == null || t.state.doc == e.value.doc) ? { suggestion: e.value.suggestion } : { suggestion: null };
  }
});
var d = import_state.StateEffect.define();
function E(n, t) {
  const e = n.state.selection.main.head, s = [], o = import_view.Decoration.widget({
    widget: new P(t),
    side: 1
  });
  return s.push(o.range(e)), import_view.Decoration.set(s);
}
var P = class extends import_view.WidgetType {
  constructor(e) {
    super();
    c(this, "suggestion");
    this.suggestion = e;
  }
  toDOM() {
    const e = document.createElement("span");
    return e.style.opacity = "0.4", e.className = "cm-inline-suggestion", e.textContent = this.suggestion, e;
  }
};
var g = (n) => {
  let t = 0;
  return import_view.ViewPlugin.fromClass(
    class {
      async update(s) {
        const o = s.state.doc;
        if (!s.docChanged)
          return;
        const i = ++t;
        for await (const a2 of n(s.state)) {
          if (i != t)
            return;
          s.view.dispatch({
            effects: d.of({
              suggestion: a2,
              doc: o
            })
          });
        }
      }
    }
  );
};
var T = class {
  constructor() {
    c(this, "decorations");
    this.decorations = import_view.Decoration.none;
  }
  update(t) {
    var s;
    const e = (s = t.state.field(
      r
    )) == null ? void 0 : s.suggestion;
    if (!e) {
      this.decorations = import_view.Decoration.none;
      return;
    }
    this.decorations = E(
      t.view,
      e.display_suggestion
    );
  }
};
var l = import_view.ViewPlugin.fromClass(T, {
  decorations: (n) => n.decorations
});
var _ = class {
  constructor(t, e) {
    c(this, "suggestFn");
    c(this, "keymap");
    c(this, "completionId");
    c(this, "run", (t2) => {
      var o, i;
      const e2 = (o = t2.state.field(
        r
      )) == null ? void 0 : o.suggestion;
      return e2 ? (t2.dispatch({
        ...x(
          t2.state,
          e2.complete_suggestion,
          t2.state.selection.main.head,
          t2.state.selection.main.head
        )
      }), (i = e2.accept_hook) == null || i.call(e2), (async () => {
        if (this.suggestFn == null)
          return;
        const a2 = ++this.completionId;
        for await (const f of this.suggestFn(t2.state)) {
          if (a2 != this.completionId)
            return;
          t2.dispatch({
            effects: d.of({
              suggestion: {
                complete_suggestion: f.complete_suggestion,
                display_suggestion: f.display_suggestion,
                accept_hook: f.accept_hook
              },
              doc: null
            })
          });
        }
      })(), true) : false;
    });
    this.suggestFn = t, this.keymap = import_state.Prec.highest(
      import_view.keymap.of([
        {
          key: e,
          run: (s) => this.run(s)
        }
      ])
    ), this.completionId = 0;
  }
};
function x(n, t, e, s) {
  return {
    ...n.changeByRange((o) => {
      if (o == n.selection.main)
        return {
          changes: { from: e, to: s, insert: t },
          range: import_state.EditorSelection.cursor(e + t.length)
        };
      const i = s - e;
      return !o.empty || i && n.sliceDoc(o.from - i, o.from) != n.sliceDoc(e, s) ? { range: o } : {
        changes: { from: o.from - i, to: o.from, insert: t },
        range: import_state.EditorSelection.cursor(o.from - i + t.length)
      };
    }),
    userEvent: "input.complete"
  };
}
function p(n) {
  return typeof n == "string" ? {
    complete_suggestion: n,
    display_suggestion: n
  } : n;
}
function S(n) {
  return async function* (t) {
    const e = await n(t);
    if (typeof e == "string" || "complete_suggestion" in e) {
      yield p(e);
      return;
    }
    for await (const s of e)
      yield p(s);
  };
}
function G(n) {
  const { delay: t = 500, accept_shortcut: e = "Tab" } = n, s = S(n.fetchFn), { debounced: o } = a(
    s,
    t
  );
  return e ? [
    r,
    g(o),
    l,
    new _(
      n.continue_suggesting ? s : null,
      e
    ).keymap
  ] : [
    r,
    g(o),
    l
  ];
}

// src/providers/provider.ts
var PROVIDERS = [
  {
    id: "ollama" /* OLLAMA */,
    name: "Ollama"
  },
  {
    id: "openai" /* OPENAI */,
    name: "Open AI"
  }
];

// node_modules/whatwg-fetch/fetch.js
var g2 = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g2,
  iterable: "Symbol" in g2 && "iterator" in Symbol,
  blob: "FileReader" in g2 && "Blob" in g2 && function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: "FormData" in g2,
  arrayBuffer: "ArrayBuffer" in g2
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve2, reject) {
    reader.onload = function() {
      resolve2(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g2) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};
Response.error = function() {
  var response = new Response(null, { status: 200, statusText: "" });
  response.ok = false;
  response.status = 0;
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response(null, { status, headers: { location: url } });
};
var DOMException = g2.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch2(input, init) {
  return new Promise(function(resolve2, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve2(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g2.location.href ? g2.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g2.Headers && init.headers instanceof g2.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch2.polyfill = true;
if (!g2.fetch) {
  g2.fetch = fetch2;
  g2.Headers = Headers;
  g2.Request = Request;
  g2.Response = Response;
}

// node_modules/ollama/dist/shared/ollama.cddbc85b.mjs
var version = "0.5.11";
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ResponseError = class extends Error {
  constructor(error, status_code) {
    super(error);
    this.error = error;
    this.status_code = status_code;
    this.name = "ResponseError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ResponseError);
    }
  }
};
var AbortableAsyncIterator = class {
  constructor(abortController, itr, doneCallback) {
    __publicField$1(this, "abortController");
    __publicField$1(this, "itr");
    __publicField$1(this, "doneCallback");
    this.abortController = abortController;
    this.itr = itr;
    this.doneCallback = doneCallback;
  }
  abort() {
    this.abortController.abort();
  }
  async *[Symbol.asyncIterator]() {
    for await (const message of this.itr) {
      if ("error" in message) {
        throw new Error(message.error);
      }
      yield message;
      if (message.done || message.status === "success") {
        this.doneCallback();
        return;
      }
    }
    throw new Error("Did not receive done or success response in stream.");
  }
};
var checkOk = async (response) => {
  var _a;
  if (response.ok) {
    return;
  }
  let message = `Error ${response.status}: ${response.statusText}`;
  let errorData = null;
  if ((_a = response.headers.get("content-type")) == null ? void 0 : _a.includes("application/json")) {
    try {
      errorData = await response.json();
      message = errorData.error || message;
    } catch (error) {
      console.log("Failed to parse error response as JSON");
    }
  } else {
    try {
      console.log("Getting text from response");
      const textResponse = await response.text();
      message = textResponse || message;
    } catch (error) {
      console.log("Failed to get text from error response");
    }
  }
  throw new ResponseError(message, response.status);
};
function getPlatform() {
  if (typeof window !== "undefined" && window.navigator) {
    return `${window.navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;
  } else if (typeof process !== "undefined") {
    return `${process.arch} ${process.platform} Node.js/${process.version}`;
  }
  return "";
}
var fetchWithHeaders = async (fetch3, url, options = {}) => {
  const defaultHeaders = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "User-Agent": `ollama-js/${version} (${getPlatform()})`
  };
  if (!options.headers) {
    options.headers = {};
  }
  const customHeaders = Object.fromEntries(
    Object.entries(options.headers).filter(([key]) => !Object.keys(defaultHeaders).some((defaultKey) => defaultKey.toLowerCase() === key.toLowerCase()))
  );
  options.headers = {
    ...defaultHeaders,
    ...customHeaders
  };
  return fetch3(url, options);
};
var get = async (fetch3, host, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var head = async (fetch3, host) => {
  const response = await fetchWithHeaders(fetch3, host, {
    method: "HEAD"
  });
  await checkOk(response);
  return response;
};
var post = async (fetch3, host, data, options) => {
  const isRecord = (input) => {
    return input !== null && typeof input === "object" && !Array.isArray(input);
  };
  const formattedData = isRecord(data) ? JSON.stringify(data) : data;
  const response = await fetchWithHeaders(fetch3, host, {
    method: "POST",
    body: formattedData,
    signal: options == null ? void 0 : options.signal,
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var del = async (fetch3, host, data, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    method: "DELETE",
    body: JSON.stringify(data),
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var parseJSON = async function* (itr) {
  var _a;
  const decoder = new TextDecoder("utf-8");
  let buffer = "";
  const reader = itr.getReader();
  while (true) {
    const { done, value: chunk } = await reader.read();
    if (done) {
      break;
    }
    buffer += decoder.decode(chunk);
    const parts = buffer.split("\n");
    buffer = (_a = parts.pop()) != null ? _a : "";
    for (const part of parts) {
      try {
        yield JSON.parse(part);
      } catch (error) {
        console.warn("invalid json: ", part);
      }
    }
  }
  for (const part of buffer.split("\n").filter((p2) => p2 !== "")) {
    try {
      yield JSON.parse(part);
    } catch (error) {
      console.warn("invalid json: ", part);
    }
  }
};
var formatHost = (host) => {
  if (!host) {
    return "http://127.0.0.1:11434";
  }
  let isExplicitProtocol = host.includes("://");
  if (host.startsWith(":")) {
    host = `http://127.0.0.1${host}`;
    isExplicitProtocol = true;
  }
  if (!isExplicitProtocol) {
    host = `http://${host}`;
  }
  const url = new URL(host);
  let port = url.port;
  if (!port) {
    if (!isExplicitProtocol) {
      port = "11434";
    } else {
      port = url.protocol === "https:" ? "443" : "80";
    }
  }
  let formattedHost = `${url.protocol}//${url.hostname}:${port}${url.pathname}`;
  if (formattedHost.endsWith("/")) {
    formattedHost = formattedHost.slice(0, -1);
  }
  return formattedHost;
};
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var Ollama$1 = class Ollama {
  constructor(config) {
    var _a, _b;
    __publicField(this, "config");
    __publicField(this, "fetch");
    __publicField(this, "ongoingStreamedRequests", []);
    this.config = {
      host: "",
      headers: config == null ? void 0 : config.headers
    };
    if (!(config == null ? void 0 : config.proxy)) {
      this.config.host = formatHost((_a = config == null ? void 0 : config.host) != null ? _a : "http://127.0.0.1:11434");
    }
    this.fetch = (_b = config == null ? void 0 : config.fetch) != null ? _b : fetch;
  }
  // Abort any ongoing streamed requests to Ollama
  abort() {
    for (const request of this.ongoingStreamedRequests) {
      request.abort();
    }
    this.ongoingStreamedRequests.length = 0;
  }
  /**
   * Processes a request to the Ollama server. If the request is streamable, it will return a
   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
   * object.
   * @param endpoint {string} - The endpoint to send the request to.
   * @param request {object} - The request object to send to the endpoint.
   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
   * response messages.
   * @throws {Error} - If the response body is missing or if the response is an error.
   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
   */
  async processStreamableRequest(endpoint, request) {
    var _a;
    request.stream = (_a = request.stream) != null ? _a : false;
    const host = `${this.config.host}/api/${endpoint}`;
    if (request.stream) {
      const abortController = new AbortController();
      const response2 = await post(this.fetch, host, request, {
        signal: abortController.signal,
        headers: this.config.headers
      });
      if (!response2.body) {
        throw new Error("Missing body");
      }
      const itr = parseJSON(response2.body);
      const abortableAsyncIterator = new AbortableAsyncIterator(
        abortController,
        itr,
        () => {
          const i = this.ongoingStreamedRequests.indexOf(abortableAsyncIterator);
          if (i > -1) {
            this.ongoingStreamedRequests.splice(i, 1);
          }
        }
      );
      this.ongoingStreamedRequests.push(abortableAsyncIterator);
      return abortableAsyncIterator;
    }
    const response = await post(this.fetch, host, request, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
  * Encodes an image to base64 if it is a Uint8Array.
  * @param image {Uint8Array | string} - The image to encode.
  * @returns {Promise<string>} - The base64 encoded image.
  */
  async encodeImage(image) {
    if (typeof image !== "string") {
      const uint8Array = new Uint8Array(image);
      let byteString = "";
      const len = uint8Array.byteLength;
      for (let i = 0; i < len; i++) {
        byteString += String.fromCharCode(uint8Array[i]);
      }
      return btoa(byteString);
    }
    return image;
  }
  /**
   * Generates a response from a text prompt.
   * @param request {GenerateRequest} - The request object.
   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async generate(request) {
    if (request.images) {
      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));
    }
    return this.processStreamableRequest("generate", request);
  }
  /**
   * Chats with the model. The request object can contain messages with images that are either
   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
   * request.
   * @param request {ChatRequest} - The request object.
   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
   * AbortableAsyncIterator that yields response messages.
   */
  async chat(request) {
    if (request.messages) {
      for (const message of request.messages) {
        if (message.images) {
          message.images = await Promise.all(
            message.images.map(this.encodeImage.bind(this))
          );
        }
      }
    }
    return this.processStreamableRequest("chat", request);
  }
  /**
   * Creates a new model from a stream of data.
   * @param request {CreateRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
   */
  async create(request) {
    return this.processStreamableRequest("create", {
      name: request.model,
      stream: request.stream,
      modelfile: request.modelfile,
      quantize: request.quantize
    });
  }
  /**
   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PullRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async pull(request) {
    return this.processStreamableRequest("pull", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PushRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async push(request) {
    return this.processStreamableRequest("push", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Deletes a model from the server. The request object should contain the name of the model to
   * delete.
   * @param request {DeleteRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async delete(request) {
    await del(
      this.fetch,
      `${this.config.host}/api/delete`,
      { name: request.model },
      { headers: this.config.headers }
    );
    return { status: "success" };
  }
  /**
   * Copies a model from one name to another. The request object should contain the name of the
   * model to copy and the new name.
   * @param request {CopyRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async copy(request) {
    await post(this.fetch, `${this.config.host}/api/copy`, { ...request }, {
      headers: this.config.headers
    });
    return { status: "success" };
  }
  /**
   * Lists the models on the server.
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async list() {
    const response = await get(this.fetch, `${this.config.host}/api/tags`, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Shows the metadata of a model. The request object should contain the name of the model.
   * @param request {ShowRequest} - The request object.
   * @returns {Promise<ShowResponse>} - The response object.
   */
  async show(request) {
    const response = await post(this.fetch, `${this.config.host}/api/show`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds text input into vectors.
   * @param request {EmbedRequest} - The request object.
   * @returns {Promise<EmbedResponse>} - The response object.
   */
  async embed(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embed`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds a text prompt into a vector.
   * @param request {EmbeddingsRequest} - The request object.
   * @returns {Promise<EmbeddingsResponse>} - The response object.
   */
  async embeddings(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Lists the running models on the server
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async ps() {
    const response = await get(this.fetch, `${this.config.host}/api/ps`, {
      headers: this.config.headers
    });
    return await response.json();
  }
};
var browser = new Ollama$1();

// node_modules/ollama/dist/index.mjs
var import_fs = __toESM(require("fs"), 1);
var import_path = require("path");
var import_crypto = require("crypto");
var import_os = require("os");
var Ollama2 = class extends Ollama$1 {
  async encodeImage(image) {
    if (typeof image !== "string") {
      return Buffer.from(image).toString("base64");
    }
    try {
      if (import_fs.default.existsSync(image)) {
        const fileBuffer = await import_fs.promises.readFile((0, import_path.resolve)(image));
        return Buffer.from(fileBuffer).toString("base64");
      }
    } catch (e) {
    }
    return image;
  }
  /**
   * Parse the modelfile and replace the FROM and ADAPTER commands with the corresponding blob hashes.
   * @param modelfile {string} - The modelfile content
   * @param mfDir {string} - The directory of the modelfile
   * @private @internal
   */
  async parseModelfile(modelfile, mfDir = process.cwd()) {
    const out = [];
    const lines = modelfile.split("\n");
    for (const line of lines) {
      const [command, args] = line.split(" ", 2);
      if (["FROM", "ADAPTER"].includes(command.toUpperCase())) {
        const path = this.resolvePath(args.trim(), mfDir);
        if (await this.fileExists(path)) {
          out.push(`${command} @${await this.createBlob(path)}`);
        } else {
          out.push(`${command} ${args}`);
        }
      } else {
        out.push(line);
      }
    }
    return out.join("\n");
  }
  /**
   * Resolve the path to an absolute path.
   * @param inputPath {string} - The input path
   * @param mfDir {string} - The directory of the modelfile
   * @private @internal
   */
  resolvePath(inputPath, mfDir) {
    if (inputPath.startsWith("~")) {
      return (0, import_path.join)((0, import_os.homedir)(), inputPath.slice(1));
    }
    return (0, import_path.resolve)(mfDir, inputPath);
  }
  /**
   * checks if a file exists
   * @param path {string} - The path to the file
   * @private @internal
   * @returns {Promise<boolean>} - Whether the file exists or not
   */
  async fileExists(path) {
    try {
      await import_fs.promises.access(path);
      return true;
    } catch (e) {
      return false;
    }
  }
  async createBlob(path) {
    if (typeof ReadableStream === "undefined") {
      throw new Error("Streaming uploads are not supported in this environment.");
    }
    const fileStream = (0, import_fs.createReadStream)(path);
    const sha256sum = await new Promise((resolve2, reject) => {
      const hash = (0, import_crypto.createHash)("sha256");
      fileStream.on("data", (data) => hash.update(data));
      fileStream.on("end", () => resolve2(hash.digest("hex")));
      fileStream.on("error", reject);
    });
    const digest = `sha256:${sha256sum}`;
    try {
      await head(this.fetch, `${this.config.host}/api/blobs/${digest}`);
    } catch (e) {
      if (e instanceof Error && e.message.includes("404")) {
        const readableStream = new ReadableStream({
          start(controller) {
            fileStream.on("data", (chunk) => {
              controller.enqueue(chunk);
            });
            fileStream.on("end", () => {
              controller.close();
            });
            fileStream.on("error", (err) => {
              controller.error(err);
            });
          }
        });
        await post(
          this.fetch,
          `${this.config.host}/api/blobs/${digest}`,
          readableStream
        );
      } else {
        throw e;
      }
    }
    return digest;
  }
  async create(request) {
    let modelfileContent = "";
    if (request.path) {
      modelfileContent = await import_fs.promises.readFile(request.path, { encoding: "utf8" });
      modelfileContent = await this.parseModelfile(
        modelfileContent,
        (0, import_path.dirname)(request.path)
      );
    } else if (request.modelfile) {
      modelfileContent = await this.parseModelfile(request.modelfile);
    } else {
      throw new Error("Must provide either path or modelfile to create a model");
    }
    request.modelfile = modelfileContent;
    if (request.stream) {
      return super.create(request);
    } else {
      return super.create(request);
    }
  }
};
var index = new Ollama2();

// src/providers/ollama/ollama.ts
var OllamaProvider = class {
  constructor(settins) {
    this.id = "ollama" /* OLLAMA */;
    this.name = "Ollama";
    this.description = "Ollama model for completion";
    this.settings = settins;
    this.ollama = new Ollama2({ host: this.settings.host });
  }
  async load() {
    console.log(`loading ollama ${this.settings.host} provider`);
    this.ollama = new Ollama2({ host: this.settings.host });
  }
  async *generate(prefix, suffix) {
    console.log("fetching completion");
    const promiseIterator = await this.ollama.generate({
      model: this.settings.model,
      prompt: prefix,
      stream: true
    });
    let completion = "";
    for await (let response of promiseIterator) {
      completion += response.response;
      yield { complete_suggestion: completion, display_suggestion: completion };
    }
  }
  async abort() {
    console.log("canceling completion");
    this.ollama.abort();
  }
};

// src/settings/settings.ts
var DEFAULT_SETTINGS = {
  provider: "ollama",
  providerSettings: {
    openai: {
      apiKey: "",
      model: "gpt-4"
    },
    ollama: {
      host: "http://localhost:11434",
      model: "mistral-nemo"
    }
  },
  promtty: true
};

// src/settings/settings-tab.ts
var import_obsidian4 = require("obsidian");

// src/settings/provider-settings.ts
var import_obsidian3 = require("obsidian");

// src/settings/settings-component.ts
var InscribeSettingsComponent = class {
  constructor(plugin, containerEl) {
    this.plugin = plugin;
    this.containerEl = containerEl;
  }
};

// src/providers/ollama/settings.ts
var import_obsidian = require("obsidian");
var OllamaSettingsComponent = class extends InscribeSettingsComponent {
  display() {
    this.containerEl.createEl("h3", { text: "Ollama Settings" });
    new import_obsidian.Setting(this.containerEl).setName("Host").setDesc("Enter the Ollama host.").addText(
      (text) => text.setPlaceholder(this.plugin.settings.providerSettings.ollama.host).setValue(this.plugin.settings.providerSettings.ollama.host).onChange(async (value) => {
        this.plugin.settings.providerSettings.ollama.host = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Model").setDesc("Choose the Ollama model.").addDropdown((dropdown) => {
      dropdown.addOption("mistral-nemo", "Mistral-Nemo").addOption("mistral-gpt", "Mistral-GPT").setValue(this.plugin.settings.providerSettings.ollama.model).onChange(async (value) => {
        this.plugin.settings.providerSettings.ollama.model = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/providers/openai/settings.ts
var import_obsidian2 = require("obsidian");
var OpenAISettingsComponent = class extends InscribeSettingsComponent {
  display() {
    this.containerEl.createEl("h3", { text: "OpenAI Settings" });
    new import_obsidian2.Setting(this.containerEl).setName("API Key").setDesc("Enter the OpenAI API key.").addText(
      (text) => text.setPlaceholder(this.plugin.settings.providerSettings.openai.apiKey).setValue(this.plugin.settings.providerSettings.openai.apiKey).onChange(async (value) => {
        this.plugin.settings.providerSettings.openai.apiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(this.containerEl).setName("Model").setDesc("Choose the OpenAI model.").addDropdown((dropdown) => {
      dropdown.addOption("gpt-4", "GPT-4").addOption("davinci", "Davinci").setValue(this.plugin.settings.providerSettings.openai.model).onChange(async (value) => {
        this.plugin.settings.providerSettings.openai.model = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/settings/provider-settings.ts
var ProviderSettingsComponent = class extends InscribeSettingsComponent {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Provider Settings" });
    new import_obsidian3.Setting(containerEl).setName("AI Provider").setDesc("Choose your preferred AI provider.").addDropdown((dropdown) => {
      for (const provider of PROVIDERS) {
        dropdown.addOption(provider.id, provider.name);
      }
      dropdown.setValue(this.plugin.settings.provider).onChange(async (value) => {
        this.plugin.settings.provider = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    switch (this.plugin.settings.provider) {
      case "openai" /* OPENAI */:
        new OpenAISettingsComponent(this.plugin, containerEl).display();
        break;
      case "ollama" /* OLLAMA */:
        new OllamaSettingsComponent(this.plugin, containerEl).display();
        break;
    }
  }
};

// src/settings/settings-tab.ts
var InscribeSettingsTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    new ProviderSettingsComponent(this.plugin, containerEl).display();
  }
};

// src/main.ts
var Inscribe = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    await this.loadModel();
    await this.setupExtention();
    this.addSettingTab(new InscribeSettingsTab(this.app, this));
  }
  onunload() {
  }
  async loadModel() {
    this.provider = new OllamaProvider(this.settings.providerSettings.ollama);
  }
  async setupExtention() {
    const extension = G({
      fetchFn: () => this.generateSuggestions(),
      delay: 500,
      continue_suggesting: false,
      accept_shortcut: "Tab"
    });
    this.registerEditorExtension(extension);
  }
  async *generateSuggestions() {
    let markdownFileInfo = this.app.workspace.activeEditor;
    if (!markdownFileInfo)
      return;
    const editor = markdownFileInfo.editor;
    const cursor = editor.getCursor();
    const currentLine = editor.getLine(cursor.line);
    if (!currentLine.length) {
      yield {
        display_suggestion: "",
        complete_suggestion: ""
      };
      return;
    }
    const lastChar = currentLine[cursor.ch - 1];
    if (lastChar !== " ") {
      yield { display_suggestion: "", complete_suggestion: "" };
      return;
    }
    const beforeCursor = editor.getRange({ line: 0, ch: 0 }, cursor);
    const afterCursor = editor.getRange(
      cursor,
      { line: editor.lastLine(), ch: editor.getLine(editor.lastLine()).length }
    );
    this.provider.abort();
    yield* this.provider.generate(beforeCursor, afterCursor);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.loadModel();
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAibm9kZV9tb2R1bGVzL2NvZGVtaXJyb3ItY29tcGFuaW9uLWV4dGVuc2lvbi9zcmMvbGliL3V0aWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9jb2RlbWlycm9yLWNvbXBhbmlvbi1leHRlbnNpb24vc3JjL2V4dGVuc2lvbi50cyIsICJzcmMvcHJvdmlkZXJzL3Byb3ZpZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCAibm9kZV9tb2R1bGVzL29sbGFtYS9kaXN0L3NoYXJlZC9vbGxhbWEuY2RkYmM4NWIubWpzIiwgIm5vZGVfbW9kdWxlcy9vbGxhbWEvZGlzdC9pbmRleC5tanMiLCAic3JjL3Byb3ZpZGVycy9vbGxhbWEvb2xsYW1hLnRzIiwgInNyYy9zZXR0aW5ncy9zZXR0aW5ncy50cyIsICJzcmMvc2V0dGluZ3Mvc2V0dGluZ3MtdGFiLnRzIiwgInNyYy9zZXR0aW5ncy9wcm92aWRlci1zZXR0aW5ncy50cyIsICJzcmMvc2V0dGluZ3Mvc2V0dGluZ3MtY29tcG9uZW50LnRzIiwgInNyYy9wcm92aWRlcnMvb2xsYW1hL3NldHRpbmdzLnRzIiwgInNyYy9wcm92aWRlcnMvb3BlbmFpL3NldHRpbmdzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBFZGl0b3IsIFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IGlubGluZVN1Z2dlc3Rpb24sIFN1Z2dlc3Rpb24gfSBmcm9tIFwiY29kZW1pcnJvci1jb21wYW5pb24tZXh0ZW5zaW9uXCI7XG5pbXBvcnQgeyBDb21wbGV0ZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9wcm92aWRlcic7XG5pbXBvcnQgT2xsYW1hUHJvdmlkZXIgZnJvbSAnLi9wcm92aWRlcnMvb2xsYW1hL29sbGFtYSc7XG5pbXBvcnQgeyBTZXR0aW5ncywgREVGQVVMVF9TRVRUSU5HUyB9IGZyb20gJy4vc2V0dGluZ3Mvc2V0dGluZ3MnO1xuaW1wb3J0IHsgSW5zY3JpYmVTZXR0aW5nc1RhYiB9IGZyb20gJy4vc2V0dGluZ3Mvc2V0dGluZ3MtdGFiJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5zY3JpYmUgZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogU2V0dGluZ3M7XG5cdHByb3ZpZGVyOiBDb21wbGV0ZXJcblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblx0XHRhd2FpdCB0aGlzLmxvYWRNb2RlbCgpO1xuXHRcdGF3YWl0IHRoaXMuc2V0dXBFeHRlbnRpb24oKTtcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IEluc2NyaWJlU2V0dGluZ3NUYWIodGhpcy5hcHAsIHRoaXMpKTtcblx0fVxuXG5cdG9udW5sb2FkKCkgeyB9XG5cblx0YXN5bmMgbG9hZE1vZGVsKCkge1xuXHRcdHRoaXMucHJvdmlkZXIgPSBuZXcgT2xsYW1hUHJvdmlkZXIodGhpcy5zZXR0aW5ncy5wcm92aWRlclNldHRpbmdzLm9sbGFtYSk7XG5cdH1cblxuXHRhc3luYyBzZXR1cEV4dGVudGlvbigpIHtcblx0XHRjb25zdCBleHRlbnNpb24gPSBpbmxpbmVTdWdnZXN0aW9uKHtcblx0XHRcdGZldGNoRm46ICgpID0+IHRoaXMuZ2VuZXJhdGVTdWdnZXN0aW9ucygpLFxuXHRcdFx0ZGVsYXk6IDUwMCxcblx0XHRcdGNvbnRpbnVlX3N1Z2dlc3Rpbmc6IGZhbHNlLFxuXHRcdFx0YWNjZXB0X3Nob3J0Y3V0OiAnVGFiJyxcblx0XHR9KTtcblxuXHRcdHRoaXMucmVnaXN0ZXJFZGl0b3JFeHRlbnNpb24oZXh0ZW5zaW9uKTtcblx0fVxuXG5cdGFzeW5jICpnZW5lcmF0ZVN1Z2dlc3Rpb25zKCk6IEFzeW5jR2VuZXJhdG9yPFN1Z2dlc3Rpb24sIHZvaWQsIHVua25vd24+IHtcblx0XHRsZXQgbWFya2Rvd25GaWxlSW5mbyA9IHRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVFZGl0b3I7XG5cdFx0aWYgKCFtYXJrZG93bkZpbGVJbmZvKSByZXR1cm47XG5cblx0XHRjb25zdCBlZGl0b3IgPSBtYXJrZG93bkZpbGVJbmZvLmVkaXRvciBhcyBFZGl0b3I7XG5cdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXG5cdFx0Ly8gSWYgdGhlIGN1cnJlbnQgbGluZSBpcyBlbXB0eSwgZG9uJ3Qgc3VnZ2VzdCBhbnl0aGluZy5cblx0XHRjb25zdCBjdXJyZW50TGluZSA9IGVkaXRvci5nZXRMaW5lKGN1cnNvci5saW5lKTtcblx0XHRpZiAoIWN1cnJlbnRMaW5lLmxlbmd0aCkge1xuXHRcdFx0eWllbGQge1xuXHRcdFx0XHRkaXNwbGF5X3N1Z2dlc3Rpb246IFwiXCIsXG5cdFx0XHRcdGNvbXBsZXRlX3N1Z2dlc3Rpb246IFwiXCIsXG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9ubHkgaWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgc3BhY2Ugb3IgZG90LCBzdWdnZXN0IGNvbXBsZXRpb25zLlxuXHRcdGNvbnN0IGxhc3RDaGFyID0gY3VycmVudExpbmVbY3Vyc29yLmNoIC0gMV07XG5cdFx0aWYgKGxhc3RDaGFyICE9PSBcIiBcIikge1xuXHRcdFx0eWllbGQgeyBkaXNwbGF5X3N1Z2dlc3Rpb246IFwiXCIsIGNvbXBsZXRlX3N1Z2dlc3Rpb246IFwiXCIgfTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBiZWZvcmVDdXJzb3IgPSBlZGl0b3IuZ2V0UmFuZ2UoeyBsaW5lOiAwLCBjaDogMCB9LCBjdXJzb3IpO1xuXHRcdGNvbnN0IGFmdGVyQ3Vyc29yID0gZWRpdG9yLmdldFJhbmdlKGN1cnNvcixcblx0XHRcdHsgbGluZTogZWRpdG9yLmxhc3RMaW5lKCksIGNoOiBlZGl0b3IuZ2V0TGluZShlZGl0b3IubGFzdExpbmUoKSkubGVuZ3RoIH0pO1xuXG5cdFx0dGhpcy5wcm92aWRlci5hYm9ydCgpO1xuXHRcdHlpZWxkKiB0aGlzLnByb3ZpZGVyLmdlbmVyYXRlKGJlZm9yZUN1cnNvciwgYWZ0ZXJDdXJzb3IpO1xuXHR9XG5cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKFxuXHRcdFx0e30sXG5cdFx0XHRERUZBVUxUX1NFVFRJTkdTLFxuXHRcdFx0YXdhaXQgdGhpcy5sb2FkRGF0YSgpXG5cdFx0KTtcblx0fVxuXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuXHRcdGF3YWl0IHRoaXMubG9hZE1vZGVsKCk7XG5cdH1cbn1cbiIsICIvKipcbiAqIEBwYXJhbSBmIGNhbGxiYWNrXG4gKiBAcGFyYW0gd2FpdCBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBhYm9ydFZhbHVlIGlmIGhhcyBhYm9ydFZhbHVlLCBwcm9taXNlIHdpbGwgcmVqZWN0IGl0IGlmXG4gKiBAcmV0dXJucyBkZWJvdW5jZWQ6IFByb21pc2UsIGZvcmNlOiAoKSA9PiB2b2lkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZVByb21pc2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbiAgZm46IFQsXG4gIHdhaXQ6IG51bWJlcixcbiAgYWJvcnRWYWx1ZTogYW55ID0gdW5kZWZpbmVkXG4pOiB7XG4gIGRlYm91bmNlZDogKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IFByb21pc2U8QXdhaXRlZDxSZXR1cm5UeXBlPFQ+Pj47XG4gIGZvcmNlOiAoKSA9PiB2b2lkO1xufSB7XG4gIGxldCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9O1xuICBjb25zdCBmb3JjZSA9IHtcbiAgICBmb3JjZTogKCkgPT4ge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH0sXG4gIH07XG4gIC8vIHR5cGUgQXdhaXRlZDxUPiA9IFQgZXh0ZW5kcyBQcm9taXNlTGlrZTxpbmZlciBVPiA/IFUgOiBUXG4gIHR5cGUgUmV0dXJuVCA9IEF3YWl0ZWQ8UmV0dXJuVHlwZTxUPj47XG4gIGNvbnN0IHdyYXBGdW5jID0gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pOiBQcm9taXNlPFJldHVyblQ+ID0+IHtcbiAgICBjYW5jZWwoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoZm4oLi4uYXJncykpLCB3YWl0KTtcbiAgICAgIGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgaWYgKGFib3J0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlamVjdChhYm9ydFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZvcmNlLmZvcmNlID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHsgZGVib3VuY2VkOiB3cmFwRnVuYywgZm9yY2U6ICgpID0+IGZvcmNlLmZvcmNlKCkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlQXN5bmNHZW5lcmF0b3I8VFBhcmFtcywgVD4oXG4gIGZuOiAoLi4uYXJnczogVFBhcmFtc1tdKSA9PiBBc3luY0dlbmVyYXRvcjxULCB2b2lkLCB2b2lkPixcbiAgd2FpdDogbnVtYmVyLFxuICBhYm9ydFZhbHVlOiBhbnkgPSB1bmRlZmluZWRcbik6IHtcbiAgZGVib3VuY2VkOiAoLi4uYXJnczogVFBhcmFtc1tdKSA9PiBBc3luY0dlbmVyYXRvcjxULCB2b2lkLCB2b2lkPjtcbiAgZm9yY2U6ICgpID0+IHZvaWQ7XG59IHtcbiAgY29uc3QgZm9yY2UgPSB7XG4gICAgZm9yY2U6ICgpID0+IHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9LFxuICB9O1xuICBsZXQgdGltZXI6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIGFzeW5jIGZ1bmN0aW9uKiB3cmFwRnVuYyguLi5hcmdzOiBUUGFyYW1zW10pOiBBc3luY0dlbmVyYXRvcjxULCB2b2lkLCB2b2lkPiB7XG4gICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICBsZXQgb3duX3RpbWVyOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICBvd25fdGltZXIgPSB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSgpLCB3YWl0KTtcbiAgICAgICAgZm9yY2UuZm9yY2UgPSAoKSA9PiB7XG4gICAgICAgICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoYWJvcnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IGFib3J0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGZuKC4uLmFyZ3MpKSB7XG4gICAgICBpZiAob3duX3RpbWVyICE9PSB0aW1lcikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHlpZWxkIGl0ZW07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGRlYm91bmNlZDogd3JhcEZ1bmMsIGZvcmNlOiAoKSA9PiBmb3JjZS5mb3JjZSgpIH07XG59XG4iLCAiaW1wb3J0IHtcbiAgVmlld1BsdWdpbixcbiAgRGVjb3JhdGlvblNldCxcbiAgRWRpdG9yVmlldyxcbiAgVmlld1VwZGF0ZSxcbiAgRGVjb3JhdGlvbixcbiAgV2lkZ2V0VHlwZSxcbiAga2V5bWFwLFxufSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7XG4gIFN0YXRlRWZmZWN0LFxuICBUZXh0LFxuICBQcmVjLFxuICBTdGF0ZUZpZWxkLFxuICBFZGl0b3JTdGF0ZSxcbiAgRWRpdG9yU2VsZWN0aW9uLFxuICBUcmFuc2FjdGlvblNwZWMsXG59IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IGRlYm91bmNlQXN5bmNHZW5lcmF0b3IgfSBmcm9tICcuL2xpYi91dGlscyc7XG5cbi8vIFNwbGl0dGluZyB0aGlzIHVwIHRvIGFsbG93ICBzb21lb25lIHRvIGRpc3BsYXkgYSB3aG9sZSBzZW50ZW5jZSBhcyBhIHN1Z2dlc3Rpb25cbi8vIHdoaWxlIG9ubHkgbGV0dGluZyB0aGUgdGFiIGtleSBpbnNlcnQgdGhlIG5leHQgd29yZCBldGMuXG5leHBvcnQgdHlwZSBTdWdnZXN0aW9uID0ge1xuICBjb21wbGV0ZV9zdWdnZXN0aW9uOiBzdHJpbmc7XG4gIGRpc3BsYXlfc3VnZ2VzdGlvbjogc3RyaW5nO1xuICBhY2NlcHRfaG9vaz86ICgpID0+IHZvaWQ7XG59O1xuXG4vLyBDdXJyZW50IHN0YXRlIG9mIHRoZSBhdXRvc3VnZ2VzdGlvblxuY29uc3QgSW5saW5lU3VnZ2VzdGlvblN0YXRlID0gU3RhdGVGaWVsZC5kZWZpbmU8e1xuICBzdWdnZXN0aW9uOiBudWxsIHwgU3VnZ2VzdGlvbjtcbn0+KHtcbiAgY3JlYXRlKCkge1xuICAgIHJldHVybiB7IHN1Z2dlc3Rpb246IG51bGwgfTtcbiAgfSxcbiAgdXBkYXRlKF9fOiBhbnksIHRyOiBhbnkpIHtcbiAgICBjb25zdCBpbmxpbmVTdWdnZXN0aW9uID0gdHIuZWZmZWN0cy5maW5kKChlOiBhbnkpID0+XG4gICAgICBlLmlzKElubGluZVN1Z2dlc3Rpb25FZmZlY3QpXG4gICAgKTtcbiAgICBpZiAodHIuc3RhdGUuZG9jKVxuICAgICAgaWYgKFxuICAgICAgICBpbmxpbmVTdWdnZXN0aW9uICYmXG4gICAgICAgIChpbmxpbmVTdWdnZXN0aW9uLnZhbHVlLmRvYyA9PSBudWxsIHx8XG4gICAgICAgICAgdHIuc3RhdGUuZG9jID09IGlubGluZVN1Z2dlc3Rpb24udmFsdWUuZG9jKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB7IHN1Z2dlc3Rpb246IGlubGluZVN1Z2dlc3Rpb24udmFsdWUuc3VnZ2VzdGlvbiB9O1xuICAgICAgfVxuICAgIHJldHVybiB7IHN1Z2dlc3Rpb246IG51bGwgfTtcbiAgfSxcbn0pO1xuXG5jb25zdCBJbmxpbmVTdWdnZXN0aW9uRWZmZWN0ID0gU3RhdGVFZmZlY3QuZGVmaW5lPHtcbiAgc3VnZ2VzdGlvbjogU3VnZ2VzdGlvbiB8IG51bGw7XG4gIGRvYzogVGV4dCB8IG51bGw7XG59PigpO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgc3VnZ2VzdGlvbiBmb3IgdGhlIG5leHQgd29yZFxuICovXG5mdW5jdGlvbiBpbmxpbmVTdWdnZXN0aW9uRGVjb3JhdGlvbih2aWV3OiBFZGl0b3JWaWV3LCBwcmVmaXg6IHN0cmluZykge1xuICBjb25zdCBwb3MgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gIGNvbnN0IHdpZGdldHMgPSBbXTtcbiAgY29uc3QgdyA9IERlY29yYXRpb24ud2lkZ2V0KHtcbiAgICB3aWRnZXQ6IG5ldyBJbmxpbmVTdWdnZXN0aW9uV2lkZ2V0KHByZWZpeCksXG4gICAgc2lkZTogMSxcbiAgfSk7XG4gIHdpZGdldHMucHVzaCh3LnJhbmdlKHBvcykpO1xuICByZXR1cm4gRGVjb3JhdGlvbi5zZXQod2lkZ2V0cyk7XG59XG5cbmNsYXNzIElubGluZVN1Z2dlc3Rpb25XaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgc3VnZ2VzdGlvbjogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihzdWdnZXN0aW9uOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc3VnZ2VzdGlvbiA9IHN1Z2dlc3Rpb247XG4gIH1cbiAgdG9ET00oKSB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGRpdi5zdHlsZS5vcGFjaXR5ID0gJzAuNCc7XG4gICAgZGl2LmNsYXNzTmFtZSA9ICdjbS1pbmxpbmUtc3VnZ2VzdGlvbic7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGhpcy5zdWdnZXN0aW9uO1xuICAgIHJldHVybiBkaXY7XG4gIH1cbn1cblxudHlwZSBJbmxpbmVGZXRjaEZuID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSkgPT4gQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj47XG5cbmV4cG9ydCBjb25zdCBmZXRjaFN1Z2dlc3Rpb24gPSAoZmV0Y2hGbjogSW5saW5lRmV0Y2hGbikgPT4ge1xuICBsZXQgc3VnZ2VzdGlvbklkID0gMDtcbiAgcmV0dXJuIFZpZXdQbHVnaW4uZnJvbUNsYXNzKFxuICAgIGNsYXNzIEZldGNoUGx1Z2luIHtcbiAgICAgIGFzeW5jIHVwZGF0ZSh1cGRhdGU6IFZpZXdVcGRhdGUpIHtcbiAgICAgICAgY29uc3QgZG9jID0gdXBkYXRlLnN0YXRlLmRvYztcbiAgICAgICAgLy8gT25seSBmZXRjaCBpZiB0aGUgZG9jdW1lbnQgaGFzIGNoYW5nZWRcbiAgICAgICAgaWYgKCF1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U3VnZ2VzdGlvbklkID0gKytzdWdnZXN0aW9uSWQ7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcmVzdWx0IG9mIGZldGNoRm4odXBkYXRlLnN0YXRlKSkge1xuICAgICAgICAgIGlmIChjdXJyZW50U3VnZ2VzdGlvbklkICE9IHN1Z2dlc3Rpb25JZCkgcmV0dXJuO1xuICAgICAgICAgIHVwZGF0ZS52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGVmZmVjdHM6IElubGluZVN1Z2dlc3Rpb25FZmZlY3Qub2Yoe1xuICAgICAgICAgICAgICBzdWdnZXN0aW9uOiByZXN1bHQsXG4gICAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG59O1xuXG5jbGFzcyBSZW5kZXJQbHVnaW4ge1xuICBkZWNvcmF0aW9uczogRGVjb3JhdGlvblNldDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gRW1wdHkgZGVjb3JhdGlvbnNcbiAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuICB9XG4gIHVwZGF0ZSh1cGRhdGU6IFZpZXdVcGRhdGUpIHtcbiAgICBjb25zdCBzdWdnZXN0aW9uOiBTdWdnZXN0aW9uIHwgbnVsbCA9IHVwZGF0ZS5zdGF0ZS5maWVsZChcbiAgICAgIElubGluZVN1Z2dlc3Rpb25TdGF0ZVxuICAgICk/LnN1Z2dlc3Rpb247XG4gICAgaWYgKCFzdWdnZXN0aW9uKSB7XG4gICAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlY29yYXRpb25zID0gaW5saW5lU3VnZ2VzdGlvbkRlY29yYXRpb24oXG4gICAgICB1cGRhdGUudmlldyxcbiAgICAgIHN1Z2dlc3Rpb24uZGlzcGxheV9zdWdnZXN0aW9uXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCByZW5kZXJJbmxpbmVTdWdnZXN0aW9uUGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoUmVuZGVyUGx1Z2luLCB7XG4gIGRlY29yYXRpb25zOiAodjogUmVuZGVyUGx1Z2luKSA9PiB2LmRlY29yYXRpb25zLFxufSk7XG5cbmNsYXNzIGlubGluZVN1Z2dlc3Rpb25LZXltYXAge1xuICBzdWdnZXN0Rm46IElubGluZUZldGNoRm4gfCBudWxsO1xuICBrZXltYXA6IGFueTtcbiAgY29tcGxldGlvbklkOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Ioc3VnZ2VzdEZuOiBJbmxpbmVGZXRjaEZuIHwgbnVsbCwgYWNjZXB0X3Nob3J0Y3V0OiBzdHJpbmcpIHtcbiAgICB0aGlzLnN1Z2dlc3RGbiA9IHN1Z2dlc3RGbjtcbiAgICB0aGlzLmtleW1hcCA9IFByZWMuaGlnaGVzdChcbiAgICAgIGtleW1hcC5vZihbXG4gICAgICAgIHtcbiAgICAgICAgICBrZXk6IGFjY2VwdF9zaG9ydGN1dCxcbiAgICAgICAgICBydW46ICh2aWV3OiBFZGl0b3JWaWV3KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW4odmlldyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIF0pXG4gICAgKTtcbiAgICB0aGlzLmNvbXBsZXRpb25JZCA9IDA7XG4gIH1cblxuICBydW4gPSAodmlldzogRWRpdG9yVmlldykgPT4ge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb246IFN1Z2dlc3Rpb24gfCBudWxsID0gdmlldy5zdGF0ZS5maWVsZChcbiAgICAgIElubGluZVN1Z2dlc3Rpb25TdGF0ZVxuICAgICk/LnN1Z2dlc3Rpb247XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBzdWdnZXN0aW9uLCBkbyBub3RoaW5nIGFuZCBsZXQgdGhlIGRlZmF1bHQga2V5bWFwIGhhbmRsZSBpdFxuICAgIGlmICghc3VnZ2VzdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgLi4uaW5zZXJ0Q29tcGxldGlvblRleHQoXG4gICAgICAgIHZpZXcuc3RhdGUsXG4gICAgICAgIHN1Z2dlc3Rpb24uY29tcGxldGVfc3VnZ2VzdGlvbixcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkLFxuICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWRcbiAgICAgICksXG4gICAgfSk7XG4gICAgc3VnZ2VzdGlvbi5hY2NlcHRfaG9vaz8uKCk7XG5cbiAgICAvLyBSZS10cmlnZ2VyIHRoZSBzdWdnZXN0aW9uXG4gICAgY29uc3QgcmV0cmlnZ2VyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3VnZ2VzdEZuID09IG51bGwpIHJldHVybjtcbiAgICAgIGNvbnN0IGNvbXBsZXRpb25JZCA9ICsrdGhpcy5jb21wbGV0aW9uSWQ7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHJlc3VsdCBvZiB0aGlzLnN1Z2dlc3RGbih2aWV3LnN0YXRlKSkge1xuICAgICAgICBpZiAoY29tcGxldGlvbklkICE9IHRoaXMuY29tcGxldGlvbklkKSByZXR1cm47XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgIGVmZmVjdHM6IElubGluZVN1Z2dlc3Rpb25FZmZlY3Qub2Yoe1xuICAgICAgICAgICAgc3VnZ2VzdGlvbjoge1xuICAgICAgICAgICAgICBjb21wbGV0ZV9zdWdnZXN0aW9uOiByZXN1bHQuY29tcGxldGVfc3VnZ2VzdGlvbixcbiAgICAgICAgICAgICAgZGlzcGxheV9zdWdnZXN0aW9uOiByZXN1bHQuZGlzcGxheV9zdWdnZXN0aW9uLFxuICAgICAgICAgICAgICBhY2NlcHRfaG9vazogcmVzdWx0LmFjY2VwdF9ob29rLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvYzogbnVsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXRyaWdnZXIoKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnNlcnRDb21wbGV0aW9uVGV4dChcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0ZXh0OiBzdHJpbmcsXG4gIGZyb206IG51bWJlcixcbiAgdG86IG51bWJlclxuKTogVHJhbnNhY3Rpb25TcGVjIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZS5jaGFuZ2VCeVJhbmdlKChyYW5nZSkgPT4ge1xuICAgICAgaWYgKHJhbmdlID09IHN0YXRlLnNlbGVjdGlvbi5tYWluKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogZnJvbSwgdG86IHRvLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tICsgdGV4dC5sZW5ndGgpLFxuICAgICAgICB9O1xuICAgICAgY29uc3QgbGVuID0gdG8gLSBmcm9tO1xuICAgICAgaWYgKFxuICAgICAgICAhcmFuZ2UuZW1wdHkgfHxcbiAgICAgICAgKGxlbiAmJlxuICAgICAgICAgIHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20gLSBsZW4sIHJhbmdlLmZyb20pICE9XG4gICAgICAgICAgICBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpXG4gICAgICApXG4gICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20gLSBsZW4sIHRvOiByYW5nZS5mcm9tLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSAtIGxlbiArIHRleHQubGVuZ3RoKSxcbiAgICAgIH07XG4gICAgfSksXG4gICAgdXNlckV2ZW50OiAnaW5wdXQuY29tcGxldGUnLFxuICB9O1xufVxuXG50eXBlIElubGluZVN1Z2dlc3Rpb25PcHRpb25zID0ge1xuICBmZXRjaEZuOiAoXG4gICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBTdWdnZXN0aW9uPiB8IEFzeW5jR2VuZXJhdG9yPFN1Z2dlc3Rpb24+O1xuICBkZWxheT86IG51bWJlcjtcbiAgY29udGludWVfc3VnZ2VzdGluZz86IGJvb2xlYW47XG4gIGFjY2VwdF9zaG9ydGN1dD86IHN0cmluZyB8IG51bGw7XG59O1xuXG4vLyBUaGlzIGlzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuZnVuY3Rpb24gdG9TdWdnZXN0aW9uKHN1Z2dlc3Rpb246IHN0cmluZyB8IFN1Z2dlc3Rpb24pOiBTdWdnZXN0aW9uIHtcbiAgaWYgKHR5cGVvZiBzdWdnZXN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wbGV0ZV9zdWdnZXN0aW9uOiBzdWdnZXN0aW9uLFxuICAgICAgZGlzcGxheV9zdWdnZXN0aW9uOiBzdWdnZXN0aW9uLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN1Z2dlc3Rpb247XG59XG5cbmZ1bmN0aW9uIHRvU3VnZ2VzdGlvbkZuKFxuICBmZXRjaEZuOiAoXG4gICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBTdWdnZXN0aW9uPiB8IEFzeW5jR2VuZXJhdG9yPFN1Z2dlc3Rpb24+XG4pOiBJbmxpbmVGZXRjaEZuIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiAoc3RhdGU6IEVkaXRvclN0YXRlKSB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbiA9IGF3YWl0IGZldGNoRm4oc3RhdGUpO1xuXG4gICAgLy8gSWYgaXQncyBhIHN0cmluZyBvciBhIFN1Z2dlc3Rpb25cbiAgICBpZiAodHlwZW9mIHN1Z2dlc3Rpb24gPT09ICdzdHJpbmcnIHx8ICdjb21wbGV0ZV9zdWdnZXN0aW9uJyBpbiBzdWdnZXN0aW9uKSB7XG4gICAgICB5aWVsZCB0b1N1Z2dlc3Rpb24oc3VnZ2VzdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIGF3YWl0IChjb25zdCBzIG9mIHN1Z2dlc3Rpb24pIHtcbiAgICAgIHlpZWxkIHRvU3VnZ2VzdGlvbihzKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmxpbmVTdWdnZXN0aW9uKG9wdGlvbnM6IElubGluZVN1Z2dlc3Rpb25PcHRpb25zKSB7XG4gIGNvbnN0IHsgZGVsYXkgPSA1MDAsIGFjY2VwdF9zaG9ydGN1dCA9ICdUYWInIH0gPSBvcHRpb25zO1xuICBjb25zdCBmZXRjaEZuID0gdG9TdWdnZXN0aW9uRm4ob3B0aW9ucy5mZXRjaEZuKTtcbiAgY29uc3QgeyBkZWJvdW5jZWQ6IGRlYm91bmNlZF9mZXRjaEZuIH0gPSBkZWJvdW5jZUFzeW5jR2VuZXJhdG9yKFxuICAgIGZldGNoRm4sXG4gICAgZGVsYXlcbiAgKTtcbiAgcmV0dXJuIGFjY2VwdF9zaG9ydGN1dFxuICAgID8gW1xuICAgICAgICBJbmxpbmVTdWdnZXN0aW9uU3RhdGUsXG4gICAgICAgIGZldGNoU3VnZ2VzdGlvbihkZWJvdW5jZWRfZmV0Y2hGbiksXG4gICAgICAgIHJlbmRlcklubGluZVN1Z2dlc3Rpb25QbHVnaW4sXG4gICAgICAgIG5ldyBpbmxpbmVTdWdnZXN0aW9uS2V5bWFwKFxuICAgICAgICAgIG9wdGlvbnMuY29udGludWVfc3VnZ2VzdGluZyA/IGZldGNoRm4gOiBudWxsLFxuICAgICAgICAgIGFjY2VwdF9zaG9ydGN1dFxuICAgICAgICApLmtleW1hcCxcbiAgICAgIF1cbiAgICA6IFtcbiAgICAgICAgSW5saW5lU3VnZ2VzdGlvblN0YXRlLFxuICAgICAgICBmZXRjaFN1Z2dlc3Rpb24oZGVib3VuY2VkX2ZldGNoRm4pLFxuICAgICAgICByZW5kZXJJbmxpbmVTdWdnZXN0aW9uUGx1Z2luLFxuICAgICAgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcmNlYWJsZUlubGluZVN1Z2dlc3Rpb24ob3B0aW9uczogSW5saW5lU3VnZ2VzdGlvbk9wdGlvbnMpIHtcbiAgY29uc3QgeyBkZWxheSA9IDUwMCwgYWNjZXB0X3Nob3J0Y3V0ID0gJ1RhYicgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZldGNoRm4gPSB0b1N1Z2dlc3Rpb25GbihvcHRpb25zLmZldGNoRm4pO1xuICBjb25zdCB7IGRlYm91bmNlZDogZGVib3VuY2VkX2ZldGNoRm4sIGZvcmNlOiBmb3JjZV9mZXRjaCB9ID1cbiAgICBkZWJvdW5jZUFzeW5jR2VuZXJhdG9yKGZldGNoRm4sIGRlbGF5KTtcbiAgcmV0dXJuIHtcbiAgICBleHRlbnNpb246IGFjY2VwdF9zaG9ydGN1dFxuICAgICAgPyBbXG4gICAgICAgICAgSW5saW5lU3VnZ2VzdGlvblN0YXRlLFxuICAgICAgICAgIGZldGNoU3VnZ2VzdGlvbihkZWJvdW5jZWRfZmV0Y2hGbiksXG4gICAgICAgICAgcmVuZGVySW5saW5lU3VnZ2VzdGlvblBsdWdpbixcbiAgICAgICAgICBuZXcgaW5saW5lU3VnZ2VzdGlvbktleW1hcChcbiAgICAgICAgICAgIG9wdGlvbnMuY29udGludWVfc3VnZ2VzdGluZyA/IGZldGNoRm4gOiBudWxsLFxuICAgICAgICAgICAgYWNjZXB0X3Nob3J0Y3V0XG4gICAgICAgICAgKS5rZXltYXAsXG4gICAgICAgIF1cbiAgICAgIDogW1xuICAgICAgICAgIElubGluZVN1Z2dlc3Rpb25TdGF0ZSxcbiAgICAgICAgICBmZXRjaFN1Z2dlc3Rpb24oZGVib3VuY2VkX2ZldGNoRm4pLFxuICAgICAgICAgIHJlbmRlcklubGluZVN1Z2dlc3Rpb25QbHVnaW4sXG4gICAgICAgIF0sXG4gICAgZm9yY2VfZmV0Y2g6IGZvcmNlX2ZldGNoLFxuICB9O1xufVxuIiwgImltcG9ydCB7IFN1Z2dlc3Rpb24gfSBmcm9tIFwiY29kZW1pcnJvci1jb21wYW5pb24tZXh0ZW5zaW9uXCI7XG5cbi8vIENvbXBsZXRlciBpbnRlcmZhY2UgZm9yIGFpIGludGVncmF0aW9uc1xuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0ZXIge1xuICAgIGdlbmVyYXRlOiAocHJlZml4OiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nKSA9PiBBc3luY0dlbmVyYXRvcjxTdWdnZXN0aW9uPjtcbiAgICBsb2FkOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAgIGFib3J0OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZW51bSBQcm92aWRlcklkIHtcbiAgICBPTExBTUEgPSBcIm9sbGFtYVwiLFxuICAgIE9QRU5BSSA9IFwib3BlbmFpXCIsXG59XG5cbi8vIFByb3ZpZGVyIGludGVyZmFjZSBmb3IgYWkgcHJvdmlkZXJzXG5leHBvcnQgaW50ZXJmYWNlIFByb3ZpZGVyIHtcbiAgICBpZDogUHJvdmlkZXJJZDtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICBnZXRNb2RlbHM6ICgpID0+IFByb21pc2U8c3RyaW5nW10+O1xuICAgIGdldFNldHRpbmdzQ29tcG9uZW50OiAocGx1Z2luOiBhbnksIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCkgPT4gdm9pZDtcbiAgICBnZXRDb21wbGV0ZXI6IChzZXR0aW5nczogYW55KSA9PiBDb21wbGV0ZXI7XG59XG5cbi8vIExpc3Qgb2YgcHJvdmlkZXJzIHdpdGggdGhlaXIgZGlzcGxheSBuYW1lIGFuZCBkZXNjcmlwdGlvblxuZXhwb3J0IGNvbnN0IFBST1ZJREVSUyA9IFtcbiAgICB7XG4gICAgICAgIGlkOiBQcm92aWRlcklkLk9MTEFNQSxcbiAgICAgICAgbmFtZTogXCJPbGxhbWFcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWQ6IFByb3ZpZGVySWQuT1BFTkFJLFxuICAgICAgICBuYW1lOiBcIk9wZW4gQUlcIixcbiAgICB9LFxuXSIsICIvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cbnZhciBnID1cbiAgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzKSB8fFxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsKSB8fFxuICB7fVxuXG52YXIgc3VwcG9ydCA9IHtcbiAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBnLFxuICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gZyAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgYmxvYjpcbiAgICAnRmlsZVJlYWRlcicgaW4gZyAmJlxuICAgICdCbG9iJyBpbiBnICYmXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBnLFxuICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBnXG59XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxufVxuXG5pZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgXVxuXG4gIHZhciBpc0FycmF5QnVmZmVyVmlldyA9XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICB9XG4gIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+IV0vaS50ZXN0KG5hbWUpIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWU6IFwiJyArIG5hbWUgKyAnXCInKVxuICB9XG4gIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbmZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdGhpcy5tYXAgPSB7fVxuXG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgfSwgdGhpcylcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgaWYgKGhlYWRlci5sZW5ndGggIT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIZWFkZXJzIGNvbnN0cnVjdG9yOiBleHBlY3RlZCBuYW1lL3ZhbHVlIHBhaXIgdG8gYmUgbGVuZ3RoIDIsIGZvdW5kJyArIGhlYWRlci5sZW5ndGgpXG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgfSwgdGhpcylcbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICB9XG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKG5hbWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIGl0ZW1zLnB1c2godmFsdWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXNcbn1cblxuZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICBpZiAoYm9keS5fbm9Cb2R5KSByZXR1cm5cbiAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gIH1cbiAgYm9keS5ib2R5VXNlZCA9IHRydWVcbn1cblxuZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgIH1cbiAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB2YXIgbWF0Y2ggPSAvY2hhcnNldD0oW0EtWmEtejAtOV8tXSspLy5leGVjKGJsb2IudHlwZSlcbiAgdmFyIGVuY29kaW5nID0gbWF0Y2ggPyBtYXRjaFsxXSA6ICd1dGYtOCdcbiAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYiwgZW5jb2RpbmcpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgfVxuICByZXR1cm4gY2hhcnMuam9pbignJylcbn1cblxuZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gIGlmIChidWYuc2xpY2UpIHtcbiAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gIH0gZWxzZSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aClcbiAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICB9XG59XG5cbmZ1bmN0aW9uIEJvZHkoKSB7XG4gIHRoaXMuYm9keVVzZWQgPSBmYWxzZVxuXG4gIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgIC8qXG4gICAgICBmZXRjaC1tb2NrIHdyYXBzIHRoZSBSZXNwb25zZSBvYmplY3QgaW4gYW4gRVM2IFByb3h5IHRvXG4gICAgICBwcm92aWRlIHVzZWZ1bCB0ZXN0IGhhcm5lc3MgZmVhdHVyZXMgc3VjaCBhcyBmbHVzaC4gSG93ZXZlciwgb25cbiAgICAgIEVTNSBicm93c2VycyB3aXRob3V0IGZldGNoIG9yIFByb3h5IHN1cHBvcnQgcG9sbHlmaWxscyBtdXN0IGJlIHVzZWQ7XG4gICAgICB0aGUgcHJveHktcG9sbHlmaWxsIGlzIHVuYWJsZSB0byBwcm94eSBhbiBhdHRyaWJ1dGUgdW5sZXNzIGl0IGV4aXN0c1xuICAgICAgb24gdGhlIG9iamVjdCBiZWZvcmUgdGhlIFByb3h5IGlzIGNyZWF0ZWQuIFRoaXMgY2hhbmdlIGVuc3VyZXNcbiAgICAgIFJlc3BvbnNlLmJvZHlVc2VkIGV4aXN0cyBvbiB0aGUgaW5zdGFuY2UsIHdoaWxlIG1haW50YWluaW5nIHRoZVxuICAgICAgc2VtYW50aWMgb2Ygc2V0dGluZyBSZXF1ZXN0LmJvZHlVc2VkIGluIHRoZSBjb25zdHJ1Y3RvciBiZWZvcmVcbiAgICAgIF9pbml0Qm9keSBpcyBjYWxsZWQuXG4gICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICB0aGlzLmJvZHlVc2VkID0gdGhpcy5ib2R5VXNlZFxuICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgIGlmICghYm9keSkge1xuICAgICAgdGhpcy5fbm9Cb2R5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcilcbiAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgaXNDb25zdW1lZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAoaXNDb25zdW1lZCkge1xuICAgICAgICByZXR1cm4gaXNDb25zdW1lZFxuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5fYm9keUFycmF5QnVmZmVyKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0ICsgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgYXMgQXJyYXlCdWZmZXInKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbnZhciBtZXRob2RzID0gWydDT05ORUNUJywgJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BBVENIJywgJ1BPU1QnLCAnUFVUJywgJ1RSQUNFJ11cblxuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcblxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgIH1cbiAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICB0aGlzLnNpZ25hbCA9IGlucHV0LnNpZ25hbFxuICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICB9XG5cbiAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nXG4gIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgfVxuICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gIHRoaXMuc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgfHwgdGhpcy5zaWduYWwgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ0Fib3J0Q29udHJvbGxlcicgaW4gZykge1xuICAgICAgdmFyIGN0cmwgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICByZXR1cm4gY3RybC5zaWduYWw7XG4gICAgfVxuICB9KCkpO1xuICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gIH1cbiAgdGhpcy5faW5pdEJvZHkoYm9keSlcblxuICBpZiAodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICBpZiAob3B0aW9ucy5jYWNoZSA9PT0gJ25vLXN0b3JlJyB8fCBvcHRpb25zLmNhY2hlID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAvLyBTZWFyY2ggZm9yIGEgJ18nIHBhcmFtZXRlciBpbiB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICB2YXIgcmVQYXJhbVNlYXJjaCA9IC8oWz8mXSlfPVteJl0qL1xuICAgICAgaWYgKHJlUGFyYW1TZWFyY2gudGVzdCh0aGlzLnVybCkpIHtcbiAgICAgICAgLy8gSWYgaXQgYWxyZWFkeSBleGlzdHMgdGhlbiBzZXQgdGhlIHZhbHVlIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnJlcGxhY2UocmVQYXJhbVNlYXJjaCwgJyQxXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGEgbmV3ICdfJyBwYXJhbWV0ZXIgdG8gdGhlIGVuZCB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgdmFyIHJlUXVlcnlTdHJpbmcgPSAvXFw/L1xuICAgICAgICB0aGlzLnVybCArPSAocmVRdWVyeVN0cmluZy50ZXN0KHRoaXMudXJsKSA/ICcmJyA6ICc/JykgKyAnXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG59XG5cbmZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgYm9keVxuICAgIC50cmltKClcbiAgICAuc3BsaXQoJyYnKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICByZXR1cm4gZm9ybVxufVxuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcbiAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKVxuICAvLyBBdm9pZGluZyBzcGxpdCB2aWEgcmVnZXggdG8gd29yayBhcm91bmQgYSBjb21tb24gSUUxMSBidWcgd2l0aCB0aGUgY29yZS1qcyAzLjYuMCByZWdleCBwb2x5ZmlsbFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoL2lzc3Vlcy83NDhcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzc1MVxuICBwcmVQcm9jZXNzZWRIZWFkZXJzXG4gICAgLnNwbGl0KCdcXHInKVxuICAgIC5tYXAoZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICByZXR1cm4gaGVhZGVyLmluZGV4T2YoJ1xcbicpID09PSAwID8gaGVhZGVyLnN1YnN0cigxLCBoZWFkZXIubGVuZ3RoKSA6IGhlYWRlclxuICAgIH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdSZXNwb25zZSAnICsgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbkJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuZXhwb3J0IGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXNcbiAgaWYgKHRoaXMuc3RhdHVzIDwgMjAwIHx8IHRoaXMuc3RhdHVzID4gNTk5KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNwb25zZSc6IFRoZSBzdGF0dXMgcHJvdmlkZWQgKDApIGlzIG91dHNpZGUgdGhlIHJhbmdlIFsyMDAsIDU5OV0uXCIpXG4gIH1cbiAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHQgPT09IHVuZGVmaW5lZCA/ICcnIDogJycgKyBvcHRpb25zLnN0YXR1c1RleHRcbiAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxufVxuXG5Cb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG5SZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgdXJsOiB0aGlzLnVybFxuICB9KVxufVxuXG5SZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMjAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gIHJlc3BvbnNlLm9rID0gZmFsc2VcbiAgcmVzcG9uc2Uuc3RhdHVzID0gMFxuICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxudmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cblJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxufVxuXG5leHBvcnQgdmFyIERPTUV4Y2VwdGlvbiA9IGcuRE9NRXhjZXB0aW9uXG50cnkge1xuICBuZXcgRE9NRXhjZXB0aW9uKClcbn0gY2F0Y2ggKGVycikge1xuICBET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKVxuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFja1xuICB9XG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERPTUV4Y2VwdGlvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgeGhyLmFib3J0KClcbiAgICB9XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICB9XG4gICAgICAvLyBUaGlzIGNoZWNrIGlmIHNwZWNpZmljYWxseSBmb3Igd2hlbiBhIHVzZXIgZmV0Y2hlcyBhIGZpbGUgbG9jYWxseSBmcm9tIHRoZSBmaWxlIHN5c3RlbVxuICAgICAgLy8gT25seSBpZiB0aGUgc3RhdHVzIGlzIG91dCBvZiBhIG5vcm1hbCByYW5nZVxuICAgICAgaWYgKHJlcXVlc3QudXJsLmluZGV4T2YoJ2ZpbGU6Ly8nKSA9PT0gMCAmJiAoeGhyLnN0YXR1cyA8IDIwMCB8fCB4aHIuc3RhdHVzID4gNTk5KSkge1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IDIwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgdGltZWQgb3V0JykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFVybCh1cmwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cmwgPT09ICcnICYmIGcubG9jYXRpb24uaHJlZiA/IGcubG9jYXRpb24uaHJlZiA6IHVybFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdXJsXG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIGZpeFVybChyZXF1ZXN0LnVybCksIHRydWUpXG5cbiAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKSB7XG4gICAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHN1cHBvcnQuYXJyYXlCdWZmZXJcbiAgICAgICkge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbml0ICYmIHR5cGVvZiBpbml0LmhlYWRlcnMgPT09ICdvYmplY3QnICYmICEoaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycyB8fCAoZy5IZWFkZXJzICYmIGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIGcuSGVhZGVycykpKSB7XG4gICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaXQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWVzLnB1c2gobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgbm9ybWFsaXplVmFsdWUoaW5pdC5oZWFkZXJzW25hbWVdKSlcbiAgICAgIH0pXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcblxuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICB9KVxufVxuXG5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcblxuaWYgKCFnLmZldGNoKSB7XG4gIGcuZmV0Y2ggPSBmZXRjaFxuICBnLkhlYWRlcnMgPSBIZWFkZXJzXG4gIGcuUmVxdWVzdCA9IFJlcXVlc3RcbiAgZy5SZXNwb25zZSA9IFJlc3BvbnNlXG59XG4iLCAiaW1wb3J0ICd3aGF0d2ctZmV0Y2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gXCIwLjUuMTFcIjtcblxudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQxKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGVycm9yLCBzdGF0dXNfY29kZSkge1xuICAgIHN1cGVyKGVycm9yKTtcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5zdGF0dXNfY29kZSA9IHN0YXR1c19jb2RlO1xuICAgIHRoaXMubmFtZSA9IFwiUmVzcG9uc2VFcnJvclwiO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVzcG9uc2VFcnJvcik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHtcbiAgY29uc3RydWN0b3IoYWJvcnRDb250cm9sbGVyLCBpdHIsIGRvbmVDYWxsYmFjaykge1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImFib3J0Q29udHJvbGxlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpdHJcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiZG9uZUNhbGxiYWNrXCIpO1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xuICAgIHRoaXMuaXRyID0gaXRyO1xuICAgIHRoaXMuZG9uZUNhbGxiYWNrID0gZG9uZUNhbGxiYWNrO1xuICB9XG4gIGFib3J0KCkge1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBtZXNzYWdlIG9mIHRoaXMuaXRyKSB7XG4gICAgICBpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgfVxuICAgICAgeWllbGQgbWVzc2FnZTtcbiAgICAgIGlmIChtZXNzYWdlLmRvbmUgfHwgbWVzc2FnZS5zdGF0dXMgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgIHRoaXMuZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCByZWNlaXZlIGRvbmUgb3Igc3VjY2VzcyByZXNwb25zZSBpbiBzdHJlYW0uXCIpO1xuICB9XG59XG5jb25zdCBjaGVja09rID0gYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbWVzc2FnZSA9IGBFcnJvciAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICBsZXQgZXJyb3JEYXRhID0gbnVsbDtcbiAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpPy5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICB0cnkge1xuICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgbWVzc2FnZSA9IGVycm9yRGF0YS5lcnJvciB8fCBtZXNzYWdlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBlcnJvciByZXNwb25zZSBhcyBKU09OXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCJHZXR0aW5nIHRleHQgZnJvbSByZXNwb25zZVwiKTtcbiAgICAgIGNvbnN0IHRleHRSZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIG1lc3NhZ2UgPSB0ZXh0UmVzcG9uc2UgfHwgbWVzc2FnZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gZ2V0IHRleHQgZnJvbSBlcnJvciByZXNwb25zZVwiKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IFJlc3BvbnNlRXJyb3IobWVzc2FnZSwgcmVzcG9uc2Uuc3RhdHVzKTtcbn07XG5mdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hdmlnYXRvcikge1xuICAgIHJldHVybiBgJHt3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtLnRvTG93ZXJDYXNlKCl9IEJyb3dzZXIvJHtuYXZpZ2F0b3IudXNlckFnZW50fTtgO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGAke3Byb2Nlc3MuYXJjaH0gJHtwcm9jZXNzLnBsYXRmb3JtfSBOb2RlLmpzLyR7cHJvY2Vzcy52ZXJzaW9ufWA7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5jb25zdCBmZXRjaFdpdGhIZWFkZXJzID0gYXN5bmMgKGZldGNoLCB1cmwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIFwiVXNlci1BZ2VudFwiOiBgb2xsYW1hLWpzLyR7dmVyc2lvbn0gKCR7Z2V0UGxhdGZvcm0oKX0pYFxuICB9O1xuICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IHt9O1xuICB9XG4gIGNvbnN0IGN1c3RvbUhlYWRlcnMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5oZWFkZXJzKS5maWx0ZXIoKFtrZXldKSA9PiAhT2JqZWN0LmtleXMoZGVmYXVsdEhlYWRlcnMpLnNvbWUoKGRlZmF1bHRLZXkpID0+IGRlZmF1bHRLZXkudG9Mb3dlckNhc2UoKSA9PT0ga2V5LnRvTG93ZXJDYXNlKCkpKVxuICApO1xuICBvcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgLi4uZGVmYXVsdEhlYWRlcnMsXG4gICAgLi4uY3VzdG9tSGVhZGVyc1xuICB9O1xuICByZXR1cm4gZmV0Y2godXJsLCBvcHRpb25zKTtcbn07XG5jb25zdCBnZXQgPSBhc3luYyAoZmV0Y2gsIGhvc3QsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhIZWFkZXJzKGZldGNoLCBob3N0LCB7XG4gICAgaGVhZGVyczogb3B0aW9ucz8uaGVhZGVyc1xuICB9KTtcbiAgYXdhaXQgY2hlY2tPayhyZXNwb25zZSk7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG5jb25zdCBoZWFkID0gYXN5bmMgKGZldGNoLCBob3N0KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoSGVhZGVycyhmZXRjaCwgaG9zdCwge1xuICAgIG1ldGhvZDogXCJIRUFEXCJcbiAgfSk7XG4gIGF3YWl0IGNoZWNrT2socmVzcG9uc2UpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuY29uc3QgcG9zdCA9IGFzeW5jIChmZXRjaCwgaG9zdCwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBpc1JlY29yZCA9IChpbnB1dCkgPT4ge1xuICAgIHJldHVybiBpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXQpO1xuICB9O1xuICBjb25zdCBmb3JtYXR0ZWREYXRhID0gaXNSZWNvcmQoZGF0YSkgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IGRhdGE7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoSGVhZGVycyhmZXRjaCwgaG9zdCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogZm9ybWF0dGVkRGF0YSxcbiAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCxcbiAgICBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzXG4gIH0pO1xuICBhd2FpdCBjaGVja09rKHJlc3BvbnNlKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbmNvbnN0IGRlbCA9IGFzeW5jIChmZXRjaCwgaG9zdCwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aEhlYWRlcnMoZmV0Y2gsIGhvc3QsIHtcbiAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgaGVhZGVyczogb3B0aW9ucz8uaGVhZGVyc1xuICB9KTtcbiAgYXdhaXQgY2hlY2tPayhyZXNwb25zZSk7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG5jb25zdCBwYXJzZUpTT04gPSBhc3luYyBmdW5jdGlvbiogKGl0cikge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4gIGxldCBidWZmZXIgPSBcIlwiO1xuICBjb25zdCByZWFkZXIgPSBpdHIuZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZTogY2h1bmsgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgIGNvbnN0IHBhcnRzID0gYnVmZmVyLnNwbGl0KFwiXFxuXCIpO1xuICAgIGJ1ZmZlciA9IHBhcnRzLnBvcCgpID8/IFwiXCI7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCBKU09OLnBhcnNlKHBhcnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiaW52YWxpZCBqc29uOiBcIiwgcGFydCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcGFydCBvZiBidWZmZXIuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChwKSA9PiBwICE9PSBcIlwiKSkge1xuICAgIHRyeSB7XG4gICAgICB5aWVsZCBKU09OLnBhcnNlKHBhcnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJpbnZhbGlkIGpzb246IFwiLCBwYXJ0KTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBmb3JtYXRIb3N0ID0gKGhvc3QpID0+IHtcbiAgaWYgKCFob3N0KSB7XG4gICAgcmV0dXJuIFwiaHR0cDovLzEyNy4wLjAuMToxMTQzNFwiO1xuICB9XG4gIGxldCBpc0V4cGxpY2l0UHJvdG9jb2wgPSBob3N0LmluY2x1ZGVzKFwiOi8vXCIpO1xuICBpZiAoaG9zdC5zdGFydHNXaXRoKFwiOlwiKSkge1xuICAgIGhvc3QgPSBgaHR0cDovLzEyNy4wLjAuMSR7aG9zdH1gO1xuICAgIGlzRXhwbGljaXRQcm90b2NvbCA9IHRydWU7XG4gIH1cbiAgaWYgKCFpc0V4cGxpY2l0UHJvdG9jb2wpIHtcbiAgICBob3N0ID0gYGh0dHA6Ly8ke2hvc3R9YDtcbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGhvc3QpO1xuICBsZXQgcG9ydCA9IHVybC5wb3J0O1xuICBpZiAoIXBvcnQpIHtcbiAgICBpZiAoIWlzRXhwbGljaXRQcm90b2NvbCkge1xuICAgICAgcG9ydCA9IFwiMTE0MzRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9ydCA9IHVybC5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiNDQzXCIgOiBcIjgwXCI7XG4gICAgfVxuICB9XG4gIGxldCBmb3JtYXR0ZWRIb3N0ID0gYCR7dXJsLnByb3RvY29sfS8vJHt1cmwuaG9zdG5hbWV9OiR7cG9ydH0ke3VybC5wYXRobmFtZX1gO1xuICBpZiAoZm9ybWF0dGVkSG9zdC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICBmb3JtYXR0ZWRIb3N0ID0gZm9ybWF0dGVkSG9zdC5zbGljZSgwLCAtMSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdHRlZEhvc3Q7XG59O1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5sZXQgT2xsYW1hJDEgPSBjbGFzcyBPbGxhbWEge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29uZmlnXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmZXRjaFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib25nb2luZ1N0cmVhbWVkUmVxdWVzdHNcIiwgW10pO1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgaG9zdDogXCJcIixcbiAgICAgIGhlYWRlcnM6IGNvbmZpZz8uaGVhZGVyc1xuICAgIH07XG4gICAgaWYgKCFjb25maWc/LnByb3h5KSB7XG4gICAgICB0aGlzLmNvbmZpZy5ob3N0ID0gZm9ybWF0SG9zdChjb25maWc/Lmhvc3QgPz8gXCJodHRwOi8vMTI3LjAuMC4xOjExNDM0XCIpO1xuICAgIH1cbiAgICB0aGlzLmZldGNoID0gY29uZmlnPy5mZXRjaCA/PyBmZXRjaDtcbiAgfVxuICAvLyBBYm9ydCBhbnkgb25nb2luZyBzdHJlYW1lZCByZXF1ZXN0cyB0byBPbGxhbWFcbiAgYWJvcnQoKSB7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICB9XG4gICAgdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cy5sZW5ndGggPSAwO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYSByZXF1ZXN0IHRvIHRoZSBPbGxhbWEgc2VydmVyLiBJZiB0aGUgcmVxdWVzdCBpcyBzdHJlYW1hYmxlLCBpdCB3aWxsIHJldHVybiBhXG4gICAqIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgdGhlIHJlc3BvbnNlIG1lc3NhZ2VzLiBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSByZXNwb25zZVxuICAgKiBvYmplY3QuXG4gICAqIEBwYXJhbSBlbmRwb2ludCB7c3RyaW5nfSAtIFRoZSBlbmRwb2ludCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7b2JqZWN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdCB0byBzZW5kIHRvIHRoZSBlbmRwb2ludC5cbiAgICogQHByb3RlY3RlZCB7VCB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8VD59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvciBhIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHNcbiAgICogcmVzcG9uc2UgbWVzc2FnZXMuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIHRoZSByZXNwb25zZSBib2R5IGlzIG1pc3Npbmcgb3IgaWYgdGhlIHJlc3BvbnNlIGlzIGFuIGVycm9yLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxUPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvciBhIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgdGhlIHN0cmVhbWVkIHJlc3BvbnNlLlxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KGVuZHBvaW50LCByZXF1ZXN0KSB7XG4gICAgcmVxdWVzdC5zdHJlYW0gPSByZXF1ZXN0LnN0cmVhbSA/PyBmYWxzZTtcbiAgICBjb25zdCBob3N0ID0gYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpLyR7ZW5kcG9pbnR9YDtcbiAgICBpZiAocmVxdWVzdC5zdHJlYW0pIHtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgaG9zdCwgcmVxdWVzdCwge1xuICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZTIuYm9keSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGJvZHlcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBpdHIgPSBwYXJzZUpTT04ocmVzcG9uc2UyLmJvZHkpO1xuICAgICAgY29uc3QgYWJvcnRhYmxlQXN5bmNJdGVyYXRvciA9IG5ldyBBYm9ydGFibGVBc3luY0l0ZXJhdG9yKFxuICAgICAgICBhYm9ydENvbnRyb2xsZXIsXG4gICAgICAgIGl0cixcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzLmluZGV4T2YoYWJvcnRhYmxlQXN5bmNJdGVyYXRvcik7XG4gICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cy5wdXNoKGFib3J0YWJsZUFzeW5jSXRlcmF0b3IpO1xuICAgICAgcmV0dXJuIGFib3J0YWJsZUFzeW5jSXRlcmF0b3I7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBob3N0LCByZXF1ZXN0LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgKiBFbmNvZGVzIGFuIGltYWdlIHRvIGJhc2U2NCBpZiBpdCBpcyBhIFVpbnQ4QXJyYXkuXG4gICogQHBhcmFtIGltYWdlIHtVaW50OEFycmF5IHwgc3RyaW5nfSAtIFRoZSBpbWFnZSB0byBlbmNvZGUuXG4gICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBUaGUgYmFzZTY0IGVuY29kZWQgaW1hZ2UuXG4gICovXG4gIGFzeW5jIGVuY29kZUltYWdlKGltYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBpbWFnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGltYWdlKTtcbiAgICAgIGxldCBieXRlU3RyaW5nID0gXCJcIjtcbiAgICAgIGNvbnN0IGxlbiA9IHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYnl0ZVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVpbnQ4QXJyYXlbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ0b2EoYnl0ZVN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcmVzcG9uc2UgZnJvbSBhIHRleHQgcHJvbXB0LlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7R2VuZXJhdGVSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8R2VuZXJhdGVSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8R2VuZXJhdGVSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3JcbiAgICogYW4gQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlKHJlcXVlc3QpIHtcbiAgICBpZiAocmVxdWVzdC5pbWFnZXMpIHtcbiAgICAgIHJlcXVlc3QuaW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdC5pbWFnZXMubWFwKHRoaXMuZW5jb2RlSW1hZ2UuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJnZW5lcmF0ZVwiLCByZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogQ2hhdHMgd2l0aCB0aGUgbW9kZWwuIFRoZSByZXF1ZXN0IG9iamVjdCBjYW4gY29udGFpbiBtZXNzYWdlcyB3aXRoIGltYWdlcyB0aGF0IGFyZSBlaXRoZXJcbiAgICogVWludDhBcnJheXMgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5ncy4gVGhlIGltYWdlcyB3aWxsIGJlIGJhc2U2NCBlbmNvZGVkIGJlZm9yZSBzZW5kaW5nIHRoZVxuICAgKiByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7Q2hhdFJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGF0UmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPENoYXRSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYW5cbiAgICogQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIGNoYXQocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0Lm1lc3NhZ2VzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcmVxdWVzdC5tZXNzYWdlcykge1xuICAgICAgICBpZiAobWVzc2FnZS5pbWFnZXMpIHtcbiAgICAgICAgICBtZXNzYWdlLmltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgbWVzc2FnZS5pbWFnZXMubWFwKHRoaXMuZW5jb2RlSW1hZ2UuYmluZCh0aGlzKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcImNoYXRcIiwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbW9kZWwgZnJvbSBhIHN0cmVhbSBvZiBkYXRhLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7Q3JlYXRlUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFByb2dyZXNzUmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFByb2dyZXNzUmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGEgc3RyZWFtIG9mIHByb2dyZXNzIHJlc3BvbnNlcy5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZShyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwiY3JlYXRlXCIsIHtcbiAgICAgIG5hbWU6IHJlcXVlc3QubW9kZWwsXG4gICAgICBzdHJlYW06IHJlcXVlc3Quc3RyZWFtLFxuICAgICAgbW9kZWxmaWxlOiByZXF1ZXN0Lm1vZGVsZmlsZSxcbiAgICAgIHF1YW50aXplOiByZXF1ZXN0LnF1YW50aXplXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1bGxzIGEgbW9kZWwgZnJvbSB0aGUgT2xsYW1hIHJlZ2lzdHJ5LiBUaGUgcmVxdWVzdCBvYmplY3QgY2FuIGNvbnRhaW4gYSBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSBpZiB0aGVcbiAgICogcmVzcG9uc2Ugc2hvdWxkIGJlIHN0cmVhbWVkLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7UHVsbFJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm9ncmVzc1Jlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxQcm9ncmVzc1Jlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvclxuICAgKiBhbiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgcHVsbChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwicHVsbFwiLCB7XG4gICAgICBuYW1lOiByZXF1ZXN0Lm1vZGVsLFxuICAgICAgc3RyZWFtOiByZXF1ZXN0LnN0cmVhbSxcbiAgICAgIGluc2VjdXJlOiByZXF1ZXN0Lmluc2VjdXJlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1c2hlcyBhIG1vZGVsIHRvIHRoZSBPbGxhbWEgcmVnaXN0cnkuIFRoZSByZXF1ZXN0IG9iamVjdCBjYW4gY29udGFpbiBhIHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIGlmIHRoZVxuICAgKiByZXNwb25zZSBzaG91bGQgYmUgc3RyZWFtZWQuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtQdXNoUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFByb2dyZXNzUmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFByb2dyZXNzUmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yXG4gICAqIGFuIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgcmVzcG9uc2UgbWVzc2FnZXMuXG4gICAqL1xuICBhc3luYyBwdXNoKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJwdXNoXCIsIHtcbiAgICAgIG5hbWU6IHJlcXVlc3QubW9kZWwsXG4gICAgICBzdHJlYW06IHJlcXVlc3Quc3RyZWFtLFxuICAgICAgaW5zZWN1cmU6IHJlcXVlc3QuaW5zZWN1cmVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIG1vZGVsIGZyb20gdGhlIHNlcnZlci4gVGhlIHJlcXVlc3Qgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBuYW1lIG9mIHRoZSBtb2RlbCB0b1xuICAgKiBkZWxldGUuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtEZWxldGVSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8U3RhdHVzUmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBkZWxldGUocmVxdWVzdCkge1xuICAgIGF3YWl0IGRlbChcbiAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvZGVsZXRlYCxcbiAgICAgIHsgbmFtZTogcmVxdWVzdC5tb2RlbCB9LFxuICAgICAgeyBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzIH1cbiAgICApO1xuICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIgfTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGEgbW9kZWwgZnJvbSBvbmUgbmFtZSB0byBhbm90aGVyLiBUaGUgcmVxdWVzdCBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG5hbWUgb2YgdGhlXG4gICAqIG1vZGVsIHRvIGNvcHkgYW5kIHRoZSBuZXcgbmFtZS5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0NvcHlSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8U3RhdHVzUmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBjb3B5KHJlcXVlc3QpIHtcbiAgICBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9jb3B5YCwgeyAuLi5yZXF1ZXN0IH0sIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH07XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIHRoZSBtb2RlbHMgb24gdGhlIHNlcnZlci5cbiAgICogQHJldHVybnMge1Byb21pc2U8TGlzdFJlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgcmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nLlxuICAgKi9cbiAgYXN5bmMgbGlzdCgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvdGFnc2AsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgbWV0YWRhdGEgb2YgYSBtb2RlbC4gVGhlIHJlcXVlc3Qgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBuYW1lIG9mIHRoZSBtb2RlbC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge1Nob3dSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8U2hvd1Jlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgc2hvdyhyZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9zaG93YCwge1xuICAgICAgLi4ucmVxdWVzdFxuICAgIH0sIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBFbWJlZHMgdGV4dCBpbnB1dCBpbnRvIHZlY3RvcnMuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtFbWJlZFJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbWJlZFJlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgZW1iZWQocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvZW1iZWRgLCB7XG4gICAgICAuLi5yZXF1ZXN0XG4gICAgfSwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVtYmVkcyBhIHRleHQgcHJvbXB0IGludG8gYSB2ZWN0b3IuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtFbWJlZGRpbmdzUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEVtYmVkZGluZ3NSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGVtYmVkZGluZ3MocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvZW1iZWRkaW5nc2AsIHtcbiAgICAgIC4uLnJlcXVlc3RcbiAgICB9LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgdGhlIHJ1bm5pbmcgbW9kZWxzIG9uIHRoZSBzZXJ2ZXJcbiAgICogQHJldHVybnMge1Byb21pc2U8TGlzdFJlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgcmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nLlxuICAgKi9cbiAgYXN5bmMgcHMoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL3BzYCwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbn07XG5jb25zdCBicm93c2VyID0gbmV3IE9sbGFtYSQxKCk7XG5cbmV4cG9ydCB7IE9sbGFtYSQxIGFzIE8sIGJyb3dzZXIgYXMgYiwgaGVhZCBhcyBoLCBwb3N0IGFzIHAgfTtcbiIsICJpbXBvcnQgeyBPIGFzIE9sbGFtYSQxLCBoIGFzIGhlYWQsIHAgYXMgcG9zdCB9IGZyb20gJy4vc2hhcmVkL29sbGFtYS5jZGRiYzg1Yi5tanMnO1xuaW1wb3J0IGZzLCB7IHByb21pc2VzLCBjcmVhdGVSZWFkU3RyZWFtIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgcmVzb2x2ZSwgam9pbiwgZGlybmFtZSB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSAnb3MnO1xuaW1wb3J0ICd3aGF0d2ctZmV0Y2gnO1xuXG5jbGFzcyBPbGxhbWEgZXh0ZW5kcyBPbGxhbWEkMSB7XG4gIGFzeW5jIGVuY29kZUltYWdlKGltYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBpbWFnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGltYWdlKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKGltYWdlKSkge1xuICAgICAgICBjb25zdCBmaWxlQnVmZmVyID0gYXdhaXQgcHJvbWlzZXMucmVhZEZpbGUocmVzb2x2ZShpbWFnZSkpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oZmlsZUJ1ZmZlcikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgdGhlIG1vZGVsZmlsZSBhbmQgcmVwbGFjZSB0aGUgRlJPTSBhbmQgQURBUFRFUiBjb21tYW5kcyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGJsb2IgaGFzaGVzLlxuICAgKiBAcGFyYW0gbW9kZWxmaWxlIHtzdHJpbmd9IC0gVGhlIG1vZGVsZmlsZSBjb250ZW50XG4gICAqIEBwYXJhbSBtZkRpciB7c3RyaW5nfSAtIFRoZSBkaXJlY3Rvcnkgb2YgdGhlIG1vZGVsZmlsZVxuICAgKiBAcHJpdmF0ZSBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIHBhcnNlTW9kZWxmaWxlKG1vZGVsZmlsZSwgbWZEaXIgPSBwcm9jZXNzLmN3ZCgpKSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgY29uc3QgbGluZXMgPSBtb2RlbGZpbGUuc3BsaXQoXCJcXG5cIik7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBjb25zdCBbY29tbWFuZCwgYXJnc10gPSBsaW5lLnNwbGl0KFwiIFwiLCAyKTtcbiAgICAgIGlmIChbXCJGUk9NXCIsIFwiQURBUFRFUlwiXS5pbmNsdWRlcyhjb21tYW5kLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLnJlc29sdmVQYXRoKGFyZ3MudHJpbSgpLCBtZkRpcik7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmZpbGVFeGlzdHMocGF0aCkpIHtcbiAgICAgICAgICBvdXQucHVzaChgJHtjb21tYW5kfSBAJHthd2FpdCB0aGlzLmNyZWF0ZUJsb2IocGF0aCl9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0LnB1c2goYCR7Y29tbWFuZH0gJHthcmdzfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dC5qb2luKFwiXFxuXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBwYXRoIHRvIGFuIGFic29sdXRlIHBhdGguXG4gICAqIEBwYXJhbSBpbnB1dFBhdGgge3N0cmluZ30gLSBUaGUgaW5wdXQgcGF0aFxuICAgKiBAcGFyYW0gbWZEaXIge3N0cmluZ30gLSBUaGUgZGlyZWN0b3J5IG9mIHRoZSBtb2RlbGZpbGVcbiAgICogQHByaXZhdGUgQGludGVybmFsXG4gICAqL1xuICByZXNvbHZlUGF0aChpbnB1dFBhdGgsIG1mRGlyKSB7XG4gICAgaWYgKGlucHV0UGF0aC5zdGFydHNXaXRoKFwiflwiKSkge1xuICAgICAgcmV0dXJuIGpvaW4oaG9tZWRpcigpLCBpbnB1dFBhdGguc2xpY2UoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZShtZkRpciwgaW5wdXRQYXRoKTtcbiAgfVxuICAvKipcbiAgICogY2hlY2tzIGlmIGEgZmlsZSBleGlzdHNcbiAgICogQHBhcmFtIHBhdGgge3N0cmluZ30gLSBUaGUgcGF0aCB0byB0aGUgZmlsZVxuICAgKiBAcHJpdmF0ZSBAaW50ZXJuYWxcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IC0gV2hldGhlciB0aGUgZmlsZSBleGlzdHMgb3Igbm90XG4gICAqL1xuICBhc3luYyBmaWxlRXhpc3RzKHBhdGgpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJvbWlzZXMuYWNjZXNzKHBhdGgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNyZWF0ZUJsb2IocGF0aCkge1xuICAgIGlmICh0eXBlb2YgUmVhZGFibGVTdHJlYW0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbWluZyB1cGxvYWRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbShwYXRoKTtcbiAgICBjb25zdCBzaGEyNTZzdW0gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZTIsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgaGFzaCA9IGNyZWF0ZUhhc2goXCJzaGEyNTZcIik7XG4gICAgICBmaWxlU3RyZWFtLm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4gaGFzaC51cGRhdGUoZGF0YSkpO1xuICAgICAgZmlsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiByZXNvbHZlMihoYXNoLmRpZ2VzdChcImhleFwiKSkpO1xuICAgICAgZmlsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgfSk7XG4gICAgY29uc3QgZGlnZXN0ID0gYHNoYTI1Njoke3NoYTI1NnN1bX1gO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBoZWFkKHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9ibG9icy8ke2RpZ2VzdH1gKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5pbmNsdWRlcyhcIjQwNFwiKSkge1xuICAgICAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgZmlsZVN0cmVhbS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbGVTdHJlYW0ub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHBvc3QoXG4gICAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgICBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvYmxvYnMvJHtkaWdlc3R9YCxcbiAgICAgICAgICByZWFkYWJsZVN0cmVhbVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZ2VzdDtcbiAgfVxuICBhc3luYyBjcmVhdGUocmVxdWVzdCkge1xuICAgIGxldCBtb2RlbGZpbGVDb250ZW50ID0gXCJcIjtcbiAgICBpZiAocmVxdWVzdC5wYXRoKSB7XG4gICAgICBtb2RlbGZpbGVDb250ZW50ID0gYXdhaXQgcHJvbWlzZXMucmVhZEZpbGUocmVxdWVzdC5wYXRoLCB7IGVuY29kaW5nOiBcInV0ZjhcIiB9KTtcbiAgICAgIG1vZGVsZmlsZUNvbnRlbnQgPSBhd2FpdCB0aGlzLnBhcnNlTW9kZWxmaWxlKFxuICAgICAgICBtb2RlbGZpbGVDb250ZW50LFxuICAgICAgICBkaXJuYW1lKHJlcXVlc3QucGF0aClcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0Lm1vZGVsZmlsZSkge1xuICAgICAgbW9kZWxmaWxlQ29udGVudCA9IGF3YWl0IHRoaXMucGFyc2VNb2RlbGZpbGUocmVxdWVzdC5tb2RlbGZpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHBhdGggb3IgbW9kZWxmaWxlIHRvIGNyZWF0ZSBhIG1vZGVsXCIpO1xuICAgIH1cbiAgICByZXF1ZXN0Lm1vZGVsZmlsZSA9IG1vZGVsZmlsZUNvbnRlbnQ7XG4gICAgaWYgKHJlcXVlc3Quc3RyZWFtKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY3JlYXRlKHJlcXVlc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuY3JlYXRlKHJlcXVlc3QpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgaW5kZXggPSBuZXcgT2xsYW1hKCk7XG5cbmV4cG9ydCB7IE9sbGFtYSwgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IENvbXBsZXRlciwgUHJvdmlkZXJJZCB9IGZyb20gXCIuLi9wcm92aWRlclwiO1xuaW1wb3J0IHsgT2xsYW1hIH0gZnJvbSBcIm9sbGFtYVwiO1xuaW1wb3J0IHsgU3VnZ2VzdGlvbiB9IGZyb20gXCJjb2RlbWlycm9yLWNvbXBhbmlvbi1leHRlbnNpb25cIjtcbmltcG9ydCB7IE9sbGFtYVNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2xsYW1hUHJvdmlkZXIgaW1wbGVtZW50cyBDb21wbGV0ZXIge1xuICAgIGlkID0gUHJvdmlkZXJJZC5PTExBTUE7XG4gICAgbmFtZSA9IFwiT2xsYW1hXCI7XG4gICAgZGVzY3JpcHRpb24gPSBcIk9sbGFtYSBtb2RlbCBmb3IgY29tcGxldGlvblwiO1xuICAgIG9sbGFtYTogT2xsYW1hXG4gICAgc2V0dGluZ3M6IE9sbGFtYVNldHRpbmdzO1xuXG4gICAgY29uc3RydWN0b3Ioc2V0dGluczogT2xsYW1hU2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbnM7XG4gICAgICAgIHRoaXMub2xsYW1hID0gbmV3IE9sbGFtYSh7IGhvc3Q6IHRoaXMuc2V0dGluZ3MuaG9zdCB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgbG9hZGluZyBvbGxhbWEgJHt0aGlzLnNldHRpbmdzLmhvc3R9IHByb3ZpZGVyYCk7XG4gICAgICAgIHRoaXMub2xsYW1hID0gbmV3IE9sbGFtYSh7IGhvc3Q6IHRoaXMuc2V0dGluZ3MuaG9zdCB9KTtcbiAgICB9XG5cbiAgICBhc3luYyAqZ2VuZXJhdGUocHJlZml4OiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nKTogQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcImZldGNoaW5nIGNvbXBsZXRpb25cIik7XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZUl0ZXJhdG9yID0gYXdhaXQgdGhpcy5vbGxhbWEuZ2VuZXJhdGUoe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMuc2V0dGluZ3MubW9kZWwsXG4gICAgICAgICAgICBwcm9tcHQ6IHByZWZpeCxcbiAgICAgICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGNvbXBsZXRpb24gPSBcIlwiO1xuICAgICAgICBmb3IgYXdhaXQgKGxldCByZXNwb25zZSBvZiBwcm9taXNlSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGNvbXBsZXRpb24gKz0gcmVzcG9uc2UucmVzcG9uc2U7XG4gICAgICAgICAgICB5aWVsZCB7IGNvbXBsZXRlX3N1Z2dlc3Rpb246IGNvbXBsZXRpb24sIGRpc3BsYXlfc3VnZ2VzdGlvbjogY29tcGxldGlvbiB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBhYm9ydCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJjYW5jZWxpbmcgY29tcGxldGlvblwiKTtcbiAgICAgICAgdGhpcy5vbGxhbWEuYWJvcnQoKTtcbiAgICB9XG59XG5cblxuIiwgImltcG9ydCB7IE9sbGFtYVNldHRpbmdzIH0gZnJvbSBcInNyYy9wcm92aWRlcnMvb2xsYW1hXCI7XG5pbXBvcnQgeyBPcGVuQUlTZXR0aW5ncyB9IGZyb20gXCJzcmMvcHJvdmlkZXJzL29wZW5haS9zZXR0aW5nc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNldHRpbmdzIHtcbiAgICBwcm92aWRlcjogc3RyaW5nLFxuICAgIHByb3ZpZGVyU2V0dGluZ3M6IHtcbiAgICAgICAgb2xsYW1hOiBPbGxhbWFTZXR0aW5ncyxcbiAgICAgICAgb3BlbmFpOiBPcGVuQUlTZXR0aW5ncyxcbiAgICB9LFxuICAgIHByb210dHk6IGJvb2xlYW4sXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBTZXR0aW5ncyA9IHtcbiAgICBwcm92aWRlcjogXCJvbGxhbWFcIixcbiAgICBwcm92aWRlclNldHRpbmdzOiB7XG4gICAgICAgIG9wZW5haToge1xuICAgICAgICAgICAgYXBpS2V5OiBcIlwiLFxuICAgICAgICAgICAgbW9kZWw6IFwiZ3B0LTRcIlxuICAgICAgICB9LFxuICAgICAgICBvbGxhbWE6IHtcbiAgICAgICAgICAgIGhvc3Q6IFwiaHR0cDovL2xvY2FsaG9zdDoxMTQzNFwiLFxuICAgICAgICAgICAgbW9kZWw6IFwibWlzdHJhbC1uZW1vXCJcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHByb210dHk6IHRydWUsXG59XG5cblxuIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IEluc2NyaWJlIGZyb20gXCIuLi9tYWluXCI7XG5pbXBvcnQgeyBQcm92aWRlclNldHRpbmdzQ29tcG9uZW50IH0gZnJvbSBcIi4vcHJvdmlkZXItc2V0dGluZ3NcIjtcblxuZXhwb3J0IGNsYXNzIEluc2NyaWJlU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcHJpdmF0ZSBwbHVnaW46IEluc2NyaWJlKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICB9XG5cbiAgICBhc3luYyBkaXNwbGF5KCkge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgICAgICBuZXcgUHJvdmlkZXJTZXR0aW5nc0NvbXBvbmVudCh0aGlzLnBsdWdpbiwgY29udGFpbmVyRWwpLmRpc3BsYXkoKTtcbiAgICB9XG59IiwgImltcG9ydCB7IFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IFByb3ZpZGVySWQsIFBST1ZJREVSUyB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXJcIjtcbmltcG9ydCB7IEluc2NyaWJlU2V0dGluZ3NDb21wb25lbnQgfSBmcm9tIFwiLi9zZXR0aW5ncy1jb21wb25lbnRcIjtcbmltcG9ydCB7IE9sbGFtYVNldHRpbmdzQ29tcG9uZW50IH0gZnJvbSBcInNyYy9wcm92aWRlcnMvb2xsYW1hXCI7XG5pbXBvcnQgeyBPcGVuQUlTZXR0aW5nc0NvbXBvbmVudCB9IGZyb20gXCJzcmMvcHJvdmlkZXJzL29wZW5haVwiO1xuXG5leHBvcnQgY2xhc3MgUHJvdmlkZXJTZXR0aW5nc0NvbXBvbmVudCBleHRlbmRzIEluc2NyaWJlU2V0dGluZ3NDb21wb25lbnQge1xuICAgIHB1YmxpYyBkaXNwbGF5KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIlByb3ZpZGVyIFNldHRpbmdzXCIgfSk7XG5cbiAgICAgICAgLy8gUHJvdmlkZXIgU2VsZWN0aW9uXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJBSSBQcm92aWRlclwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJDaG9vc2UgeW91ciBwcmVmZXJyZWQgQUkgcHJvdmlkZXIuXCIpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oKGRyb3Bkb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm92aWRlciBvZiBQUk9WSURFUlMpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKHByb3ZpZGVyLmlkLCBwcm92aWRlci5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVyKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlciA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN3aXRjaCBjYXNlIGZvciBwcm92aWRlcnNcbiAgICAgICAgc3dpdGNoICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlcikge1xuICAgICAgICAgICAgY2FzZSBQcm92aWRlcklkLk9QRU5BSTpcbiAgICAgICAgICAgICAgICBuZXcgT3BlbkFJU2V0dGluZ3NDb21wb25lbnQodGhpcy5wbHVnaW4sIGNvbnRhaW5lckVsKS5kaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByb3ZpZGVySWQuT0xMQU1BOlxuICAgICAgICAgICAgICAgIG5ldyBPbGxhbWFTZXR0aW5nc0NvbXBvbmVudCh0aGlzLnBsdWdpbiwgY29udGFpbmVyRWwpLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn0iLCAiaW1wb3J0IEluc2NyaWJlIGZyb20gXCJzcmMvbWFpblwiO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5zY3JpYmVTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgcHJvdGVjdGVkIHBsdWdpbjogSW5zY3JpYmU7XG4gICAgcHJvdGVjdGVkIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHBsdWdpbjogSW5zY3JpYmUsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCkge1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xuICAgIH1cblxuICAgIHB1YmxpYyBhYnN0cmFjdCBkaXNwbGF5KCk6IHZvaWQ7XG59IiwgImltcG9ydCB7IFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IEluc2NyaWJlU2V0dGluZ3NDb21wb25lbnQgfSBmcm9tIFwic3JjL3NldHRpbmdzL3NldHRpbmdzLWNvbXBvbmVudFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9sbGFtYVNldHRpbmdzIHtcbiAgICBob3N0OiBzdHJpbmc7XG4gICAgbW9kZWw6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIE9sbGFtYVNldHRpbmdzQ29tcG9uZW50IGV4dGVuZHMgSW5zY3JpYmVTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgcHVibGljIGRpc3BsYXkoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IFwiT2xsYW1hIFNldHRpbmdzXCIgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5jb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiSG9zdFwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJFbnRlciB0aGUgT2xsYW1hIGhvc3QuXCIpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcih0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlclNldHRpbmdzLm9sbGFtYS5ob3N0KVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXJTZXR0aW5ncy5vbGxhbWEuaG9zdClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXJTZXR0aW5ncy5vbGxhbWEuaG9zdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICBuZXcgU2V0dGluZyh0aGlzLmNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJNb2RlbFwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJDaG9vc2UgdGhlIE9sbGFtYSBtb2RlbC5cIilcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwibWlzdHJhbC1uZW1vXCIsIFwiTWlzdHJhbC1OZW1vXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oXCJtaXN0cmFsLWdwdFwiLCBcIk1pc3RyYWwtR1BUXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlclNldHRpbmdzLm9sbGFtYS5tb2RlbClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXJTZXR0aW5ncy5vbGxhbWEubW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBJbnNjcmliZVNldHRpbmdzQ29tcG9uZW50IH0gZnJvbSBcInNyYy9zZXR0aW5ncy9zZXR0aW5ncy1jb21wb25lbnRcIjtcblxuZXhwb3J0IGludGVyZmFjZSBPcGVuQUlTZXR0aW5ncyB7XG4gICAgYXBpS2V5OiBzdHJpbmc7XG4gICAgbW9kZWw6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIE9wZW5BSVNldHRpbmdzQ29tcG9uZW50IGV4dGVuZHMgSW5zY3JpYmVTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgcHVibGljIGRpc3BsYXkoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IFwiT3BlbkFJIFNldHRpbmdzXCIgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5jb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQVBJIEtleVwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJFbnRlciB0aGUgT3BlbkFJIEFQSSBrZXkuXCIpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcih0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlclNldHRpbmdzLm9wZW5haS5hcGlLZXkpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlclNldHRpbmdzLm9wZW5haS5hcGlLZXkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVyU2V0dGluZ3Mub3BlbmFpLmFwaUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICBuZXcgU2V0dGluZyh0aGlzLmNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJNb2RlbFwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJDaG9vc2UgdGhlIE9wZW5BSSBtb2RlbC5cIilcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwiZ3B0LTRcIiwgXCJHUFQtNFwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwiZGF2aW5jaVwiLCBcIkRhdmluY2lcIilcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVyU2V0dGluZ3Mub3BlbmFpLm1vZGVsKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlclNldHRpbmdzLm9wZW5haS5tb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxtQkFBK0I7Ozs7Ozs7QUM0Q3hCLFNBQVNDLEVBQ2RDLEdBQ0FDLEdBQ0FDLElBQWtCLFFBSWxCO0FBQ0EsUUFBTUMsS0FBUTtJQUNaLE9BQU8sTUFBTTtJQUViO0VBQUE7QUFFRixNQUFJQyxJQUF1QjtBQUUzQixrQkFBZ0JDLEtBQVlDLElBQWdEO0FBQzFFRixTQUFTLGFBQWFBLENBQUs7QUFDM0IsUUFBSUcsS0FBMkI7QUFFM0IsUUFBQTtBQUNJLFlBQUEsSUFBSSxRQUFjLENBQUNDLE1BQVk7QUFDbkNELFFBQUFBLEtBQVlILElBQVEsV0FBVyxNQUFNSSxFQUFBQSxHQUFXUCxDQUFJLEdBQ3BERSxHQUFNLFFBQVEsTUFBTTtBQUNsQkMsZUFBUyxhQUFhQSxDQUFLLEdBQ25CSSxFQUFBQTtRQUFBO01BQ1YsQ0FDRDtJQUFBLFNBQUFDLElBQUE7QUFFRCxVQUFJUCxNQUFlO0FBQ1gsY0FBQUE7SUFFVjtBQUVBLHFCQUFpQlEsS0FBUVYsRUFB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LCAiZm4iLCAid2FpdCIsICJhYm9ydFZhbHVlIiwgImZvcmNlIiwgInRpbWVyIiwgIndyYXBGdW5jIiwgImFyZ3MiLCAib3duX3RpbWVyIiwgInJlc29sdmUiLCAiZSIsICJpdGVtIiwgIklubGluZVN1Z2dlc3Rpb25TdGF0ZSIsICJTdGF0ZUZpZWxkIiwgIl9fIiwgInRyIiwgImlubGluZVN1Z2dlc3Rpb24iLCAiZSIsICJJbmxpbmVTdWdnZXN0aW9uRWZmZWN0IiwgIlN0YXRlRWZmZWN0IiwgImlubGluZVN1Z2dlc3Rpb25EZWNvcmF0aW9uIiwgInZpZXciLCAicHJlZml4IiwgInBvcyIsICJ3aWRnZXRzIiwgInciLCAiRGVjb3JhdGlvbiIsICJJbmxpbmVTdWdnZXN0aW9uV2lkZ2V0IiwgIldpZGdldFR5cGUiLCAic3VnZ2VzdGlvbiIsICJfX3B1YmxpY0ZpZWxkIiwgImRpdiIsICJmZXRjaFN1Z2dlc3Rpb24iLCAiZmV0Y2hGbiIsICJzdWdnZXN0aW9uSWQiLCAiVmlld1BsdWdpbiIsICJ1cGRhdGUiLCAiZG9jIiwgImN1cnJlbnRTdWdnZXN0aW9uSWQiLCAicmVzdWx0IiwgIlJlbmRlclBsdWdpbiIsICJfYSIsICJyZW5kZXJJbmxpbmVTdWdnZXN0aW9uUGx1Z2luIiwgInYiLCAiaW5saW5lU3VnZ2VzdGlvbktleW1hcCIsICJzdWdnZXN0Rm4iLCAiYWNjZXB0X3Nob3J0Y3V0IiwgImluc2VydENvbXBsZXRpb25UZXh0IiwgIl9iIiwgImNvbXBsZXRpb25JZCIsICJQcmVjIiwgImtleW1hcCIsICJzdGF0ZSIsICJ0ZXh0IiwgImZyb20iLCAidG8iLCAicmFuZ2UiLCAiRWRpdG9yU2VsZWN0aW9uIiwgImxlbiIsICJ0b1N1Z2dlc3Rpb24iLCAidG9TdWdnZXN0aW9uRm4iLCAib3B0aW9ucyIsICJkZWxheSIsICJkZWJvdW5jZWRfZmV0Y2hGbiIsICJkZWJvdW5jZUFzeW5jR2VuZXJhdG9yIiwgImciLCAicmVzb2x2ZSIsICJmZXRjaCIsICJmZXRjaCIsICJwIiwgIl9fZGVmUHJvcCIsICJPbGxhbWEiLCAiZnMiLCAiT2xsYW1hIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIl0KfQo=
