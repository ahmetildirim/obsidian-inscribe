/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Inscribe
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/extension/index.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var TextSplitStrategies = {
  /**
   * Word-level segmentation (space-delimited).
   * Accepts text until (and including) the first space.
   */
  word: (text) => {
    const nextSpace = text.indexOf(" ");
    return nextSpace === -1 ? { accepted: text, remaining: "" } : {
      accepted: text.slice(0, nextSpace + 1),
      remaining: text.slice(nextSpace + 1)
    };
  },
  /**
   * Sentence-level segmentation (punctuation followed by whitespace).
   */
  sentence: (text) => {
    const match = text.match(/[.!?]\s+/);
    if (match && match.index !== void 0) {
      return {
        accepted: text.slice(0, match.index + 1),
        remaining: text.slice(match.index + 1)
      };
    }
    return { accepted: text, remaining: "" };
  },
  /**
   * Paragraph-level segmentation (double newline).
   */
  paragraph: (text) => {
    const paragraphEnd = text.indexOf("\n\n");
    return paragraphEnd === -1 ? { accepted: text, remaining: "" } : {
      accepted: text.slice(0, paragraphEnd + 2),
      remaining: text.slice(paragraphEnd + 2)
    };
  },
  /**
   * Atomic acceptance â€“ consume the entire suggestion.
   */
  full: (text) => ({ accepted: text, remaining: "" })
};
var SuggestionUpdateEffect = import_state.StateEffect.define();
var suggestionSessionState = import_state.StateField.define({
  create: () => getResetSession(),
  update(session, transaction) {
    const effect = transaction.effects.find(
      (e) => e.is(SuggestionUpdateEffect)
    );
    if (effect)
      return updateSessionFromEffect(effect.value);
    if (transaction.docChanged && session.remainingText && session.anchorPosition !== null) {
      return updateSessionOnDocumentChange(session, transaction);
    }
    if (session.remainingText !== null && session.anchorPosition !== null) {
      return updateSessionOnCursorDrift(session, transaction);
    }
    return session;
  }
});
function getResetSession() {
  return {
    fullText: null,
    remainingText: null,
    baselineDocument: null,
    anchorPosition: null
  };
}
function updateSessionFromEffect(effect) {
  return effect.content === null ? getResetSession() : initializeSession(effect);
}
function initializeSession(effect) {
  return {
    fullText: effect.content,
    remainingText: effect.content,
    baselineDocument: effect.document,
    anchorPosition: effect.anchor
  };
}
function updateSessionOnDocumentChange(session, transaction) {
  let insertedContent = "";
  let insertionAtAnchor = false;
  transaction.changes.iterChanges((fromA, toA, _fromB, _toB, inserted) => {
    if (fromA === session.anchorPosition && toA === fromA) {
      insertedContent = inserted.toString();
      insertionAtAnchor = true;
    }
  });
  if (!insertionAtAnchor || !session.remainingText) {
    return invalidateSession(session);
  }
  if (session.remainingText.startsWith(insertedContent)) {
    return advanceSession(session, insertedContent.length);
  }
  return invalidateSession(session);
}
function advanceSession(session, consumedLength) {
  return {
    ...session,
    remainingText: session.remainingText.slice(consumedLength).length > 0 ? session.remainingText.slice(consumedLength) : null,
    anchorPosition: session.anchorPosition + consumedLength
  };
}
function invalidateSession(session) {
  return {
    ...session,
    remainingText: null,
    anchorPosition: null
  };
}
function updateSessionOnCursorDrift(session, transaction) {
  return transaction.state.selection.main.head !== session.anchorPosition ? invalidateSession(session) : session;
}
var _SuggestionWidget = class extends import_view.WidgetType {
  constructor(content) {
    super();
    this.content = content;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = _SuggestionWidget.CSS_CLASS;
    span.style.opacity = _SuggestionWidget.OPACITY.toString();
    span.textContent = this.content;
    return span;
  }
};
var SuggestionWidget = _SuggestionWidget;
SuggestionWidget.OPACITY = 0.4;
SuggestionWidget.CSS_CLASS = "cm-inline-prediction";
var suggestionRenderer = import_view.ViewPlugin.fromClass(
  class {
    constructor() {
      this.decorations = import_view.Decoration.none;
    }
    update(update) {
      const session = update.state.field(suggestionSessionState);
      this.decorations = session.remainingText ? this.createDecoration(update.view, session.remainingText) : import_view.Decoration.none;
    }
    createDecoration(view, suggestionText) {
      const cursorPosition = view.state.selection.main.head;
      return import_view.Decoration.set([
        import_view.Decoration.widget({
          widget: new SuggestionWidget(suggestionText),
          side: 1
        }).range(cursorPosition)
      ]);
    }
  },
  { decorations: (v) => v.decorations }
);
var createDebouncedFetcher = (fetch3, getDelay) => {
  let activeRequest = true;
  let timeoutId;
  const throttledFetch = async function* (state) {
    clearTimeout(timeoutId);
    activeRequest = true;
    await new Promise((resolve2) => {
      timeoutId = setTimeout(resolve2, getDelay());
    });
    if (activeRequest)
      yield* fetch3(state);
  };
  const fetcherPlugin = import_view.ViewPlugin.fromClass(
    class {
      constructor() {
        this.currentRequestId = 0;
      }
      async update(update) {
        const state = update.state;
        if (!update.docChanged || state.field(suggestionSessionState).remainingText)
          return;
        const requestId = ++this.currentRequestId;
        for await (const suggestion of throttledFetch(state)) {
          if (requestId !== this.currentRequestId)
            return;
          update.view.dispatch({
            effects: SuggestionUpdateEffect.of({
              content: suggestion.text,
              document: state.doc,
              anchor: state.selection.main.head
            })
          });
        }
      }
    }
  );
  return {
    fetcherPlugin,
    terminate: () => {
      activeRequest = false;
      clearTimeout(timeoutId);
    }
  };
};
var createAcceptanceHandler = (terminateFetch, hotkey, getOptions) => import_state.Prec.highest(
  import_view.keymap.of([
    {
      key: hotkey,
      run: (view) => {
        var _a;
        const session = view.state.field(suggestionSessionState);
        if (!session.remainingText)
          return false;
        const dynamicOptions = getOptions();
        const segmentationKey = (_a = dynamicOptions.splitStrategy) != null ? _a : "word";
        const { accepted, remaining } = TextSplitStrategies[segmentationKey](session.remainingText);
        if (!accepted)
          return false;
        view.dispatch({
          ...insertCompletion(view.state, accepted),
          effects: SuggestionUpdateEffect.of({
            content: remaining || null,
            document: remaining ? session.baselineDocument : null,
            anchor: remaining ? session.anchorPosition + accepted.length : null
          })
        });
        if (!remaining)
          terminateFetch();
        return true;
      }
    }
  ])
);
var insertCompletion = (state, text) => {
  const cursorPos = state.selection.main.head;
  return {
    ...state.changeByRange(() => ({
      changes: { from: cursorPos, insert: text },
      range: import_state.EditorSelection.cursor(cursorPos + text.length)
    })),
    userEvent: "completion.accept"
  };
};
function inlineSuggestions(config) {
  const { fetchFunc, getOptions } = config;
  const staticHotkey = config.acceptanceHotkey || "Tab";
  const normalizeFetch = async function* (state) {
    const result = await fetchFunc(state);
    if (Symbol.asyncIterator in result) {
      yield* result;
    } else {
      yield result;
    }
  };
  const getDelay = () => {
    var _a;
    return (_a = getOptions().delayMs) != null ? _a : 300;
  };
  const { fetcherPlugin, terminate } = createDebouncedFetcher(normalizeFetch, getDelay);
  const acceptanceHandler = createAcceptanceHandler(terminate, staticHotkey, getOptions);
  return [
    suggestionSessionState,
    fetcherPlugin,
    suggestionRenderer,
    acceptanceHandler
  ];
}

// src/providers/openai/provider.ts
var OpenAIProvider = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateModels() {
    return ["gpt-4", "davinci"];
  }
};

// node_modules/ollama/dist/index.mjs
var import_fs = __toESM(require("fs"), 1);
var import_path = require("path");

// node_modules/whatwg-fetch/fetch.js
var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g,
  iterable: "Symbol" in g && "iterator" in Symbol,
  blob: "FileReader" in g && "Blob" in g && function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: "FormData" in g,
  arrayBuffer: "ArrayBuffer" in g
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve2, reject) {
    reader.onload = function() {
      resolve2(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};
Response.error = function() {
  var response = new Response(null, { status: 200, statusText: "" });
  response.ok = false;
  response.status = 0;
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response(null, { status, headers: { location: url } });
};
var DOMException = g.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch2(input, init) {
  return new Promise(function(resolve2, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve2(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch2.polyfill = true;
if (!g.fetch) {
  g.fetch = fetch2;
  g.Headers = Headers;
  g.Request = Request;
  g.Response = Response;
}

// node_modules/ollama/dist/browser.mjs
var version = "0.5.12";
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ResponseError = class extends Error {
  constructor(error, status_code) {
    super(error);
    this.error = error;
    this.status_code = status_code;
    this.name = "ResponseError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ResponseError);
    }
  }
};
var AbortableAsyncIterator = class {
  constructor(abortController, itr, doneCallback) {
    __publicField$1(this, "abortController");
    __publicField$1(this, "itr");
    __publicField$1(this, "doneCallback");
    this.abortController = abortController;
    this.itr = itr;
    this.doneCallback = doneCallback;
  }
  abort() {
    this.abortController.abort();
  }
  async *[Symbol.asyncIterator]() {
    for await (const message of this.itr) {
      if ("error" in message) {
        throw new Error(message.error);
      }
      yield message;
      if (message.done || message.status === "success") {
        this.doneCallback();
        return;
      }
    }
    throw new Error("Did not receive done or success response in stream.");
  }
};
var checkOk = async (response) => {
  var _a;
  if (response.ok) {
    return;
  }
  let message = `Error ${response.status}: ${response.statusText}`;
  let errorData = null;
  if ((_a = response.headers.get("content-type")) == null ? void 0 : _a.includes("application/json")) {
    try {
      errorData = await response.json();
      message = errorData.error || message;
    } catch (error) {
      console.log("Failed to parse error response as JSON");
    }
  } else {
    try {
      console.log("Getting text from response");
      const textResponse = await response.text();
      message = textResponse || message;
    } catch (error) {
      console.log("Failed to get text from error response");
    }
  }
  throw new ResponseError(message, response.status);
};
function getPlatform() {
  if (typeof window !== "undefined" && window.navigator) {
    return `${window.navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;
  } else if (typeof process !== "undefined") {
    return `${process.arch} ${process.platform} Node.js/${process.version}`;
  }
  return "";
}
var fetchWithHeaders = async (fetch3, url, options = {}) => {
  const defaultHeaders = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "User-Agent": `ollama-js/${version} (${getPlatform()})`
  };
  if (!options.headers) {
    options.headers = {};
  }
  const customHeaders = Object.fromEntries(
    Object.entries(options.headers).filter(([key]) => !Object.keys(defaultHeaders).some((defaultKey) => defaultKey.toLowerCase() === key.toLowerCase()))
  );
  options.headers = {
    ...defaultHeaders,
    ...customHeaders
  };
  return fetch3(url, options);
};
var get = async (fetch3, host, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var post = async (fetch3, host, data, options) => {
  const isRecord = (input) => {
    return input !== null && typeof input === "object" && !Array.isArray(input);
  };
  const formattedData = isRecord(data) ? JSON.stringify(data) : data;
  const response = await fetchWithHeaders(fetch3, host, {
    method: "POST",
    body: formattedData,
    signal: options == null ? void 0 : options.signal,
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var del = async (fetch3, host, data, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    method: "DELETE",
    body: JSON.stringify(data),
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var parseJSON = async function* (itr) {
  var _a;
  const decoder = new TextDecoder("utf-8");
  let buffer = "";
  const reader = itr.getReader();
  while (true) {
    const { done, value: chunk } = await reader.read();
    if (done) {
      break;
    }
    buffer += decoder.decode(chunk);
    const parts = buffer.split("\n");
    buffer = (_a = parts.pop()) != null ? _a : "";
    for (const part of parts) {
      try {
        yield JSON.parse(part);
      } catch (error) {
        console.warn("invalid json: ", part);
      }
    }
  }
  for (const part of buffer.split("\n").filter((p) => p !== "")) {
    try {
      yield JSON.parse(part);
    } catch (error) {
      console.warn("invalid json: ", part);
    }
  }
};
var formatHost = (host) => {
  if (!host) {
    return "http://127.0.0.1:11434";
  }
  let isExplicitProtocol = host.includes("://");
  if (host.startsWith(":")) {
    host = `http://127.0.0.1${host}`;
    isExplicitProtocol = true;
  }
  if (!isExplicitProtocol) {
    host = `http://${host}`;
  }
  const url = new URL(host);
  let port = url.port;
  if (!port) {
    if (!isExplicitProtocol) {
      port = "11434";
    } else {
      port = url.protocol === "https:" ? "443" : "80";
    }
  }
  let formattedHost = `${url.protocol}//${url.hostname}:${port}${url.pathname}`;
  if (formattedHost.endsWith("/")) {
    formattedHost = formattedHost.slice(0, -1);
  }
  return formattedHost;
};
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var Ollama$1 = class Ollama {
  constructor(config) {
    var _a, _b;
    __publicField(this, "config");
    __publicField(this, "fetch");
    __publicField(this, "ongoingStreamedRequests", []);
    this.config = {
      host: "",
      headers: config == null ? void 0 : config.headers
    };
    if (!(config == null ? void 0 : config.proxy)) {
      this.config.host = formatHost((_a = config == null ? void 0 : config.host) != null ? _a : "http://127.0.0.1:11434");
    }
    this.fetch = (_b = config == null ? void 0 : config.fetch) != null ? _b : fetch;
  }
  // Abort any ongoing streamed requests to Ollama
  abort() {
    for (const request of this.ongoingStreamedRequests) {
      request.abort();
    }
    this.ongoingStreamedRequests.length = 0;
  }
  /**
   * Processes a request to the Ollama server. If the request is streamable, it will return a
   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
   * object.
   * @param endpoint {string} - The endpoint to send the request to.
   * @param request {object} - The request object to send to the endpoint.
   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
   * response messages.
   * @throws {Error} - If the response body is missing or if the response is an error.
   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
   */
  async processStreamableRequest(endpoint, request) {
    var _a;
    request.stream = (_a = request.stream) != null ? _a : false;
    const host = `${this.config.host}/api/${endpoint}`;
    if (request.stream) {
      const abortController = new AbortController();
      const response2 = await post(this.fetch, host, request, {
        signal: abortController.signal,
        headers: this.config.headers
      });
      if (!response2.body) {
        throw new Error("Missing body");
      }
      const itr = parseJSON(response2.body);
      const abortableAsyncIterator = new AbortableAsyncIterator(
        abortController,
        itr,
        () => {
          const i = this.ongoingStreamedRequests.indexOf(abortableAsyncIterator);
          if (i > -1) {
            this.ongoingStreamedRequests.splice(i, 1);
          }
        }
      );
      this.ongoingStreamedRequests.push(abortableAsyncIterator);
      return abortableAsyncIterator;
    }
    const response = await post(this.fetch, host, request, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Encodes an image to base64 if it is a Uint8Array.
   * @param image {Uint8Array | string} - The image to encode.
   * @returns {Promise<string>} - The base64 encoded image.
   */
  async encodeImage(image) {
    if (typeof image !== "string") {
      const uint8Array = new Uint8Array(image);
      let byteString = "";
      const len = uint8Array.byteLength;
      for (let i = 0; i < len; i++) {
        byteString += String.fromCharCode(uint8Array[i]);
      }
      return btoa(byteString);
    }
    return image;
  }
  /**
   * Generates a response from a text prompt.
   * @param request {GenerateRequest} - The request object.
   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async generate(request) {
    if (request.images) {
      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));
    }
    return this.processStreamableRequest("generate", request);
  }
  /**
   * Chats with the model. The request object can contain messages with images that are either
   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
   * request.
   * @param request {ChatRequest} - The request object.
   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
   * AbortableAsyncIterator that yields response messages.
   */
  async chat(request) {
    if (request.messages) {
      for (const message of request.messages) {
        if (message.images) {
          message.images = await Promise.all(
            message.images.map(this.encodeImage.bind(this))
          );
        }
      }
    }
    return this.processStreamableRequest("chat", request);
  }
  /**
   * Creates a new model from a stream of data.
   * @param request {CreateRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
   */
  async create(request) {
    return this.processStreamableRequest("create", {
      ...request
    });
  }
  /**
   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PullRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async pull(request) {
    return this.processStreamableRequest("pull", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PushRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async push(request) {
    return this.processStreamableRequest("push", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Deletes a model from the server. The request object should contain the name of the model to
   * delete.
   * @param request {DeleteRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async delete(request) {
    await del(
      this.fetch,
      `${this.config.host}/api/delete`,
      { name: request.model },
      { headers: this.config.headers }
    );
    return { status: "success" };
  }
  /**
   * Copies a model from one name to another. The request object should contain the name of the
   * model to copy and the new name.
   * @param request {CopyRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async copy(request) {
    await post(this.fetch, `${this.config.host}/api/copy`, { ...request }, {
      headers: this.config.headers
    });
    return { status: "success" };
  }
  /**
   * Lists the models on the server.
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async list() {
    const response = await get(this.fetch, `${this.config.host}/api/tags`, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Shows the metadata of a model. The request object should contain the name of the model.
   * @param request {ShowRequest} - The request object.
   * @returns {Promise<ShowResponse>} - The response object.
   */
  async show(request) {
    const response = await post(this.fetch, `${this.config.host}/api/show`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds text input into vectors.
   * @param request {EmbedRequest} - The request object.
   * @returns {Promise<EmbedResponse>} - The response object.
   */
  async embed(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embed`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds a text prompt into a vector.
   * @param request {EmbeddingsRequest} - The request object.
   * @returns {Promise<EmbeddingsResponse>} - The response object.
   */
  async embeddings(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Lists the running models on the server
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async ps() {
    const response = await get(this.fetch, `${this.config.host}/api/ps`, {
      headers: this.config.headers
    });
    return await response.json();
  }
};
var browser = new Ollama$1();

// node_modules/ollama/dist/index.mjs
var Ollama2 = class extends Ollama$1 {
  async encodeImage(image) {
    if (typeof image !== "string") {
      return Buffer.from(image).toString("base64");
    }
    try {
      if (import_fs.default.existsSync(image)) {
        const fileBuffer = await import_fs.promises.readFile((0, import_path.resolve)(image));
        return Buffer.from(fileBuffer).toString("base64");
      }
    } catch (e) {
    }
    return image;
  }
  /**
   * checks if a file exists
   * @param path {string} - The path to the file
   * @private @internal
   * @returns {Promise<boolean>} - Whether the file exists or not
   */
  async fileExists(path) {
    try {
      await import_fs.promises.access(path);
      return true;
    } catch (e) {
      return false;
    }
  }
  async create(request) {
    if (request.from && await this.fileExists((0, import_path.resolve)(request.from))) {
      throw Error("Creating with a local path is not currently supported from ollama-js");
    }
    if (request.stream) {
      return super.create(request);
    } else {
      return super.create(request);
    }
  }
};
var index = new Ollama2();

// node_modules/mustache/mustache.mjs
var objectToString = Object.prototype.toString;
var isArray = Array.isArray || function isArrayPolyfill(object) {
  return objectToString.call(object) === "[object Array]";
};
function isFunction(object) {
  return typeof object === "function";
}
function typeStr(obj) {
  return isArray(obj) ? "array" : typeof obj;
}
function escapeRegExp(string) {
  return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function hasProperty(obj, propName) {
  return obj != null && typeof obj === "object" && propName in obj;
}
function primitiveHasOwnProperty(primitive, propName) {
  return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
}
var regExpTest = RegExp.prototype.test;
function testRegExp(re, string) {
  return regExpTest.call(re, string);
}
var nonSpaceRe = /\S/;
function isWhitespace(string) {
  return !testRegExp(nonSpaceRe, string);
}
var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(string) {
  return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
    return entityMap[s];
  });
}
var whiteRe = /\s*/;
var spaceRe = /\s+/;
var equalsRe = /\s*=/;
var curlyRe = /\s*\}/;
var tagRe = /#|\^|\/|>|\{|&|=|!/;
function parseTemplate(template, tags) {
  if (!template)
    return [];
  var lineHasNonSpace = false;
  var sections = [];
  var tokens = [];
  var spaces = [];
  var hasTag = false;
  var nonSpace = false;
  var indentation = "";
  var tagIndex = 0;
  function stripSpace() {
    if (hasTag && !nonSpace) {
      while (spaces.length)
        delete tokens[spaces.pop()];
    } else {
      spaces = [];
    }
    hasTag = false;
    nonSpace = false;
  }
  var openingTagRe, closingTagRe, closingCurlyRe;
  function compileTags(tagsToCompile) {
    if (typeof tagsToCompile === "string")
      tagsToCompile = tagsToCompile.split(spaceRe, 2);
    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
      throw new Error("Invalid tags: " + tagsToCompile);
    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
    closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
    closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
  }
  compileTags(tags || mustache.tags);
  var scanner = new Scanner(template);
  var start, type, value, chr, token, openSection;
  while (!scanner.eos()) {
    start = scanner.pos;
    value = scanner.scanUntil(openingTagRe);
    if (value) {
      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
        chr = value.charAt(i);
        if (isWhitespace(chr)) {
          spaces.push(tokens.length);
          indentation += chr;
        } else {
          nonSpace = true;
          lineHasNonSpace = true;
          indentation += " ";
        }
        tokens.push(["text", chr, start, start + 1]);
        start += 1;
        if (chr === "\n") {
          stripSpace();
          indentation = "";
          tagIndex = 0;
          lineHasNonSpace = false;
        }
      }
    }
    if (!scanner.scan(openingTagRe))
      break;
    hasTag = true;
    type = scanner.scan(tagRe) || "name";
    scanner.scan(whiteRe);
    if (type === "=") {
      value = scanner.scanUntil(equalsRe);
      scanner.scan(equalsRe);
      scanner.scanUntil(closingTagRe);
    } else if (type === "{") {
      value = scanner.scanUntil(closingCurlyRe);
      scanner.scan(curlyRe);
      scanner.scanUntil(closingTagRe);
      type = "&";
    } else {
      value = scanner.scanUntil(closingTagRe);
    }
    if (!scanner.scan(closingTagRe))
      throw new Error("Unclosed tag at " + scanner.pos);
    if (type == ">") {
      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
    } else {
      token = [type, value, start, scanner.pos];
    }
    tagIndex++;
    tokens.push(token);
    if (type === "#" || type === "^") {
      sections.push(token);
    } else if (type === "/") {
      openSection = sections.pop();
      if (!openSection)
        throw new Error('Unopened section "' + value + '" at ' + start);
      if (openSection[1] !== value)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
    } else if (type === "name" || type === "{" || type === "&") {
      nonSpace = true;
    } else if (type === "=") {
      compileTags(value);
    }
  }
  stripSpace();
  openSection = sections.pop();
  if (openSection)
    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
  return nestTokens(squashTokens(tokens));
}
function squashTokens(tokens) {
  var squashedTokens = [];
  var token, lastToken;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    if (token) {
      if (token[0] === "text" && lastToken && lastToken[0] === "text") {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        squashedTokens.push(token);
        lastToken = token;
      }
    }
  }
  return squashedTokens;
}
function nestTokens(tokens) {
  var nestedTokens = [];
  var collector = nestedTokens;
  var sections = [];
  var token, section;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    switch (token[0]) {
      case "#":
      case "^":
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case "/":
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
    }
  }
  return nestedTokens;
}
function Scanner(string) {
  this.string = string;
  this.tail = string;
  this.pos = 0;
}
Scanner.prototype.eos = function eos() {
  return this.tail === "";
};
Scanner.prototype.scan = function scan(re) {
  var match = this.tail.match(re);
  if (!match || match.index !== 0)
    return "";
  var string = match[0];
  this.tail = this.tail.substring(string.length);
  this.pos += string.length;
  return string;
};
Scanner.prototype.scanUntil = function scanUntil(re) {
  var index2 = this.tail.search(re), match;
  switch (index2) {
    case -1:
      match = this.tail;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, index2);
      this.tail = this.tail.substring(index2);
  }
  this.pos += match.length;
  return match;
};
function Context(view, parentContext) {
  this.view = view;
  this.cache = { ".": this.view };
  this.parent = parentContext;
}
Context.prototype.push = function push(view) {
  return new Context(view, this);
};
Context.prototype.lookup = function lookup(name) {
  var cache = this.cache;
  var value;
  if (cache.hasOwnProperty(name)) {
    value = cache[name];
  } else {
    var context = this, intermediateValue, names, index2, lookupHit = false;
    while (context) {
      if (name.indexOf(".") > 0) {
        intermediateValue = context.view;
        names = name.split(".");
        index2 = 0;
        while (intermediateValue != null && index2 < names.length) {
          if (index2 === names.length - 1)
            lookupHit = hasProperty(intermediateValue, names[index2]) || primitiveHasOwnProperty(intermediateValue, names[index2]);
          intermediateValue = intermediateValue[names[index2++]];
        }
      } else {
        intermediateValue = context.view[name];
        lookupHit = hasProperty(context.view, name);
      }
      if (lookupHit) {
        value = intermediateValue;
        break;
      }
      context = context.parent;
    }
    cache[name] = value;
  }
  if (isFunction(value))
    value = value.call(this.view);
  return value;
};
function Writer() {
  this.templateCache = {
    _cache: {},
    set: function set(key, value) {
      this._cache[key] = value;
    },
    get: function get2(key) {
      return this._cache[key];
    },
    clear: function clear() {
      this._cache = {};
    }
  };
}
Writer.prototype.clearCache = function clearCache() {
  if (typeof this.templateCache !== "undefined") {
    this.templateCache.clear();
  }
};
Writer.prototype.parse = function parse(template, tags) {
  var cache = this.templateCache;
  var cacheKey = template + ":" + (tags || mustache.tags).join(":");
  var isCacheEnabled = typeof cache !== "undefined";
  var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
  if (tokens == void 0) {
    tokens = parseTemplate(template, tags);
    isCacheEnabled && cache.set(cacheKey, tokens);
  }
  return tokens;
};
Writer.prototype.render = function render(template, view, partials, config) {
  var tags = this.getConfigTags(config);
  var tokens = this.parse(template, tags);
  var context = view instanceof Context ? view : new Context(view, void 0);
  return this.renderTokens(tokens, context, partials, template, config);
};
Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
  var buffer = "";
  var token, symbol, value;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    value = void 0;
    token = tokens[i];
    symbol = token[0];
    if (symbol === "#")
      value = this.renderSection(token, context, partials, originalTemplate, config);
    else if (symbol === "^")
      value = this.renderInverted(token, context, partials, originalTemplate, config);
    else if (symbol === ">")
      value = this.renderPartial(token, context, partials, config);
    else if (symbol === "&")
      value = this.unescapedValue(token, context);
    else if (symbol === "name")
      value = this.escapedValue(token, context, config);
    else if (symbol === "text")
      value = this.rawValue(token);
    if (value !== void 0)
      buffer += value;
  }
  return buffer;
};
Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
  var self2 = this;
  var buffer = "";
  var value = context.lookup(token[1]);
  function subRender(template) {
    return self2.render(template, context, partials, config);
  }
  if (!value)
    return;
  if (isArray(value)) {
    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
    }
  } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
  } else if (isFunction(value)) {
    if (typeof originalTemplate !== "string")
      throw new Error("Cannot use higher-order sections without the original template");
    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
    if (value != null)
      buffer += value;
  } else {
    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
  }
  return buffer;
};
Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
  var value = context.lookup(token[1]);
  if (!value || isArray(value) && value.length === 0)
    return this.renderTokens(token[4], context, partials, originalTemplate, config);
};
Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
  var filteredIndentation = indentation.replace(/[^ \t]/g, "");
  var partialByNl = partial.split("\n");
  for (var i = 0; i < partialByNl.length; i++) {
    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
      partialByNl[i] = filteredIndentation + partialByNl[i];
    }
  }
  return partialByNl.join("\n");
};
Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
  if (!partials)
    return;
  var tags = this.getConfigTags(config);
  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
  if (value != null) {
    var lineHasNonSpace = token[6];
    var tagIndex = token[5];
    var indentation = token[4];
    var indentedValue = value;
    if (tagIndex == 0 && indentation) {
      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
    }
    var tokens = this.parse(indentedValue, tags);
    return this.renderTokens(tokens, context, partials, indentedValue, config);
  }
};
Writer.prototype.unescapedValue = function unescapedValue(token, context) {
  var value = context.lookup(token[1]);
  if (value != null)
    return value;
};
Writer.prototype.escapedValue = function escapedValue(token, context, config) {
  var escape = this.getConfigEscape(config) || mustache.escape;
  var value = context.lookup(token[1]);
  if (value != null)
    return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
};
Writer.prototype.rawValue = function rawValue(token) {
  return token[1];
};
Writer.prototype.getConfigTags = function getConfigTags(config) {
  if (isArray(config)) {
    return config;
  } else if (config && typeof config === "object") {
    return config.tags;
  } else {
    return void 0;
  }
};
Writer.prototype.getConfigEscape = function getConfigEscape(config) {
  if (config && typeof config === "object" && !isArray(config)) {
    return config.escape;
  } else {
    return void 0;
  }
};
var mustache = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  /**
   * Allows a user to override the default caching strategy, by providing an
   * object with set, get and clear methods. This can also be used to disable
   * the cache by setting it to the literal `undefined`.
   */
  set templateCache(cache) {
    defaultWriter.templateCache = cache;
  },
  /**
   * Gets the default or overridden caching object from the default writer.
   */
  get templateCache() {
    return defaultWriter.templateCache;
  }
};
var defaultWriter = new Writer();
mustache.clearCache = function clearCache2() {
  return defaultWriter.clearCache();
};
mustache.parse = function parse2(template, tags) {
  return defaultWriter.parse(template, tags);
};
mustache.render = function render2(template, view, partials, config) {
  if (typeof template !== "string") {
    throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
  }
  return defaultWriter.render(template, view, partials, config);
};
mustache.escape = escapeHtml;
mustache.Scanner = Scanner;
mustache.Context = Context;
mustache.Writer = Writer;
var mustache_default = mustache;

// src/prompt/prompt.ts
var TEMPLATE_VARIABLES = `{{pre_cursor}}
{{post_cursor}} 
{{active_sentence}} 
{{last_line}}`;
function buildPrompt(template, args) {
  return mustache_default.render(template, args);
}
function preparePrompt(editor, template = TEMPLATE_VARIABLES) {
  const cursor = editor.getCursor();
  const preCursor = editor.getRange({ line: 0, ch: 0 }, cursor);
  const postCursor = editor.getRange(cursor, { line: editor.lastLine(), ch: editor.getLine(editor.lastLine()).length });
  const activeSentence = sentenceAtCursor(editor);
  const lastLine = editor.getLine(editor.lastLine());
  return buildPrompt(template, {
    pre_cursor: preCursor,
    post_cursor: postCursor,
    active_sentence: activeSentence,
    last_line: lastLine
  });
}
function sentenceAtCursor(editor) {
  const cursor = editor.getCursor();
  let currentLine = cursor.line;
  let sentenceLines = [editor.getLine(currentLine)];
  while (currentLine > 0) {
    currentLine--;
    const line = editor.getLine(currentLine);
    if (/[.!?]\s*$/.test(line)) {
      break;
    }
    sentenceLines.unshift(line);
  }
  return sentenceLines.join(" ").replace(/\s+/g, " ").trim();
}

// src/providers/ollama/provider.ts
var OllamaProvider = class {
  constructor(settins) {
    this.aborted = false;
    this.settings = settins;
    this.client = new Ollama2({ host: this.settings.host });
  }
  async *generate(editor, options) {
    this.aborted = false;
    const prompt = preparePrompt(editor, options.userPrompt);
    const completionIterator = await this.client.generate({
      model: options.model,
      prompt,
      system: options.systemPrompt,
      stream: true,
      options: {
        temperature: options.temperature
      }
    });
    const initialPosition = editor.getCursor();
    let completion = "";
    for await (let response of completionIterator) {
      if (this.aborted) {
        return;
      }
      const currentPosition = editor.getCursor();
      if (currentPosition.line !== initialPosition.line || currentPosition.ch !== initialPosition.ch) {
        console.log("cursor moved, aborting completion");
        this.abort();
        return;
      }
      completion += response.response;
      yield completion;
    }
  }
  async abort() {
    if (this.aborted)
      return;
    this.client.abort();
    this.aborted = true;
    console.log("aborted completion");
  }
  async updateModels() {
    const response = await this.client.list();
    return response.models.map((model) => model.name);
  }
};

// src/providers/index.ts
var buildProviders = (settings) => {
  return {
    ["ollama" /* OLLAMA */]: new OllamaProvider(settings.providers.ollama),
    ["openai" /* OPENAI */]: new OpenAIProvider(settings.providers.openai)
  };
};

// src/settings/tab.ts
var import_obsidian2 = require("obsidian");

// src/settings/provider-modal.ts
var import_obsidian = require("obsidian");
var ProviderSettingsModal = class extends import_obsidian.Modal {
  constructor(app, plugin, providerType, onSave) {
    super(app);
    this.plugin = plugin;
    this.providerType = providerType;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    this.modalEl.addClass("inscribe-provider-modal");
    this.modalEl.style.width = "60vw";
    this.modalEl.style.height = "auto";
    const container = contentEl.createDiv({ cls: "inscribe-modal-container" });
    const provider = this.providerType === "ollama" /* OLLAMA */ ? this.plugin.settings.providers.ollama : this.plugin.settings.providers.openai;
    const header = container.createDiv({ cls: "inscribe-modal-header" });
    header.createEl("h2", {
      text: `Configure ${provider.name}`,
      cls: "inscribe-modal-title"
    });
    const content = container.createDiv({ cls: "inscribe-modal-content" });
    if (this.providerType === "ollama" /* OLLAMA */) {
      const ollamaProvider = this.plugin.settings.providers.ollama;
      new import_obsidian.Setting(content).setClass("inscribe-modal-setting").setName("Host").setDesc("Your Ollama instance URL").addText((text) => {
        text.setPlaceholder("http://localhost:11434").setValue(ollamaProvider.host).onChange(async (value) => {
          ollamaProvider.host = value;
          await this.plugin.saveSettings();
        });
        text.inputEl.addClass("inscribe-modal-input");
      });
    } else {
      const openaiProvider = this.plugin.settings.providers.openai;
      new import_obsidian.Setting(content).setClass("inscribe-modal-setting").setName("API Key").setDesc("Your OpenAI API key").addText((text) => {
        text.setPlaceholder("sk-...").setValue(openaiProvider.apiKey).onChange(async (value) => {
          openaiProvider.apiKey = value;
          await this.plugin.saveSettings();
        });
        text.inputEl.addClass("inscribe-modal-input");
      });
    }
    this.addStyles();
  }
  addStyles() {
    const style = document.createElement("style");
    style.id = "inscribe-modal-styles";
    style.textContent = `
            .inscribe-provider-modal {
                max-width: 800px !important;
                max-height: 80vh !important;
                width: 60vw !important;
                height: auto !important;
                border-radius: 12px !important;
            }

            .inscribe-modal-container {
                display: flex;
                flex-direction: column;
                height: 100%;
                padding: 0;
            }

            .inscribe-modal-header {
                padding: 24px 32px;
                border-bottom: 1px solid var(--background-modifier-border);
            }

            .inscribe-modal-title {
                margin: 0;
                font-size: 1.5em;
                font-weight: 600;
                color: var(--text-normal);
            }

            .inscribe-modal-content {
                padding: 24px 32px;
                overflow-y: auto;
            }

            .inscribe-modal-setting {
                padding: 1rem 0;
                border: none;
            }

            .inscribe-modal-setting .setting-item-info {
                padding: 0 1rem 0 0;
            }

            .inscribe-modal-input {
                width: 100% !important;
                padding: 8px 12px !important;
                border-radius: 6px !important;
                background: var(--background-modifier-form-field) !important;
            }
        `;
    document.head.appendChild(style);
  }
  onClose() {
    const { contentEl } = this;
    const style = document.getElementById("inscribe-modal-styles");
    if (style) {
      style.remove();
    }
    contentEl.empty();
    this.onSave();
  }
};

// src/settings/tab.ts
var InscribeSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.displayedProfileId = DEFAULT_PROFILE;
    this.sections = {
      providers: document.createElement("div"),
      profiles: document.createElement("div"),
      profile: document.createElement("div"),
      pathMappings: document.createElement("div")
    };
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    Object.values(this.sections).forEach((section) => {
      containerEl.appendChild(section);
      containerEl.createEl("br");
    });
    await this.renderProviders();
    await this.renderProfiles();
    await this.renderPathMappings();
  }
  async renderProviders() {
    const { providers } = this.sections;
    providers.empty();
    providers.createEl("h3", { text: "Providers" });
    providers.createEl("p", { text: "Configure the AI providers you want to use for completions" });
    new import_obsidian2.Setting(providers).setName("Ollama").setDesc("Local AI provider running on your machine").addButton((button) => {
      button.setButtonText("Configure").setTooltip("Configure Ollama").onClick(() => this.openProviderModal("ollama" /* OLLAMA */));
    });
    new import_obsidian2.Setting(providers).setName("OpenAI").setDesc("OpenAI API provider").addButton((button) => {
      button.setButtonText("Configure").setTooltip("Configure OpenAI").onClick(() => this.openProviderModal("openai" /* OPENAI */));
    });
  }
  async openProviderModal(type) {
    new ProviderSettingsModal(
      this.app,
      this.plugin,
      type,
      () => this.renderProviders()
    ).open();
  }
  async renderProfiles() {
    const { profiles } = this.sections;
    profiles.empty();
    profiles.createEl("h3", { text: "Profiles" });
    profiles.createEl("p", { text: "Configure the settings for each profile. A profile can be assigned to paths. The default profile is used when no profile is assigned." });
    const displayedProfile = this.plugin.settings.profiles[this.displayedProfileId];
    await this.renderProfileSelection();
    await this.renderProfileSettings(displayedProfile);
  }
  async renderProfileSelection() {
    this.sections.profiles.createEl("br");
    new import_obsidian2.Setting(this.sections.profiles).setHeading().setName("Manage profile").setDesc("Select a profile to configure its settings").addDropdown(this.createProfileDropdown.bind(this)).addExtraButton(this.createNewProfileButton.bind(this)).addExtraButton(this.createDeleteProfileButton.bind(this));
  }
  createProfileDropdown(dropdown) {
    Object.entries(this.plugin.settings.profiles).forEach(([id, profile]) => {
      dropdown.addOption(id, profile.name);
    });
    dropdown.setValue(this.displayedProfileId).onChange(async (value) => {
      this.displayedProfileId = value;
      await this.renderProfileSettings(this.plugin.settings.profiles[value]);
    });
  }
  createNewProfileButton(button) {
    button.setIcon("plus").setTooltip("Create new profile").onClick(async () => {
      this.displayedProfileId = newProfile(this.plugin.settings.profiles);
      await this.plugin.saveSettings();
      await this.renderProfiles();
    });
  }
  createDeleteProfileButton(button) {
    const isDefault = this.displayedProfileId === DEFAULT_PROFILE;
    button.setDisabled(isDefault).setIcon("trash").setTooltip(isDefault ? "Cannot delete default profile" : "Delete profile").onClick(async () => {
      delete this.plugin.settings.profiles[this.displayedProfileId];
      this.displayedProfileId = DEFAULT_PROFILE;
      await this.plugin.saveSettings();
      await this.renderProfiles();
    });
  }
  async renderProfileSettings(profile) {
    const { profile: profileSection } = this.sections;
    profileSection.empty();
    new import_obsidian2.Setting(profileSection).setName("Profile Name").setDesc("Name of the profile").addText((text) => {
      text.setValue(profile.name).onChange(async (value) => {
        profile.name = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(profileSection).setName("AI Provider").setDesc("Choose your preferred AI provider").addDropdown((dropdown) => {
      dropdown.addOption("ollama" /* OLLAMA */, "Ollama").addOption("openai" /* OPENAI */, "OpenAI").setValue(profile.provider).onChange(async (value) => {
        profile.provider = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(profileSection).setName("Model").setDesc("Select the model to use for completions").addDropdown((dropdown) => {
      const models = profile.provider === "ollama" /* OLLAMA */ ? this.plugin.settings.providers.ollama.models : this.plugin.settings.providers.openai.models;
      models.forEach((model) => dropdown.addOption(model, model));
      dropdown.setValue(profile.completionOptions.model).onChange(async (value) => {
        profile.completionOptions.model = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(profileSection).setName("Temperature").setDesc("Control the randomness of completions (0 = deterministic, 1 = creative)").addSlider((slider) => {
      slider.setLimits(0, 1, 0.1).setValue(profile.completionOptions.temperature).setDynamicTooltip().onChange(async (value) => {
        profile.completionOptions.temperature = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(profileSection).setName("Suggestion Delay").setDesc("Delay in milliseconds before fetching suggestions").addText((text) => {
      text.inputEl.setAttr("type", "number");
      text.setPlaceholder("1000").setValue(String(profile.delayMs)).onChange(async (value) => {
        profile.delayMs = parseInt(value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(profileSection).setName("Completion Strategy").setDesc("Choose how completions should be split and accepted").addDropdown((dropdown) => {
      dropdown.addOption("word", "Word by Word").addOption("sentence", "Sentence by Sentence").addOption("paragraph", "Paragraph by Paragraph").addOption("full", "Full Completion").setValue(profile.splitStrategy).onChange(async (value) => {
        profile.splitStrategy = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(profileSection).setName("System Prompt").setDesc("Set system prompt").addTextArea((text) => {
      text.inputEl.rows = 3;
      text.inputEl.setCssStyles({ width: "100%", resize: "vertical", position: "relative" });
      text.setValue(profile.completionOptions.systemPrompt).onChange(async (value) => {
        profile.completionOptions.systemPrompt = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(profileSection).setName("User Prompt").setDesc("User prompt template ").addExtraButton((button) => {
      button.setIcon("list").setTooltip("Insert mustache template variables").onClick(async () => {
        const text = profile.completionOptions.userPrompt + "\n" + TEMPLATE_VARIABLES;
        profile.completionOptions.userPrompt = text;
        await this.plugin.saveSettings();
        await this.renderProfileSettings(profile);
      });
    }).addTextArea((text) => {
      text.inputEl.rows = 3;
      text.inputEl.setCssStyles({ width: "100%", resize: "vertical", position: "relative" });
      text.setValue(profile.completionOptions.userPrompt).onChange(async (value) => {
        profile.completionOptions.userPrompt = value;
        await this.plugin.saveSettings();
      });
    });
  }
  async renderPathMappings() {
    const { pathMappings: pathProfileMappings } = this.sections;
    pathProfileMappings.empty();
    pathProfileMappings.createEl("h3", { text: "Dynamic Profile Mapping" });
    pathProfileMappings.createEl("p", { text: "Configure which profile to use for specific paths. Paths are matched by prefix, with longer paths taking precedence. For example, '/Daily' will match all files in the Daily folder." });
    pathProfileMappings.createEl("br");
    new import_obsidian2.Setting(pathProfileMappings).setHeading().setName("Add Path Profile Mapping").addButton((button) => {
      button.setButtonText("Add").onClick(async () => {
        this.plugin.settings.path_profile_mappings[""] = DEFAULT_PROFILE;
        await this.plugin.saveSettings();
        await this.renderPathMappings();
      });
    });
    pathProfileMappings.createEl("br");
    Object.entries(this.plugin.settings.path_profile_mappings).forEach(([path, profileName]) => {
      new import_obsidian2.Setting(pathProfileMappings).setName(path || "Root").addText((text) => {
        text.setPlaceholder("Enter path (e.g., Daily/Work)").setValue(path).onChange(async (value) => {
          delete this.plugin.settings.path_profile_mappings[path];
          this.plugin.settings.path_profile_mappings[value] = profileName;
          await this.plugin.saveSettings();
        });
      }).addDropdown((dropdown) => {
        Object.entries(this.plugin.settings.profiles).forEach(([id, profile]) => {
          dropdown.addOption(id, profile.name);
        });
        dropdown.setValue(profileName).onChange(async (value) => {
          this.plugin.settings.path_profile_mappings[path] = value;
          await this.plugin.saveSettings();
        });
      }).addExtraButton((button) => {
        button.setIcon("trash").setTooltip("Delete mapping").onClick(async () => {
          delete this.plugin.settings.path_profile_mappings[path];
          await this.plugin.saveSettings();
          await this.renderPathMappings();
        });
      });
    });
  }
};

// src/settings/index.ts
var DEFAULT_PROFILE = "default";
var DEFAULT_SETTINGS = {
  providers: {
    openai: {
      integration: "openai" /* OPENAI */,
      name: "Open AI",
      description: "Use OpenAI APIs to generate text.",
      apiKey: "",
      model: "gpt-4o",
      models: ["gpt-4", "gpt-3.5-turbo", "gpt-3.5", "gpt-3", "gpt-2", "gpt-1"],
      configured: false
    },
    ollama: {
      integration: "ollama" /* OLLAMA */,
      name: "Ollama",
      description: "Use your own Ollama instance to generate text.",
      host: "http://localhost:11434",
      models: ["llama3.2:latest", "mistral-nemo"],
      configured: true
    }
  },
  profiles: {
    default: {
      name: "Default Profile",
      provider: "ollama" /* OLLAMA */,
      delayMs: 500,
      splitStrategy: "word",
      completionOptions: {
        model: "mistral-nemo",
        userPrompt: "Complete following text:\n {{pre_cursor}}}",
        systemPrompt: "You are an helpful AI completer. Follow instructions",
        temperature: 0.5
      }
    }
  },
  path_profile_mappings: {
    "/": DEFAULT_PROFILE
  }
};
function newProfile(profiles) {
  const id = Math.random().toString(36).substring(2, 6);
  let name = "New Profile";
  let i = 1;
  Object.entries(profiles).forEach(([, value]) => {
    if (value.name === name) {
      name = `New Profile ${i}`;
      i++;
    }
  });
  const defaultProfile = profiles[DEFAULT_PROFILE];
  const profile = {
    ...defaultProfile,
    name
  };
  profiles[id] = profile;
  return id;
}

// src/completion/index.ts
async function* generateCompletion(editor, provider, options) {
  await provider.abort();
  const cursor = editor.getCursor();
  const currentLine = editor.getLine(cursor.line);
  if (!currentLine.length) {
    return;
  }
  const lastChar = currentLine[cursor.ch - 1];
  if (lastChar !== " ") {
    return;
  }
  for await (const text of provider.generate(editor, options)) {
    yield { text };
  }
}
function resolveProfile(settings, providers, filePath) {
  const profileName = resolveProfileFromPath(settings, filePath);
  const profile = settings.profiles[profileName];
  const provider = providers[profile.provider];
  return [provider, profile];
}
function resolveProfileFromPath(settings, filePath) {
  if (!settings.path_profile_mappings || Object.keys(settings.path_profile_mappings).length === 0) {
    return DEFAULT_PROFILE;
  }
  const normalizedPath = filePath.replace(/^\/+|\/+$/g, "");
  let longestMatch = "";
  let matchedProfile = DEFAULT_PROFILE;
  Object.entries(settings.path_profile_mappings).forEach(([path, profile]) => {
    const normalizedMappingPath = path.replace(/^\/+|\/+$/g, "");
    if (normalizedPath.startsWith(normalizedMappingPath)) {
      if (normalizedMappingPath.length > longestMatch.length) {
        longestMatch = normalizedMappingPath;
        matchedProfile = profile;
      }
    }
  });
  return matchedProfile;
}

// src/main.ts
var Inscribe = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.inlineSuggestionOptions = { delayMs: 300, splitStrategy: "sentence" };
  }
  async onload() {
    await this.loadSettings();
    await this.loadProviders();
    await this.setupExtention();
    this.addSettingTab(new InscribeSettingsTab(this.app, this));
  }
  async loadProviders() {
    this.providers = buildProviders(this.settings);
  }
  async setupExtention() {
    const getOptions = () => {
      return this.inlineSuggestionOptions;
    };
    const extension = inlineSuggestions({
      fetchFunc: () => this.fetchSuggestions(),
      getOptions
    });
    this.registerEditorExtension(extension);
  }
  async *fetchSuggestions() {
    var _a;
    const activeEditor = this.app.workspace.activeEditor;
    if (!activeEditor)
      return;
    if (!activeEditor.editor)
      return;
    const filePath = ((_a = activeEditor.file) == null ? void 0 : _a.path) || "";
    const [provider, profile] = resolveProfile(this.settings, this.providers, filePath);
    this.inlineSuggestionOptions.delayMs = profile.delayMs;
    this.inlineSuggestionOptions.splitStrategy = profile.splitStrategy;
    yield* generateCompletion(activeEditor.editor, provider, profile.completionOptions);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.loadProviders();
  }
};
/*! Bundled license information:

mustache/mustache.mjs:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL2V4dGVuc2lvbi9pbmRleC50cyIsICJzcmMvcHJvdmlkZXJzL29wZW5haS9wcm92aWRlci50cyIsICJub2RlX21vZHVsZXMvb2xsYW1hL2Rpc3QvaW5kZXgubWpzIiwgIm5vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCAibm9kZV9tb2R1bGVzL29sbGFtYS9kaXN0L2Jyb3dzZXIubWpzIiwgIm5vZGVfbW9kdWxlcy9tdXN0YWNoZS9tdXN0YWNoZS5tanMiLCAic3JjL3Byb21wdC9wcm9tcHQudHMiLCAic3JjL3Byb3ZpZGVycy9vbGxhbWEvcHJvdmlkZXIudHMiLCAic3JjL3Byb3ZpZGVycy9pbmRleC50cyIsICJzcmMvc2V0dGluZ3MvdGFiLnRzIiwgInNyYy9zZXR0aW5ncy9wcm92aWRlci1tb2RhbC50cyIsICJzcmMvc2V0dGluZ3MvaW5kZXgudHMiLCAic3JjL2NvbXBsZXRpb24vaW5kZXgudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IElubGluZUNvbXBsZXRpb25PcHRpb25zLCBTdWdnZXN0aW9uLCBpbmxpbmVTdWdnZXN0aW9ucyB9IGZyb20gXCIuL2V4dGVuc2lvblwiO1xuaW1wb3J0IHsgU2V0dGluZ3MsIERFRkFVTFRfU0VUVElOR1MsIFByb2ZpbGUsIERFRkFVTFRfUFJPRklMRSB9IGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHsgSW5zY3JpYmVTZXR0aW5nc1RhYiB9IGZyb20gXCIuL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBidWlsZFByb3ZpZGVycywgUHJvdmlkZXJzIH0gZnJvbSAnLi9wcm92aWRlcnMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVDb21wbGV0aW9uLCByZXNvbHZlUHJvZmlsZSB9IGZyb20gJy4vY29tcGxldGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluc2NyaWJlIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IFNldHRpbmdzO1xuXHRwcm92aWRlcnM6IFByb3ZpZGVycztcblx0aW5saW5lU3VnZ2VzdGlvbk9wdGlvbnM6IElubGluZUNvbXBsZXRpb25PcHRpb25zID0geyBkZWxheU1zOiAzMDAsIHNwbGl0U3RyYXRlZ3k6IFwic2VudGVuY2VcIiB9O1xuXG5cdGFzeW5jIG9ubG9hZCgpIHtcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXHRcdGF3YWl0IHRoaXMubG9hZFByb3ZpZGVycygpO1xuXHRcdGF3YWl0IHRoaXMuc2V0dXBFeHRlbnRpb24oKTtcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IEluc2NyaWJlU2V0dGluZ3NUYWIodGhpcy5hcHAsIHRoaXMpKTtcblx0fVxuXG5cdGFzeW5jIGxvYWRQcm92aWRlcnMoKSB7XG5cdFx0dGhpcy5wcm92aWRlcnMgPSBidWlsZFByb3ZpZGVycyh0aGlzLnNldHRpbmdzKTtcblx0fVxuXG5cdGFzeW5jIHNldHVwRXh0ZW50aW9uKCkge1xuXHRcdGNvbnN0IGdldE9wdGlvbnMgPSAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbmxpbmVTdWdnZXN0aW9uT3B0aW9ucztcblx0XHR9O1xuXG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gaW5saW5lU3VnZ2VzdGlvbnMoe1xuXHRcdFx0ZmV0Y2hGdW5jOiAoKSA9PiB0aGlzLmZldGNoU3VnZ2VzdGlvbnMoKSxcblx0XHRcdGdldE9wdGlvbnM6IGdldE9wdGlvbnMsXG5cdFx0fSk7XG5cdFx0dGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbihleHRlbnNpb24pO1xuXHR9XG5cblx0YXN5bmMgKiBmZXRjaFN1Z2dlc3Rpb25zKCk6IEFzeW5jR2VuZXJhdG9yPFN1Z2dlc3Rpb24+IHtcblx0XHRjb25zdCBhY3RpdmVFZGl0b3IgPSB0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlRWRpdG9yO1xuXHRcdGlmICghYWN0aXZlRWRpdG9yKSByZXR1cm47XG5cdFx0aWYgKCFhY3RpdmVFZGl0b3IuZWRpdG9yKSByZXR1cm47XG5cblx0XHRjb25zdCBmaWxlUGF0aCA9IGFjdGl2ZUVkaXRvci5maWxlPy5wYXRoIHx8ICcnO1xuXHRcdGNvbnN0IFtwcm92aWRlciwgcHJvZmlsZV0gPSByZXNvbHZlUHJvZmlsZSh0aGlzLnNldHRpbmdzLCB0aGlzLnByb3ZpZGVycywgZmlsZVBhdGgpO1xuXHRcdHRoaXMuaW5saW5lU3VnZ2VzdGlvbk9wdGlvbnMuZGVsYXlNcyA9IHByb2ZpbGUuZGVsYXlNcztcblx0XHR0aGlzLmlubGluZVN1Z2dlc3Rpb25PcHRpb25zLnNwbGl0U3RyYXRlZ3kgPSBwcm9maWxlLnNwbGl0U3RyYXRlZ3k7XG5cdFx0eWllbGQqIGdlbmVyYXRlQ29tcGxldGlvbihhY3RpdmVFZGl0b3IuZWRpdG9yLCBwcm92aWRlciwgcHJvZmlsZS5jb21wbGV0aW9uT3B0aW9ucyk7XG5cdH1cblxuXHRhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oXG5cdFx0XHR7fSxcblx0XHRcdERFRkFVTFRfU0VUVElOR1MsXG5cdFx0XHRhd2FpdCB0aGlzLmxvYWREYXRhKClcblx0XHQpO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdFx0YXdhaXQgdGhpcy5sb2FkUHJvdmlkZXJzKCk7XG5cdH1cbn0iLCAiLyoqXG4gKiBJbnRlbGxpZ2VudCBJbmxpbmUgQ29tcGxldGlvbnMgZm9yIENvZGVNaXJyb3JcbiAqXG4gKiBUaGlzIGV4dGVuc2lvbiBvZmZlcnMgQUktcG93ZXJlZCBpbmxpbmUgc3VnZ2VzdGlvbnMgd2l0aDpcbiAqIC0gQ29uZmlndXJhYmxlIHN1Z2dlc3Rpb24gZmV0Y2hpbmcgc3RyYXRlZ2llc1xuICogLSBNdWx0aXBsZSB0ZXh0IHNlZ21lbnRhdGlvbiBhcHByb2FjaGVzXG4gKiAtIERlYm91bmNlZCBuZXR3b3JrIHJlcXVlc3RzXG4gKiAtIE5vbi1pbnZhc2l2ZSBzdWdnZXN0aW9uIHJlbmRlcmluZ1xuICovXG5cbmltcG9ydCB7XG4gICAgVmlld1BsdWdpbixcbiAgICBFZGl0b3JWaWV3LFxuICAgIFZpZXdVcGRhdGUsXG4gICAgRGVjb3JhdGlvbixcbiAgICBXaWRnZXRUeXBlLFxuICAgIGtleW1hcCxcbn0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQge1xuICAgIFN0YXRlRWZmZWN0LFxuICAgIFRleHQsXG4gICAgU3RhdGVGaWVsZCxcbiAgICBFZGl0b3JTdGF0ZSxcbiAgICBFZGl0b3JTZWxlY3Rpb24sXG4gICAgVHJhbnNhY3Rpb24sXG4gICAgUHJlYyxcbn0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgVHlwZSBEZWZpbml0aW9uc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiogU3VwcG9ydGVkIHNlZ21lbnRhdGlvbiBzdHJhdGVnaWVzICovXG5leHBvcnQgdHlwZSBTcGxpdFN0cmF0ZWd5ID0ga2V5b2YgdHlwZW9mIFRleHRTcGxpdFN0cmF0ZWdpZXM7XG5cbi8qKiBJbmxpbmUgc3VnZ2VzdGlvbiBzdHJ1Y3R1cmUgXHUyMDEzIG5vdyBvbmx5IGNhcnJpZXMgdGV4dC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3VnZ2VzdGlvbiB7XG4gICAgdGV4dDogc3RyaW5nO1xufVxuXG4vKiogSW5saW5lIGNvbXBsZXRpb24gY29uZmlndXJhdGlvbi5cbiAqIFxuICogTm90ZTogSW5zdGVhZCBvZiBlYWNoIHN1Z2dlc3Rpb24gY2FycnlpbmcgaXRzIHNwbGl0IHN0cmF0ZWd5LFxuICogeW91IHN1cHBseSBhIGR5bmFtaWMgZ2V0dGVyIGZ1bmN0aW9uIChgZ2V0T3B0aW9uc2ApIHNvIHRoYXQgdGhlIGV4dGVuc2lvblxuICogYWx3YXlzIHVzZXMgdGhlIGN1cnJlbnQgc2V0dGluZ3MuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5saW5lQ29tcGxldGlvbkNvbmZpZyB7XG4gICAgZmV0Y2hGdW5jOiAoXG4gICAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgICkgPT4gQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj4gfCBQcm9taXNlPFN1Z2dlc3Rpb24+O1xuICAgIC8qKiAoT3B0aW9uYWwpIEEgc3RhdGljIGhvdGtleSBmb3IgYWNjZXB0aW5nIHN1Z2dlc3Rpb25zLiAqL1xuICAgIGFjY2VwdGFuY2VIb3RrZXk/OiBzdHJpbmc7XG4gICAgLyoqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGN1cnJlbnQgb3B0aW9ucy4gKi9cbiAgICBnZXRPcHRpb25zOiAoKSA9PiBJbmxpbmVDb21wbGV0aW9uT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmxpbmVDb21wbGV0aW9uT3B0aW9ucyB7XG4gICAgZGVsYXlNcz86IG51bWJlcjtcbiAgICBzcGxpdFN0cmF0ZWd5PzogU3BsaXRTdHJhdGVneTtcbn1cblxuLyoqIEludGVybmFsIHN0YXRlIGZvciB0aGUgY3VycmVudCBzdWdnZXN0aW9uIHNlc3Npb24uXG4gKiBOb3RlOiBUaGUgcHJldmlvdXMgXCJzZWdtZW50YXRpb25cIiBwcm9wZXJ0eSBoYXMgYmVlbiByZW1vdmVkLlxuICovXG5pbnRlcmZhY2UgU3VnZ2VzdGlvblNlc3Npb24ge1xuICAgIGZ1bGxUZXh0OiBzdHJpbmcgfCBudWxsO1xuICAgIHJlbWFpbmluZ1RleHQ6IHN0cmluZyB8IG51bGw7XG4gICAgYmFzZWxpbmVEb2N1bWVudDogVGV4dCB8IG51bGw7XG4gICAgYW5jaG9yUG9zaXRpb246IG51bWJlciB8IG51bGw7XG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICBUZXh0IFNlZ21lbnRhdGlvbiBTdHJhdGVnaWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKlxuICogQSBzZXQgb2YgdGV4dCBzcGxpdHRpbmcgZnVuY3Rpb25zIHVzZWQgdG8gZGV0ZXJtaW5lIGhvdyBtdWNoIG9mIHRoZVxuICogc3VnZ2VzdGlvbiB0byBhY2NlcHQgd2hlbiB0cmlnZ2VyZWQuXG4gKi9cbmNvbnN0IFRleHRTcGxpdFN0cmF0ZWdpZXMgPSB7XG4gICAgLyoqXG4gICAgICogV29yZC1sZXZlbCBzZWdtZW50YXRpb24gKHNwYWNlLWRlbGltaXRlZCkuXG4gICAgICogQWNjZXB0cyB0ZXh0IHVudGlsIChhbmQgaW5jbHVkaW5nKSB0aGUgZmlyc3Qgc3BhY2UuXG4gICAgICovXG4gICAgd29yZDogKHRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBuZXh0U3BhY2UgPSB0ZXh0LmluZGV4T2YoJyAnKTtcbiAgICAgICAgcmV0dXJuIG5leHRTcGFjZSA9PT0gLTFcbiAgICAgICAgICAgID8geyBhY2NlcHRlZDogdGV4dCwgcmVtYWluaW5nOiAnJyB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBhY2NlcHRlZDogdGV4dC5zbGljZSgwLCBuZXh0U3BhY2UgKyAxKSxcbiAgICAgICAgICAgICAgICByZW1haW5pbmc6IHRleHQuc2xpY2UobmV4dFNwYWNlICsgMSksXG4gICAgICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW50ZW5jZS1sZXZlbCBzZWdtZW50YXRpb24gKHB1bmN0dWF0aW9uIGZvbGxvd2VkIGJ5IHdoaXRlc3BhY2UpLlxuICAgICAqL1xuICAgIHNlbnRlbmNlOiAodGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGV4dC5tYXRjaCgvWy4hP11cXHMrLyk7XG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjY2VwdGVkOiB0ZXh0LnNsaWNlKDAsIG1hdGNoLmluZGV4ICsgMSksXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nOiB0ZXh0LnNsaWNlKG1hdGNoLmluZGV4ICsgMSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGFjY2VwdGVkOiB0ZXh0LCByZW1haW5pbmc6ICcnIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcmFncmFwaC1sZXZlbCBzZWdtZW50YXRpb24gKGRvdWJsZSBuZXdsaW5lKS5cbiAgICAgKi9cbiAgICBwYXJhZ3JhcGg6ICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoRW5kID0gdGV4dC5pbmRleE9mKCdcXG5cXG4nKTtcbiAgICAgICAgcmV0dXJuIHBhcmFncmFwaEVuZCA9PT0gLTFcbiAgICAgICAgICAgID8geyBhY2NlcHRlZDogdGV4dCwgcmVtYWluaW5nOiAnJyB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBhY2NlcHRlZDogdGV4dC5zbGljZSgwLCBwYXJhZ3JhcGhFbmQgKyAyKSxcbiAgICAgICAgICAgICAgICByZW1haW5pbmc6IHRleHQuc2xpY2UocGFyYWdyYXBoRW5kICsgMiksXG4gICAgICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdG9taWMgYWNjZXB0YW5jZSBcdTIwMTMgY29uc3VtZSB0aGUgZW50aXJlIHN1Z2dlc3Rpb24uXG4gICAgICovXG4gICAgZnVsbDogKHRleHQ6IHN0cmluZykgPT4gKHsgYWNjZXB0ZWQ6IHRleHQsIHJlbWFpbmluZzogJycgfSksXG59IGFzIGNvbnN0O1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgU3VnZ2VzdGlvbiBTZXNzaW9uIFN0YXRlIE1hbmFnZW1lbnRcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyoqXG4gKiBFZmZlY3QgdG8gdXBkYXRlIHRoZSBzdWdnZXN0aW9uIHNlc3Npb24gc3RhdGUuXG4gKiBBIGBudWxsYCBjb250ZW50IHNpZ25hbHMgYSByZXNldC5cbiAqL1xuY29uc3QgU3VnZ2VzdGlvblVwZGF0ZUVmZmVjdCA9IFN0YXRlRWZmZWN0LmRlZmluZTx7XG4gICAgY29udGVudDogc3RyaW5nIHwgbnVsbDtcbiAgICBkb2N1bWVudDogVGV4dCB8IG51bGw7XG4gICAgYW5jaG9yOiBudW1iZXIgfCBudWxsO1xufT4oKTtcblxuLyoqXG4gKiBUaGUgc3RhdGUgZmllbGQgdGhhdCBob2xkcyB0aGUgY3VycmVudCBzdWdnZXN0aW9uIHNlc3Npb24uXG4gKi9cbmNvbnN0IHN1Z2dlc3Rpb25TZXNzaW9uU3RhdGUgPSBTdGF0ZUZpZWxkLmRlZmluZTxTdWdnZXN0aW9uU2Vzc2lvbj4oe1xuICAgIGNyZWF0ZTogKCkgPT4gZ2V0UmVzZXRTZXNzaW9uKCksXG5cbiAgICB1cGRhdGUoc2Vzc2lvbiwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gUHJvY2VzcyBleHBsaWNpdCBzZXNzaW9uIHVwZGF0ZSBlZmZlY3RzLlxuICAgICAgICBjb25zdCBlZmZlY3QgPSB0cmFuc2FjdGlvbi5lZmZlY3RzLmZpbmQoKGUpID0+XG4gICAgICAgICAgICBlLmlzKFN1Z2dlc3Rpb25VcGRhdGVFZmZlY3QpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlZmZlY3QpIHJldHVybiB1cGRhdGVTZXNzaW9uRnJvbUVmZmVjdChlZmZlY3QudmFsdWUpO1xuXG4gICAgICAgIC8vIElmIHRoZSBkb2N1bWVudCBoYXMgY2hhbmdlZCwgYWRqdXN0IHRoZSBzZXNzaW9uLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkICYmXG4gICAgICAgICAgICBzZXNzaW9uLnJlbWFpbmluZ1RleHQgJiZcbiAgICAgICAgICAgIHNlc3Npb24uYW5jaG9yUG9zaXRpb24gIT09IG51bGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU2Vzc2lvbk9uRG9jdW1lbnRDaGFuZ2Uoc2Vzc2lvbiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gYWN0aXZlIHN1Z2dlc3Rpb24gYnV0IHRoZSBjdXJzb3IgaGFzIG1vdmVkLCBjYW5jZWwgaXQuXG4gICAgICAgIGlmIChzZXNzaW9uLnJlbWFpbmluZ1RleHQgIT09IG51bGwgJiYgc2Vzc2lvbi5hbmNob3JQb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNlc3Npb25PbkN1cnNvckRyaWZ0KHNlc3Npb24sIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgIH0sXG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnJlc2gsIGVtcHR5IHN1Z2dlc3Rpb24gc2Vzc2lvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVzZXRTZXNzaW9uKCk6IFN1Z2dlc3Rpb25TZXNzaW9uIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmdWxsVGV4dDogbnVsbCxcbiAgICAgICAgcmVtYWluaW5nVGV4dDogbnVsbCxcbiAgICAgICAgYmFzZWxpbmVEb2N1bWVudDogbnVsbCxcbiAgICAgICAgYW5jaG9yUG9zaXRpb246IG51bGwsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgc2Vzc2lvbiBzdGF0ZSBiYXNlZCBvbiBhbiBpbmNvbWluZyBlZmZlY3QuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVNlc3Npb25Gcm9tRWZmZWN0KGVmZmVjdDoge1xuICAgIGNvbnRlbnQ6IHN0cmluZyB8IG51bGw7XG4gICAgZG9jdW1lbnQ6IFRleHQgfCBudWxsO1xuICAgIGFuY2hvcjogbnVtYmVyIHwgbnVsbDtcbn0pOiBTdWdnZXN0aW9uU2Vzc2lvbiB7XG4gICAgcmV0dXJuIGVmZmVjdC5jb250ZW50ID09PSBudWxsXG4gICAgICAgID8gZ2V0UmVzZXRTZXNzaW9uKClcbiAgICAgICAgOiBpbml0aWFsaXplU2Vzc2lvbihlZmZlY3QgYXMge1xuICAgICAgICAgICAgY29udGVudDogc3RyaW5nO1xuICAgICAgICAgICAgZG9jdW1lbnQ6IFRleHQ7XG4gICAgICAgICAgICBhbmNob3I6IG51bWJlcjtcbiAgICAgICAgfSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBuZXcgc3VnZ2VzdGlvbiBzZXNzaW9uIHdpdGggcHJvdmlkZWQgZWZmZWN0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVTZXNzaW9uKGVmZmVjdDoge1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICBkb2N1bWVudDogVGV4dDtcbiAgICBhbmNob3I6IG51bWJlcjtcbn0pOiBTdWdnZXN0aW9uU2Vzc2lvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVsbFRleHQ6IGVmZmVjdC5jb250ZW50LFxuICAgICAgICByZW1haW5pbmdUZXh0OiBlZmZlY3QuY29udGVudCxcbiAgICAgICAgYmFzZWxpbmVEb2N1bWVudDogZWZmZWN0LmRvY3VtZW50LFxuICAgICAgICBhbmNob3JQb3NpdGlvbjogZWZmZWN0LmFuY2hvcixcbiAgICB9O1xufVxuXG4vKipcbiAqIEFkanVzdCB0aGUgc3VnZ2VzdGlvbiBzZXNzaW9uIGluIHJlc3BvbnNlIHRvIGRvY3VtZW50IGNoYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVNlc3Npb25PbkRvY3VtZW50Q2hhbmdlKFxuICAgIHNlc3Npb246IFN1Z2dlc3Rpb25TZXNzaW9uLFxuICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuKTogU3VnZ2VzdGlvblNlc3Npb24ge1xuICAgIGxldCBpbnNlcnRlZENvbnRlbnQgPSAnJztcbiAgICBsZXQgaW5zZXJ0aW9uQXRBbmNob3IgPSBmYWxzZTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBkb2N1bWVudCBjaGFuZ2VzIHRvIGRldGVjdCBhbiBpbnNlcnRpb24gYXQgdGhlIHN1Z2dlc3Rpb24ncyBhbmNob3IuXG4gICAgdHJhbnNhY3Rpb24uY2hhbmdlcy5pdGVyQ2hhbmdlcygoZnJvbUEsIHRvQSwgX2Zyb21CLCBfdG9CLCBpbnNlcnRlZCkgPT4ge1xuICAgICAgICBpZiAoZnJvbUEgPT09IHNlc3Npb24uYW5jaG9yUG9zaXRpb24gJiYgdG9BID09PSBmcm9tQSkge1xuICAgICAgICAgICAgaW5zZXJ0ZWRDb250ZW50ID0gaW5zZXJ0ZWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGluc2VydGlvbkF0QW5jaG9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFpbnNlcnRpb25BdEFuY2hvciB8fCAhc2Vzc2lvbi5yZW1haW5pbmdUZXh0KSB7XG4gICAgICAgIHJldHVybiBpbnZhbGlkYXRlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgdGhlIGluc2VydGVkIHRleHQgbWF0Y2hlcyB0aGUgcGVuZGluZyBzdWdnZXN0aW9uLlxuICAgIGlmIChzZXNzaW9uLnJlbWFpbmluZ1RleHQuc3RhcnRzV2l0aChpbnNlcnRlZENvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiBhZHZhbmNlU2Vzc2lvbihzZXNzaW9uLCBpbnNlcnRlZENvbnRlbnQubGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW52YWxpZGF0ZVNlc3Npb24oc2Vzc2lvbik7XG59XG5cbi8qKlxuICogQWR2YW5jZSB0aGUgc2Vzc2lvbiBieSBjb25zdW1pbmcgYWNjZXB0ZWQgdGV4dC5cbiAqL1xuZnVuY3Rpb24gYWR2YW5jZVNlc3Npb24oXG4gICAgc2Vzc2lvbjogU3VnZ2VzdGlvblNlc3Npb24sXG4gICAgY29uc3VtZWRMZW5ndGg6IG51bWJlclxuKTogU3VnZ2VzdGlvblNlc3Npb24ge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnNlc3Npb24sXG4gICAgICAgIHJlbWFpbmluZ1RleHQ6XG4gICAgICAgICAgICBzZXNzaW9uLnJlbWFpbmluZ1RleHQhLnNsaWNlKGNvbnN1bWVkTGVuZ3RoKS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBzZXNzaW9uLnJlbWFpbmluZ1RleHQhLnNsaWNlKGNvbnN1bWVkTGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgYW5jaG9yUG9zaXRpb246IHNlc3Npb24uYW5jaG9yUG9zaXRpb24hICsgY29uc3VtZWRMZW5ndGgsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBJbnZhbGlkYXRlIHRoZSBzZXNzaW9uLCBlZmZlY3RpdmVseSBjYW5jZWxsaW5nIGFueSBwZW5kaW5nIHN1Z2dlc3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRhdGVTZXNzaW9uKHNlc3Npb246IFN1Z2dlc3Rpb25TZXNzaW9uKTogU3VnZ2VzdGlvblNlc3Npb24ge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnNlc3Npb24sXG4gICAgICAgIHJlbWFpbmluZ1RleHQ6IG51bGwsXG4gICAgICAgIGFuY2hvclBvc2l0aW9uOiBudWxsLFxuICAgIH07XG59XG5cbi8qKlxuICogQ2FuY2VsIHRoZSBzdWdnZXN0aW9uIGlmIHRoZSBjdXJzb3IgaGFzIGRyaWZ0ZWQgYXdheS5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlU2Vzc2lvbk9uQ3Vyc29yRHJpZnQoXG4gICAgc2Vzc2lvbjogU3VnZ2VzdGlvblNlc3Npb24sXG4gICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG4pOiBTdWdnZXN0aW9uU2Vzc2lvbiB7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQgIT09IHNlc3Npb24uYW5jaG9yUG9zaXRpb25cbiAgICAgICAgPyBpbnZhbGlkYXRlU2Vzc2lvbihzZXNzaW9uKVxuICAgICAgICA6IHNlc3Npb247XG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICBTdWdnZXN0aW9uIFJlbmRlcmluZyAoVmlzdWFsaXphdGlvbiBMYXllcilcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyoqXG4gKiBXaWRnZXQgZm9yIHJlbmRlcmluZyBpbmxpbmUgc3VnZ2VzdGlvbiB0ZXh0LlxuICovXG5jbGFzcyBTdWdnZXN0aW9uV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgc3RhdGljIHJlYWRvbmx5IE9QQUNJVFkgPSAwLjQ7XG4gICAgc3RhdGljIHJlYWRvbmx5IENTU19DTEFTUyA9ICdjbS1pbmxpbmUtcHJlZGljdGlvbic7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNvbnRlbnQ6IHN0cmluZykge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHRvRE9NKCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBTdWdnZXN0aW9uV2lkZ2V0LkNTU19DTEFTUztcbiAgICAgICAgc3Bhbi5zdHlsZS5vcGFjaXR5ID0gU3VnZ2VzdGlvbldpZGdldC5PUEFDSVRZLnRvU3RyaW5nKCk7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQbHVnaW4gdGhhdCByZW5kZXJzIGlubGluZSBzdWdnZXN0aW9uIGRlY29yYXRpb25zLlxuICovXG5jb25zdCBzdWdnZXN0aW9uUmVuZGVyZXIgPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhcbiAgICBjbGFzcyB7XG4gICAgICAgIGRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuXG4gICAgICAgIHVwZGF0ZSh1cGRhdGU6IFZpZXdVcGRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSB1cGRhdGUuc3RhdGUuZmllbGQoc3VnZ2VzdGlvblNlc3Npb25TdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gc2Vzc2lvbi5yZW1haW5pbmdUZXh0XG4gICAgICAgICAgICAgICAgPyB0aGlzLmNyZWF0ZURlY29yYXRpb24odXBkYXRlLnZpZXcsIHNlc3Npb24ucmVtYWluaW5nVGV4dClcbiAgICAgICAgICAgICAgICA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaXZhdGUgY3JlYXRlRGVjb3JhdGlvbih2aWV3OiBFZGl0b3JWaWV3LCBzdWdnZXN0aW9uVGV4dDogc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChbXG4gICAgICAgICAgICAgICAgRGVjb3JhdGlvbi53aWRnZXQoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBTdWdnZXN0aW9uV2lkZ2V0KHN1Z2dlc3Rpb25UZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgc2lkZTogMSxcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShjdXJzb3JQb3NpdGlvbiksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgeyBkZWNvcmF0aW9uczogKHYpID0+IHYuZGVjb3JhdGlvbnMgfVxuKTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgIFN1Z2dlc3Rpb24gRmV0Y2hpbmcgKERlYm91bmNlZCBGZXRjaGVyKVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZmV0Y2hlciBmb3Igc3VnZ2VzdGlvbnMuXG4gKlxuICogQHBhcmFtIGZldGNoIC0gVGhlIHN1Z2dlc3Rpb24gZmV0Y2ggZnVuY3Rpb24uXG4gKiBAcGFyYW0gZ2V0RGVsYXkgLSBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY3VycmVudCBkZWJvdW5jZSBkZWxheSBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmNvbnN0IGNyZWF0ZURlYm91bmNlZEZldGNoZXIgPSAoXG4gICAgZmV0Y2g6IChzdGF0ZTogRWRpdG9yU3RhdGUpID0+IEFzeW5jR2VuZXJhdG9yPFN1Z2dlc3Rpb24+LFxuICAgIGdldERlbGF5OiAoKSA9PiBudW1iZXJcbikgPT4ge1xuICAgIGxldCBhY3RpdmVSZXF1ZXN0ID0gdHJ1ZTtcbiAgICBsZXQgdGltZW91dElkOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PjtcblxuICAgIC8qKlxuICAgICAqIFRocm90dGxlZCBmZXRjaCB0aGF0IHdhaXRzIGZvciB0aGUgZGVib3VuY2UgaW50ZXJ2YWwuXG4gICAgICovXG4gICAgY29uc3QgdGhyb3R0bGVkRmV0Y2ggPSBhc3luYyBmdW5jdGlvbiogKHN0YXRlOiBFZGl0b3JTdGF0ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgYWN0aXZlUmVxdWVzdCA9IHRydWU7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIGdldERlbGF5KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFjdGl2ZVJlcXVlc3QpIHlpZWxkKiBmZXRjaChzdGF0ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBsdWdpbiB0aGF0IGluaXRpYXRlcyBzdWdnZXN0aW9uIGZldGNoaW5nIG9uIGRvY3VtZW50IGNoYW5nZXMuXG4gICAgICovXG4gICAgY29uc3QgZmV0Y2hlclBsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKFxuICAgICAgICBjbGFzcyB7XG4gICAgICAgICAgICBwcml2YXRlIGN1cnJlbnRSZXF1ZXN0SWQgPSAwO1xuXG4gICAgICAgICAgICBhc3luYyB1cGRhdGUodXBkYXRlOiBWaWV3VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB1cGRhdGUuc3RhdGU7XG4gICAgICAgICAgICAgICAgLy8gT25seSB0cmlnZ2VyIGZldGNoIGlmIHRoZXJlIGlzIG5vIGFjdGl2ZSBzdWdnZXN0aW9uLlxuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlLmRvY0NoYW5nZWQgfHwgc3RhdGUuZmllbGQoc3VnZ2VzdGlvblNlc3Npb25TdGF0ZSkucmVtYWluaW5nVGV4dClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gKyt0aGlzLmN1cnJlbnRSZXF1ZXN0SWQ7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBzdWdnZXN0aW9uIG9mIHRocm90dGxlZEZldGNoKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgc3RhbGUgcmVxdWVzdHMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SWQgIT09IHRoaXMuY3VycmVudFJlcXVlc3RJZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBTdWdnZXN0aW9uVXBkYXRlRWZmZWN0Lm9mKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzdWdnZXN0aW9uLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHN0YXRlLmRvYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZldGNoZXJQbHVnaW4sXG4gICAgICAgIHRlcm1pbmF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgYWN0aXZlUmVxdWVzdCA9IGZhbHNlO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICBVc2VyIEludGVyYWN0aW9uIChBY2NlcHRhbmNlIEhhbmRsZXIpXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKlxuICogUmV0dXJucyBhIGtleSBiaW5kaW5nIHRoYXQgYWNjZXB0cyB0aGUgY3VycmVudCBzdWdnZXN0aW9uLlxuICpcbiAqIEBwYXJhbSB0ZXJtaW5hdGVGZXRjaCAtIEZ1bmN0aW9uIHRvIHN0b3AgZnVydGhlciBmZXRjaGluZy5cbiAqIEBwYXJhbSBob3RrZXkgLSBUaGUga2V5IHRoYXQgdHJpZ2dlcnMgYWNjZXB0YW5jZS5cbiAqIEBwYXJhbSBnZXRPcHRpb25zIC0gRnVuY3Rpb24gcmV0dXJuaW5nIGR5bmFtaWMgb3B0aW9ucyAoaW5jbHVkaW5nIHNwbGl0U3RyYXRlZ3kpLlxuICovXG5jb25zdCBjcmVhdGVBY2NlcHRhbmNlSGFuZGxlciA9IChcbiAgICB0ZXJtaW5hdGVGZXRjaDogKCkgPT4gdm9pZCxcbiAgICBob3RrZXk6IHN0cmluZyxcbiAgICBnZXRPcHRpb25zOiAoKSA9PiB7IGRlbGF5TXM/OiBudW1iZXI7IHNwbGl0U3RyYXRlZ3k/OiBTcGxpdFN0cmF0ZWd5IH1cbikgPT5cbiAgICBQcmVjLmhpZ2hlc3QoXG4gICAgICAgIGtleW1hcC5vZihbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5OiBob3RrZXksXG4gICAgICAgICAgICAgICAgcnVuOiAodmlldzogRWRpdG9yVmlldykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gdmlldy5zdGF0ZS5maWVsZChzdWdnZXN0aW9uU2Vzc2lvblN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uLnJlbWFpbmluZ1RleHQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgb2J0YWluIHRoZSBjdXJyZW50IHNwbGl0IHN0cmF0ZWd5IGZyb20gZ2V0T3B0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHluYW1pY09wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRhdGlvbktleSA9IGR5bmFtaWNPcHRpb25zLnNwbGl0U3RyYXRlZ3kgPz8gJ3dvcmQnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGFjY2VwdGVkLCByZW1haW5pbmcgfSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBUZXh0U3BsaXRTdHJhdGVnaWVzW3NlZ21lbnRhdGlvbktleV0oc2Vzc2lvbi5yZW1haW5pbmdUZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFjY2VwdGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBhY2NlcHRlZCBzdWdnZXN0aW9uIHRleHQuXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uaW5zZXJ0Q29tcGxldGlvbih2aWV3LnN0YXRlLCBhY2NlcHRlZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBTdWdnZXN0aW9uVXBkYXRlRWZmZWN0Lm9mKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiByZW1haW5pbmcgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogcmVtYWluaW5nID8gc2Vzc2lvbi5iYXNlbGluZURvY3VtZW50IDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3I6IHJlbWFpbmluZyA/IHNlc3Npb24uYW5jaG9yUG9zaXRpb24hICsgYWNjZXB0ZWQubGVuZ3RoIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbWFpbmluZykgdGVybWluYXRlRmV0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pXG4gICAgKTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gY3JlYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBpbnNlcnRzIGNvbXBsZXRpb24gdGV4dC5cbiAqL1xuY29uc3QgaW5zZXJ0Q29tcGxldGlvbiA9IChzdGF0ZTogRWRpdG9yU3RhdGUsIHRleHQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IGN1cnNvclBvcyA9IHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUuY2hhbmdlQnlSYW5nZSgoKSA9PiAoe1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiBjdXJzb3JQb3MsIGluc2VydDogdGV4dCB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoY3Vyc29yUG9zICsgdGV4dC5sZW5ndGgpLFxuICAgICAgICB9KSksXG4gICAgICAgIHVzZXJFdmVudDogJ2NvbXBsZXRpb24uYWNjZXB0JyxcbiAgICB9O1xufTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgIFB1YmxpYyBBUElcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyoqXG4gKiBUaGUgbWFpbiBleHRlbnNpb24gZnVuY3Rpb24uIEl0IHdpcmVzIHVwIHNlc3Npb24gc3RhdGUgbWFuYWdlbWVudCxcbiAqIHN1Z2dlc3Rpb24gZmV0Y2hpbmcsIHJlbmRlcmluZywgYW5kIHVzZXIgaW50ZXJhY3Rpb24uXG4gKlxuICogTm90aWNlIHRoYXQgdGhlIHN1Z2dlc3Rpb24gbm93IG9ubHkgY29udGFpbnMgdGV4dC5cbiAqIFRoZSBzcGxpdCBzdHJhdGVneSBpcyBhbHdheXMgb2J0YWluZWQgZHluYW1pY2FsbHkgdmlhIGBnZXRPcHRpb25zKClgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5saW5lU3VnZ2VzdGlvbnMoY29uZmlnOiBJbmxpbmVDb21wbGV0aW9uQ29uZmlnKSB7XG4gICAgY29uc3QgeyBmZXRjaEZ1bmMsIGdldE9wdGlvbnMgfSA9IGNvbmZpZztcbiAgICAvLyBVc2UgdGhlIGhvdGtleSBmcm9tIHRoZSBjb25maWcgaWYgcHJvdmlkZWQ7IG90aGVyd2lzZSwgZGVmYXVsdCB0byBcIlRhYlwiLlxuICAgIGNvbnN0IHN0YXRpY0hvdGtleSA9IGNvbmZpZy5hY2NlcHRhbmNlSG90a2V5IHx8ICdUYWInO1xuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBmZXRjaCBmdW5jdGlvbiB0byBhbHdheXMgcmV0dXJuIGFuIGFzeW5jIGdlbmVyYXRvci5cbiAgICBjb25zdCBub3JtYWxpemVGZXRjaCA9IGFzeW5jIGZ1bmN0aW9uKiAoc3RhdGU6IEVkaXRvclN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoRnVuYyhzdGF0ZSk7XG4gICAgICAgIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgIHlpZWxkKiByZXN1bHQgYXMgQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCByZXN1bHQgYXMgU3VnZ2VzdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBVc2UgZ2V0T3B0aW9ucygpIHRvIG9idGFpbiB0aGUgY3VycmVudCBkZWJvdW5jZSBkZWxheS5cbiAgICBjb25zdCBnZXREZWxheSA9ICgpID0+IGdldE9wdGlvbnMoKS5kZWxheU1zID8/IDMwMDtcbiAgICBjb25zdCB7IGZldGNoZXJQbHVnaW4sIHRlcm1pbmF0ZSB9ID0gY3JlYXRlRGVib3VuY2VkRmV0Y2hlcihub3JtYWxpemVGZXRjaCwgZ2V0RGVsYXkpO1xuICAgIGNvbnN0IGFjY2VwdGFuY2VIYW5kbGVyID0gY3JlYXRlQWNjZXB0YW5jZUhhbmRsZXIodGVybWluYXRlLCBzdGF0aWNIb3RrZXksIGdldE9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3VnZ2VzdGlvblNlc3Npb25TdGF0ZSxcbiAgICAgICAgZmV0Y2hlclBsdWdpbixcbiAgICAgICAgc3VnZ2VzdGlvblJlbmRlcmVyLFxuICAgICAgICBhY2NlcHRhbmNlSGFuZGxlcixcbiAgICBdO1xufVxuIiwgImltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSBcIi4uXCI7XG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IE9wZW5BSVNldHRpbmdzIH0gZnJvbSBcIi5cIjtcblxuZXhwb3J0IGNsYXNzIE9wZW5BSVByb3ZpZGVyIGltcGxlbWVudHMgUHJvdmlkZXIge1xuICAgIHNldHRpbmdzOiBPcGVuQUlTZXR0aW5nc1xuICAgIG1vZGVsczogc3RyaW5nW107XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IE9wZW5BSVNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9XG4gICAgZ2VuZXJhdGU6IChlZGl0b3I6IEVkaXRvcikgPT4gQXN5bmNHZW5lcmF0b3I8c3RyaW5nPjtcbiAgICBhYm9ydDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgICB1cGRhdGVNb2RlbHMoKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gW1wiZ3B0LTRcIiwgXCJkYXZpbmNpXCJdO1xuICAgIH1cbn0iLCAiaW1wb3J0IGZzLCB7IHByb21pc2VzIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgcmVzb2x2ZSB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgT2xsYW1hIGFzIE9sbGFtYSQxIH0gZnJvbSAnLi9icm93c2VyLm1qcyc7XG5pbXBvcnQgJ3doYXR3Zy1mZXRjaCc7XG5cbmNsYXNzIE9sbGFtYSBleHRlbmRzIE9sbGFtYSQxIHtcbiAgYXN5bmMgZW5jb2RlSW1hZ2UoaW1hZ2UpIHtcbiAgICBpZiAodHlwZW9mIGltYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oaW1hZ2UpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoaW1hZ2UpKSB7XG4gICAgICAgIGNvbnN0IGZpbGVCdWZmZXIgPSBhd2FpdCBwcm9taXNlcy5yZWFkRmlsZShyZXNvbHZlKGltYWdlKSk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShmaWxlQnVmZmVyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG4gIC8qKlxuICAgKiBjaGVja3MgaWYgYSBmaWxlIGV4aXN0c1xuICAgKiBAcGFyYW0gcGF0aCB7c3RyaW5nfSAtIFRoZSBwYXRoIHRvIHRoZSBmaWxlXG4gICAqIEBwcml2YXRlIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gLSBXaGV0aGVyIHRoZSBmaWxlIGV4aXN0cyBvciBub3RcbiAgICovXG4gIGFzeW5jIGZpbGVFeGlzdHMocGF0aCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm9taXNlcy5hY2Nlc3MocGF0aCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlKHJlcXVlc3QpIHtcbiAgICBpZiAocmVxdWVzdC5mcm9tICYmIGF3YWl0IHRoaXMuZmlsZUV4aXN0cyhyZXNvbHZlKHJlcXVlc3QuZnJvbSkpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNyZWF0aW5nIHdpdGggYSBsb2NhbCBwYXRoIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGZyb20gb2xsYW1hLWpzXCIpO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdC5zdHJlYW0pIHtcbiAgICAgIHJldHVybiBzdXBlci5jcmVhdGUocmVxdWVzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5jcmVhdGUocmVxdWVzdCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBpbmRleCA9IG5ldyBPbGxhbWEoKTtcblxuZXhwb3J0IHsgT2xsYW1hLCBpbmRleCBhcyBkZWZhdWx0IH07XG4iLCAiLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG52YXIgZyA9XG4gICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbCkgfHxcbiAge31cblxudmFyIHN1cHBvcnQgPSB7XG4gIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gZyxcbiAgaXRlcmFibGU6ICdTeW1ib2wnIGluIGcgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gIGJsb2I6XG4gICAgJ0ZpbGVSZWFkZXInIGluIGcgJiZcbiAgICAnQmxvYicgaW4gZyAmJlxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gZyxcbiAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gZ1xufVxuXG5mdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbn1cblxuaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gIF1cblxuICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPVxuICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgfVxuICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5eX2B8fiFdL2kudGVzdChuYW1lKSB8fCBuYW1lID09PSAnJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiJylcbiAgfVxuICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG5mdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX1cbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvclxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gIHRoaXMubWFwID0ge31cblxuICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIGlmIChoZWFkZXIubGVuZ3RoICE9IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGVhZGVycyBjb25zdHJ1Y3RvcjogZXhwZWN0ZWQgbmFtZS92YWx1ZSBwYWlyIHRvIGJlIGxlbmd0aCAyLCBmb3VuZCcgKyBoZWFkZXIubGVuZ3RoKVxuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG4gICAgfSwgdGhpcylcbiAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgIH0sIHRoaXMpXG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV1cbiAgdGhpcy5tYXBbbmFtZV0gPSBvbGRWYWx1ZSA/IG9sZFZhbHVlICsgJywgJyArIHZhbHVlIDogdmFsdWVcbn1cblxuSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpXG4gICAgfVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgaXRlbXMucHVzaChuYW1lKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpdGVtcy5wdXNoKHZhbHVlKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbmlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgaWYgKGJvZHkuX25vQm9keSkgcmV0dXJuXG4gIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICB9XG4gIGJvZHkuYm9keVVzZWQgPSB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICB9XG4gICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgdmFyIG1hdGNoID0gL2NoYXJzZXQ9KFtBLVphLXowLTlfLV0rKS8uZXhlYyhibG9iLnR5cGUpXG4gIHZhciBlbmNvZGluZyA9IG1hdGNoID8gbWF0Y2hbMV0gOiAndXRmLTgnXG4gIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IsIGVuY29kaW5nKVxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gIH1cbiAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICB9IGVsc2Uge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBCb2R5KCkge1xuICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAvKlxuICAgICAgZmV0Y2gtbW9jayB3cmFwcyB0aGUgUmVzcG9uc2Ugb2JqZWN0IGluIGFuIEVTNiBQcm94eSB0b1xuICAgICAgcHJvdmlkZSB1c2VmdWwgdGVzdCBoYXJuZXNzIGZlYXR1cmVzIHN1Y2ggYXMgZmx1c2guIEhvd2V2ZXIsIG9uXG4gICAgICBFUzUgYnJvd3NlcnMgd2l0aG91dCBmZXRjaCBvciBQcm94eSBzdXBwb3J0IHBvbGx5ZmlsbHMgbXVzdCBiZSB1c2VkO1xuICAgICAgdGhlIHByb3h5LXBvbGx5ZmlsbCBpcyB1bmFibGUgdG8gcHJveHkgYW4gYXR0cmlidXRlIHVubGVzcyBpdCBleGlzdHNcbiAgICAgIG9uIHRoZSBvYmplY3QgYmVmb3JlIHRoZSBQcm94eSBpcyBjcmVhdGVkLiBUaGlzIGNoYW5nZSBlbnN1cmVzXG4gICAgICBSZXNwb25zZS5ib2R5VXNlZCBleGlzdHMgb24gdGhlIGluc3RhbmNlLCB3aGlsZSBtYWludGFpbmluZyB0aGVcbiAgICAgIHNlbWFudGljIG9mIHNldHRpbmcgUmVxdWVzdC5ib2R5VXNlZCBpbiB0aGUgY29uc3RydWN0b3IgYmVmb3JlXG4gICAgICBfaW5pdEJvZHkgaXMgY2FsbGVkLlxuICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgdGhpcy5ib2R5VXNlZCA9IHRoaXMuYm9keVVzZWRcbiAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIHRoaXMuX25vQm9keSA9IHRydWU7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JylcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGlzQ29uc3VtZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKGlzQ29uc3VtZWQpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29uc3VtZWRcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnVmZmVyLnNsaWNlKFxuICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCArIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIGFzIEFycmF5QnVmZmVyJylcbiAgICB9XG4gIH1cblxuICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICB9XG4gIH1cblxuICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG52YXIgbWV0aG9kcyA9IFsnQ09OTkVDVCcsICdERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQQVRDSCcsICdQT1NUJywgJ1BVVCcsICdUUkFDRSddXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICByZXR1cm4gbWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEgPyB1cGNhc2VkIDogbWV0aG9kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICB9XG4gICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWxcbiAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dClcbiAgfVxuXG4gIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJ1xuICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIH1cbiAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdBYm9ydENvbnRyb2xsZXInIGluIGcpIHtcbiAgICAgIHZhciBjdHJsID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgcmV0dXJuIGN0cmwuc2lnbmFsO1xuICAgIH1cbiAgfSgpKTtcbiAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICB9XG4gIHRoaXMuX2luaXRCb2R5KGJvZHkpXG5cbiAgaWYgKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgaWYgKG9wdGlvbnMuY2FjaGUgPT09ICduby1zdG9yZScgfHwgb3B0aW9ucy5jYWNoZSA9PT0gJ25vLWNhY2hlJykge1xuICAgICAgLy8gU2VhcmNoIGZvciBhICdfJyBwYXJhbWV0ZXIgaW4gdGhlIHF1ZXJ5IHN0cmluZ1xuICAgICAgdmFyIHJlUGFyYW1TZWFyY2ggPSAvKFs/Jl0pXz1bXiZdKi9cbiAgICAgIGlmIChyZVBhcmFtU2VhcmNoLnRlc3QodGhpcy51cmwpKSB7XG4gICAgICAgIC8vIElmIGl0IGFscmVhZHkgZXhpc3RzIHRoZW4gc2V0IHRoZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5yZXBsYWNlKHJlUGFyYW1TZWFyY2gsICckMV89JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBhIG5ldyAnXycgcGFyYW1ldGVyIHRvIHRoZSBlbmQgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHZhciByZVF1ZXJ5U3RyaW5nID0gL1xcPy9cbiAgICAgICAgdGhpcy51cmwgKz0gKHJlUXVlcnlTdHJpbmcudGVzdCh0aGlzLnVybCkgPyAnJicgOiAnPycpICsgJ189JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxufVxuXG5mdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gIGJvZHlcbiAgICAudHJpbSgpXG4gICAgLnNwbGl0KCcmJylcbiAgICAuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9JylcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGZvcm1cbn1cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xccj9cXG5bXFx0IF0rL2csICcgJylcbiAgLy8gQXZvaWRpbmcgc3BsaXQgdmlhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgY29tbW9uIElFMTEgYnVnIHdpdGggdGhlIGNvcmUtanMgMy42LjAgcmVnZXggcG9seWZpbGxcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaC9pc3N1ZXMvNzQ4XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy83NTFcbiAgcHJlUHJvY2Vzc2VkSGVhZGVyc1xuICAgIC5zcGxpdCgnXFxyJylcbiAgICAubWFwKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgcmV0dXJuIGhlYWRlci5pbmRleE9mKCdcXG4nKSA9PT0gMCA/IGhlYWRlci5zdWJzdHIoMSwgaGVhZGVyLmxlbmd0aCkgOiBoZWFkZXJcbiAgICB9KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignUmVzcG9uc2UgJyArIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICByZXR1cm4gaGVhZGVyc1xufVxuXG5Cb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbmV4cG9ydCBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzXG4gIGlmICh0aGlzLnN0YXR1cyA8IDIwMCB8fCB0aGlzLnN0YXR1cyA+IDU5OSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzcG9uc2UnOiBUaGUgc3RhdHVzIHByb3ZpZGVkICgwKSBpcyBvdXRzaWRlIHRoZSByYW5nZSBbMjAwLCA1OTldLlwiKVxuICB9XG4gIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgdGhpcy5zdGF0dXNUZXh0ID0gb3B0aW9ucy5zdGF0dXNUZXh0ID09PSB1bmRlZmluZWQgPyAnJyA6ICcnICsgb3B0aW9ucy5zdGF0dXNUZXh0XG4gIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbn1cblxuQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgIHVybDogdGhpcy51cmxcbiAgfSlcbn1cblxuUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDIwMCwgc3RhdHVzVGV4dDogJyd9KVxuICByZXNwb25zZS5vayA9IGZhbHNlXG4gIHJlc3BvbnNlLnN0YXR1cyA9IDBcbiAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbnZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG5SZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbn1cblxuZXhwb3J0IHZhciBET01FeGNlcHRpb24gPSBnLkRPTUV4Y2VwdGlvblxudHJ5IHtcbiAgbmV3IERPTUV4Y2VwdGlvbigpXG59IGNhdGNoIChlcnIpIHtcbiAgRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSwgbmFtZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSlcbiAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2tcbiAgfVxuICBET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBET01FeGNlcHRpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgfVxuXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICBmdW5jdGlvbiBhYm9ydFhocigpIHtcbiAgICAgIHhoci5hYm9ydCgpXG4gICAgfVxuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgfVxuICAgICAgLy8gVGhpcyBjaGVjayBpZiBzcGVjaWZpY2FsbHkgZm9yIHdoZW4gYSB1c2VyIGZldGNoZXMgYSBmaWxlIGxvY2FsbHkgZnJvbSB0aGUgZmlsZSBzeXN0ZW1cbiAgICAgIC8vIE9ubHkgaWYgdGhlIHN0YXR1cyBpcyBvdXQgb2YgYSBub3JtYWwgcmFuZ2VcbiAgICAgIGlmIChyZXF1ZXN0LnVybC5pbmRleE9mKCdmaWxlOi8vJykgPT09IDAgJiYgKHhoci5zdGF0dXMgPCAyMDAgfHwgeGhyLnN0YXR1cyA+IDU5OSkpIHtcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMgPSAyMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpXG4gICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IHRpbWVkIG91dCcpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhVcmwodXJsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXJsID09PSAnJyAmJiBnLmxvY2F0aW9uLmhyZWYgPyBnLmxvY2F0aW9uLmhyZWYgOiB1cmxcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCBmaXhVcmwocmVxdWVzdC51cmwpLCB0cnVlKVxuXG4gICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhocikge1xuICAgICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBzdXBwb3J0LmFycmF5QnVmZmVyXG4gICAgICApIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5pdCAmJiB0eXBlb2YgaW5pdC5oZWFkZXJzID09PSAnb2JqZWN0JyAmJiAhKGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgfHwgKGcuSGVhZGVycyAmJiBpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBnLkhlYWRlcnMpKSkge1xuICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbml0LmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBuYW1lcy5wdXNoKG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIG5vcm1hbGl6ZVZhbHVlKGluaXQuaGVhZGVyc1tuYW1lXSkpXG4gICAgICB9KVxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG5cbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgfSlcbn1cblxuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG5cbmlmICghZy5mZXRjaCkge1xuICBnLmZldGNoID0gZmV0Y2hcbiAgZy5IZWFkZXJzID0gSGVhZGVyc1xuICBnLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIGcuUmVzcG9uc2UgPSBSZXNwb25zZVxufVxuIiwgImltcG9ydCAnd2hhdHdnLWZldGNoJztcblxuY29uc3QgdmVyc2lvbiA9IFwiMC41LjEyXCI7XG5cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMShvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlcnJvciwgc3RhdHVzX2NvZGUpIHtcbiAgICBzdXBlcihlcnJvcik7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMuc3RhdHVzX2NvZGUgPSBzdGF0dXNfY29kZTtcbiAgICB0aGlzLm5hbWUgPSBcIlJlc3BvbnNlRXJyb3JcIjtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlc3BvbnNlRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKGFib3J0Q29udHJvbGxlciwgaXRyLCBkb25lQ2FsbGJhY2spIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJhYm9ydENvbnRyb2xsZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaXRyXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImRvbmVDYWxsYmFja1wiKTtcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICB0aGlzLml0ciA9IGl0cjtcbiAgICB0aGlzLmRvbmVDYWxsYmFjayA9IGRvbmVDYWxsYmFjaztcbiAgfVxuICBhYm9ydCgpIHtcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgbWVzc2FnZSBvZiB0aGlzLml0cikge1xuICAgICAgaWYgKFwiZXJyb3JcIiBpbiBtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIG1lc3NhZ2U7XG4gICAgICBpZiAobWVzc2FnZS5kb25lIHx8IG1lc3NhZ2Uuc3RhdHVzID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgICB0aGlzLmRvbmVDYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRpZCBub3QgcmVjZWl2ZSBkb25lIG9yIHN1Y2Nlc3MgcmVzcG9uc2UgaW4gc3RyZWFtLlwiKTtcbiAgfVxufVxuY29uc3QgY2hlY2tPayA9IGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBgRXJyb3IgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcbiAgbGV0IGVycm9yRGF0YSA9IG51bGw7XG4gIGlmIChyZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKT8uaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIG1lc3NhZ2UgPSBlcnJvckRhdGEuZXJyb3IgfHwgbWVzc2FnZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gcGFyc2UgZXJyb3IgcmVzcG9uc2UgYXMgSlNPTlwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiR2V0dGluZyB0ZXh0IGZyb20gcmVzcG9uc2VcIik7XG4gICAgICBjb25zdCB0ZXh0UmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBtZXNzYWdlID0gdGV4dFJlc3BvbnNlIHx8IG1lc3NhZ2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIGdldCB0ZXh0IGZyb20gZXJyb3IgcmVzcG9uc2VcIik7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBSZXNwb25zZUVycm9yKG1lc3NhZ2UsIHJlc3BvbnNlLnN0YXR1cyk7XG59O1xuZnVuY3Rpb24gZ2V0UGxhdGZvcm0oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gYCR7d2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpfSBCcm93c2VyLyR7bmF2aWdhdG9yLnVzZXJBZ2VudH07YDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBgJHtwcm9jZXNzLmFyY2h9ICR7cHJvY2Vzcy5wbGF0Zm9ybX0gTm9kZS5qcy8ke3Byb2Nlc3MudmVyc2lvbn1gO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuY29uc3QgZmV0Y2hXaXRoSGVhZGVycyA9IGFzeW5jIChmZXRjaCwgdXJsLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBcIlVzZXItQWdlbnRcIjogYG9sbGFtYS1qcy8ke3ZlcnNpb259ICgke2dldFBsYXRmb3JtKCl9KWBcbiAgfTtcbiAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSB7fTtcbiAgfVxuICBjb25zdCBjdXN0b21IZWFkZXJzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuaGVhZGVycykuZmlsdGVyKChba2V5XSkgPT4gIU9iamVjdC5rZXlzKGRlZmF1bHRIZWFkZXJzKS5zb21lKChkZWZhdWx0S2V5KSA9PiBkZWZhdWx0S2V5LnRvTG93ZXJDYXNlKCkgPT09IGtleS50b0xvd2VyQ2FzZSgpKSlcbiAgKTtcbiAgb3B0aW9ucy5oZWFkZXJzID0ge1xuICAgIC4uLmRlZmF1bHRIZWFkZXJzLFxuICAgIC4uLmN1c3RvbUhlYWRlcnNcbiAgfTtcbiAgcmV0dXJuIGZldGNoKHVybCwgb3B0aW9ucyk7XG59O1xuY29uc3QgZ2V0ID0gYXN5bmMgKGZldGNoLCBob3N0LCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoSGVhZGVycyhmZXRjaCwgaG9zdCwge1xuICAgIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnNcbiAgfSk7XG4gIGF3YWl0IGNoZWNrT2socmVzcG9uc2UpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuY29uc3QgcG9zdCA9IGFzeW5jIChmZXRjaCwgaG9zdCwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBpc1JlY29yZCA9IChpbnB1dCkgPT4ge1xuICAgIHJldHVybiBpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXQpO1xuICB9O1xuICBjb25zdCBmb3JtYXR0ZWREYXRhID0gaXNSZWNvcmQoZGF0YSkgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IGRhdGE7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoSGVhZGVycyhmZXRjaCwgaG9zdCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogZm9ybWF0dGVkRGF0YSxcbiAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCxcbiAgICBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzXG4gIH0pO1xuICBhd2FpdCBjaGVja09rKHJlc3BvbnNlKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbmNvbnN0IGRlbCA9IGFzeW5jIChmZXRjaCwgaG9zdCwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aEhlYWRlcnMoZmV0Y2gsIGhvc3QsIHtcbiAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgaGVhZGVyczogb3B0aW9ucz8uaGVhZGVyc1xuICB9KTtcbiAgYXdhaXQgY2hlY2tPayhyZXNwb25zZSk7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG5jb25zdCBwYXJzZUpTT04gPSBhc3luYyBmdW5jdGlvbiogKGl0cikge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4gIGxldCBidWZmZXIgPSBcIlwiO1xuICBjb25zdCByZWFkZXIgPSBpdHIuZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZTogY2h1bmsgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgIGNvbnN0IHBhcnRzID0gYnVmZmVyLnNwbGl0KFwiXFxuXCIpO1xuICAgIGJ1ZmZlciA9IHBhcnRzLnBvcCgpID8/IFwiXCI7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCBKU09OLnBhcnNlKHBhcnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiaW52YWxpZCBqc29uOiBcIiwgcGFydCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcGFydCBvZiBidWZmZXIuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChwKSA9PiBwICE9PSBcIlwiKSkge1xuICAgIHRyeSB7XG4gICAgICB5aWVsZCBKU09OLnBhcnNlKHBhcnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJpbnZhbGlkIGpzb246IFwiLCBwYXJ0KTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBmb3JtYXRIb3N0ID0gKGhvc3QpID0+IHtcbiAgaWYgKCFob3N0KSB7XG4gICAgcmV0dXJuIFwiaHR0cDovLzEyNy4wLjAuMToxMTQzNFwiO1xuICB9XG4gIGxldCBpc0V4cGxpY2l0UHJvdG9jb2wgPSBob3N0LmluY2x1ZGVzKFwiOi8vXCIpO1xuICBpZiAoaG9zdC5zdGFydHNXaXRoKFwiOlwiKSkge1xuICAgIGhvc3QgPSBgaHR0cDovLzEyNy4wLjAuMSR7aG9zdH1gO1xuICAgIGlzRXhwbGljaXRQcm90b2NvbCA9IHRydWU7XG4gIH1cbiAgaWYgKCFpc0V4cGxpY2l0UHJvdG9jb2wpIHtcbiAgICBob3N0ID0gYGh0dHA6Ly8ke2hvc3R9YDtcbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGhvc3QpO1xuICBsZXQgcG9ydCA9IHVybC5wb3J0O1xuICBpZiAoIXBvcnQpIHtcbiAgICBpZiAoIWlzRXhwbGljaXRQcm90b2NvbCkge1xuICAgICAgcG9ydCA9IFwiMTE0MzRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9ydCA9IHVybC5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiNDQzXCIgOiBcIjgwXCI7XG4gICAgfVxuICB9XG4gIGxldCBmb3JtYXR0ZWRIb3N0ID0gYCR7dXJsLnByb3RvY29sfS8vJHt1cmwuaG9zdG5hbWV9OiR7cG9ydH0ke3VybC5wYXRobmFtZX1gO1xuICBpZiAoZm9ybWF0dGVkSG9zdC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICBmb3JtYXR0ZWRIb3N0ID0gZm9ybWF0dGVkSG9zdC5zbGljZSgwLCAtMSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdHRlZEhvc3Q7XG59O1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5sZXQgT2xsYW1hJDEgPSBjbGFzcyBPbGxhbWEge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29uZmlnXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmZXRjaFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib25nb2luZ1N0cmVhbWVkUmVxdWVzdHNcIiwgW10pO1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgaG9zdDogXCJcIixcbiAgICAgIGhlYWRlcnM6IGNvbmZpZz8uaGVhZGVyc1xuICAgIH07XG4gICAgaWYgKCFjb25maWc/LnByb3h5KSB7XG4gICAgICB0aGlzLmNvbmZpZy5ob3N0ID0gZm9ybWF0SG9zdChjb25maWc/Lmhvc3QgPz8gXCJodHRwOi8vMTI3LjAuMC4xOjExNDM0XCIpO1xuICAgIH1cbiAgICB0aGlzLmZldGNoID0gY29uZmlnPy5mZXRjaCA/PyBmZXRjaDtcbiAgfVxuICAvLyBBYm9ydCBhbnkgb25nb2luZyBzdHJlYW1lZCByZXF1ZXN0cyB0byBPbGxhbWFcbiAgYWJvcnQoKSB7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICB9XG4gICAgdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cy5sZW5ndGggPSAwO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYSByZXF1ZXN0IHRvIHRoZSBPbGxhbWEgc2VydmVyLiBJZiB0aGUgcmVxdWVzdCBpcyBzdHJlYW1hYmxlLCBpdCB3aWxsIHJldHVybiBhXG4gICAqIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgdGhlIHJlc3BvbnNlIG1lc3NhZ2VzLiBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSByZXNwb25zZVxuICAgKiBvYmplY3QuXG4gICAqIEBwYXJhbSBlbmRwb2ludCB7c3RyaW5nfSAtIFRoZSBlbmRwb2ludCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7b2JqZWN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdCB0byBzZW5kIHRvIHRoZSBlbmRwb2ludC5cbiAgICogQHByb3RlY3RlZCB7VCB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8VD59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvciBhIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHNcbiAgICogcmVzcG9uc2UgbWVzc2FnZXMuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIHRoZSByZXNwb25zZSBib2R5IGlzIG1pc3Npbmcgb3IgaWYgdGhlIHJlc3BvbnNlIGlzIGFuIGVycm9yLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxUPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvciBhIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgdGhlIHN0cmVhbWVkIHJlc3BvbnNlLlxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KGVuZHBvaW50LCByZXF1ZXN0KSB7XG4gICAgcmVxdWVzdC5zdHJlYW0gPSByZXF1ZXN0LnN0cmVhbSA/PyBmYWxzZTtcbiAgICBjb25zdCBob3N0ID0gYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpLyR7ZW5kcG9pbnR9YDtcbiAgICBpZiAocmVxdWVzdC5zdHJlYW0pIHtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgaG9zdCwgcmVxdWVzdCwge1xuICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZTIuYm9keSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGJvZHlcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBpdHIgPSBwYXJzZUpTT04ocmVzcG9uc2UyLmJvZHkpO1xuICAgICAgY29uc3QgYWJvcnRhYmxlQXN5bmNJdGVyYXRvciA9IG5ldyBBYm9ydGFibGVBc3luY0l0ZXJhdG9yKFxuICAgICAgICBhYm9ydENvbnRyb2xsZXIsXG4gICAgICAgIGl0cixcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzLmluZGV4T2YoYWJvcnRhYmxlQXN5bmNJdGVyYXRvcik7XG4gICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cy5wdXNoKGFib3J0YWJsZUFzeW5jSXRlcmF0b3IpO1xuICAgICAgcmV0dXJuIGFib3J0YWJsZUFzeW5jSXRlcmF0b3I7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBob3N0LCByZXF1ZXN0LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRW5jb2RlcyBhbiBpbWFnZSB0byBiYXNlNjQgaWYgaXQgaXMgYSBVaW50OEFycmF5LlxuICAgKiBAcGFyYW0gaW1hZ2Uge1VpbnQ4QXJyYXkgfCBzdHJpbmd9IC0gVGhlIGltYWdlIHRvIGVuY29kZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBUaGUgYmFzZTY0IGVuY29kZWQgaW1hZ2UuXG4gICAqL1xuICBhc3luYyBlbmNvZGVJbWFnZShpbWFnZSkge1xuICAgIGlmICh0eXBlb2YgaW1hZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShpbWFnZSk7XG4gICAgICBsZXQgYnl0ZVN0cmluZyA9IFwiXCI7XG4gICAgICBjb25zdCBsZW4gPSB1aW50OEFycmF5LmJ5dGVMZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGJ5dGVTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OEFycmF5W2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidG9hKGJ5dGVTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHJlc3BvbnNlIGZyb20gYSB0ZXh0IHByb21wdC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0dlbmVyYXRlUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEdlbmVyYXRlUmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPEdlbmVyYXRlUmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yXG4gICAqIGFuIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgcmVzcG9uc2UgbWVzc2FnZXMuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZShyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QuaW1hZ2VzKSB7XG4gICAgICByZXF1ZXN0LmltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3QuaW1hZ2VzLm1hcCh0aGlzLmVuY29kZUltYWdlLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwiZ2VuZXJhdGVcIiwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIENoYXRzIHdpdGggdGhlIG1vZGVsLiBUaGUgcmVxdWVzdCBvYmplY3QgY2FuIGNvbnRhaW4gbWVzc2FnZXMgd2l0aCBpbWFnZXMgdGhhdCBhcmUgZWl0aGVyXG4gICAqIFVpbnQ4QXJyYXlzIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3MuIFRoZSBpbWFnZXMgd2lsbCBiZSBiYXNlNjQgZW5jb2RlZCBiZWZvcmUgc2VuZGluZyB0aGVcbiAgICogcmVxdWVzdC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0NoYXRSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2hhdFJlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxDaGF0UmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGFuXG4gICAqIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgcmVzcG9uc2UgbWVzc2FnZXMuXG4gICAqL1xuICBhc3luYyBjaGF0KHJlcXVlc3QpIHtcbiAgICBpZiAocmVxdWVzdC5tZXNzYWdlcykge1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHJlcXVlc3QubWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW1hZ2VzKSB7XG4gICAgICAgICAgbWVzc2FnZS5pbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIG1lc3NhZ2UuaW1hZ2VzLm1hcCh0aGlzLmVuY29kZUltYWdlLmJpbmQodGhpcykpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJjaGF0XCIsIHJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG1vZGVsIGZyb20gYSBzdHJlYW0gb2YgZGF0YS5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0NyZWF0ZVJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm9ncmVzc1Jlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxQcm9ncmVzc1Jlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvciBhIHN0cmVhbSBvZiBwcm9ncmVzcyByZXNwb25zZXMuXG4gICAqL1xuICBhc3luYyBjcmVhdGUocmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcImNyZWF0ZVwiLCB7XG4gICAgICAuLi5yZXF1ZXN0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1bGxzIGEgbW9kZWwgZnJvbSB0aGUgT2xsYW1hIHJlZ2lzdHJ5LiBUaGUgcmVxdWVzdCBvYmplY3QgY2FuIGNvbnRhaW4gYSBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSBpZiB0aGVcbiAgICogcmVzcG9uc2Ugc2hvdWxkIGJlIHN0cmVhbWVkLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7UHVsbFJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm9ncmVzc1Jlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxQcm9ncmVzc1Jlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvclxuICAgKiBhbiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgcHVsbChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwicHVsbFwiLCB7XG4gICAgICBuYW1lOiByZXF1ZXN0Lm1vZGVsLFxuICAgICAgc3RyZWFtOiByZXF1ZXN0LnN0cmVhbSxcbiAgICAgIGluc2VjdXJlOiByZXF1ZXN0Lmluc2VjdXJlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1c2hlcyBhIG1vZGVsIHRvIHRoZSBPbGxhbWEgcmVnaXN0cnkuIFRoZSByZXF1ZXN0IG9iamVjdCBjYW4gY29udGFpbiBhIHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIGlmIHRoZVxuICAgKiByZXNwb25zZSBzaG91bGQgYmUgc3RyZWFtZWQuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtQdXNoUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFByb2dyZXNzUmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFByb2dyZXNzUmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yXG4gICAqIGFuIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgcmVzcG9uc2UgbWVzc2FnZXMuXG4gICAqL1xuICBhc3luYyBwdXNoKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJwdXNoXCIsIHtcbiAgICAgIG5hbWU6IHJlcXVlc3QubW9kZWwsXG4gICAgICBzdHJlYW06IHJlcXVlc3Quc3RyZWFtLFxuICAgICAgaW5zZWN1cmU6IHJlcXVlc3QuaW5zZWN1cmVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIG1vZGVsIGZyb20gdGhlIHNlcnZlci4gVGhlIHJlcXVlc3Qgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBuYW1lIG9mIHRoZSBtb2RlbCB0b1xuICAgKiBkZWxldGUuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtEZWxldGVSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8U3RhdHVzUmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBkZWxldGUocmVxdWVzdCkge1xuICAgIGF3YWl0IGRlbChcbiAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvZGVsZXRlYCxcbiAgICAgIHsgbmFtZTogcmVxdWVzdC5tb2RlbCB9LFxuICAgICAgeyBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzIH1cbiAgICApO1xuICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIgfTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGEgbW9kZWwgZnJvbSBvbmUgbmFtZSB0byBhbm90aGVyLiBUaGUgcmVxdWVzdCBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG5hbWUgb2YgdGhlXG4gICAqIG1vZGVsIHRvIGNvcHkgYW5kIHRoZSBuZXcgbmFtZS5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0NvcHlSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8U3RhdHVzUmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBjb3B5KHJlcXVlc3QpIHtcbiAgICBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9jb3B5YCwgeyAuLi5yZXF1ZXN0IH0sIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH07XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIHRoZSBtb2RlbHMgb24gdGhlIHNlcnZlci5cbiAgICogQHJldHVybnMge1Byb21pc2U8TGlzdFJlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgcmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nLlxuICAgKi9cbiAgYXN5bmMgbGlzdCgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvdGFnc2AsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgbWV0YWRhdGEgb2YgYSBtb2RlbC4gVGhlIHJlcXVlc3Qgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBuYW1lIG9mIHRoZSBtb2RlbC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge1Nob3dSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8U2hvd1Jlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgc2hvdyhyZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9zaG93YCwge1xuICAgICAgLi4ucmVxdWVzdFxuICAgIH0sIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBFbWJlZHMgdGV4dCBpbnB1dCBpbnRvIHZlY3RvcnMuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtFbWJlZFJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbWJlZFJlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgZW1iZWQocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvZW1iZWRgLCB7XG4gICAgICAuLi5yZXF1ZXN0XG4gICAgfSwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVtYmVkcyBhIHRleHQgcHJvbXB0IGludG8gYSB2ZWN0b3IuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtFbWJlZGRpbmdzUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEVtYmVkZGluZ3NSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGVtYmVkZGluZ3MocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvZW1iZWRkaW5nc2AsIHtcbiAgICAgIC4uLnJlcXVlc3RcbiAgICB9LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgdGhlIHJ1bm5pbmcgbW9kZWxzIG9uIHRoZSBzZXJ2ZXJcbiAgICogQHJldHVybnMge1Byb21pc2U8TGlzdFJlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgcmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nLlxuICAgKi9cbiAgYXN5bmMgcHMoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL3BzYCwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbn07XG5jb25zdCBicm93c2VyID0gbmV3IE9sbGFtYSQxKCk7XG5cbmV4cG9ydCB7IE9sbGFtYSQxIGFzIE9sbGFtYSwgYnJvd3NlciBhcyBkZWZhdWx0IH07XG4iLCAiLyohXG4gKiBtdXN0YWNoZS5qcyAtIExvZ2ljLWxlc3Mge3ttdXN0YWNoZX19IHRlbXBsYXRlcyB3aXRoIEphdmFTY3JpcHRcbiAqIGh0dHA6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanNcbiAqL1xuXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXlQb2x5ZmlsbCAob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogTW9yZSBjb3JyZWN0IHR5cGVvZiBzdHJpbmcgaGFuZGxpbmcgYXJyYXlcbiAqIHdoaWNoIG5vcm1hbGx5IHJldHVybnMgdHlwZW9mICdvYmplY3QnXG4gKi9cbmZ1bmN0aW9uIHR5cGVTdHIgKG9iaikge1xuICByZXR1cm4gaXNBcnJheShvYmopID8gJ2FycmF5JyA6IHR5cGVvZiBvYmo7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbn1cblxuLyoqXG4gKiBOdWxsIHNhZmUgd2F5IG9mIGNoZWNraW5nIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCxcbiAqIGluY2x1ZGluZyBpdHMgcHJvdG90eXBlLCBoYXMgYSBnaXZlbiBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eSAob2JqLCBwcm9wTmFtZSkge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKHByb3BOYW1lIGluIG9iaik7XG59XG5cbi8qKlxuICogU2FmZSB3YXkgb2YgZGV0ZWN0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB0aGluZyBpcyBhIHByaW1pdGl2ZSBhbmRcbiAqIHdoZXRoZXIgaXQgaGFzIHRoZSBnaXZlbiBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eSAocHJpbWl0aXZlLCBwcm9wTmFtZSkge1xuICByZXR1cm4gKFxuICAgIHByaW1pdGl2ZSAhPSBudWxsXG4gICAgJiYgdHlwZW9mIHByaW1pdGl2ZSAhPT0gJ29iamVjdCdcbiAgICAmJiBwcmltaXRpdmUuaGFzT3duUHJvcGVydHlcbiAgICAmJiBwcmltaXRpdmUuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpXG4gICk7XG59XG5cbi8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vaXNzdWVzLmFwYWNoZS5vcmcvamlyYS9icm93c2UvQ09VQ0hEQi01Nzdcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg5XG52YXIgcmVnRXhwVGVzdCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdDtcbmZ1bmN0aW9uIHRlc3RSZWdFeHAgKHJlLCBzdHJpbmcpIHtcbiAgcmV0dXJuIHJlZ0V4cFRlc3QuY2FsbChyZSwgc3RyaW5nKTtcbn1cblxudmFyIG5vblNwYWNlUmUgPSAvXFxTLztcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAoc3RyaW5nKSB7XG4gIHJldHVybiAhdGVzdFJlZ0V4cChub25TcGFjZVJlLCBzdHJpbmcpO1xufVxuXG52YXIgZW50aXR5TWFwID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnLFxuICAnLyc6ICcmI3gyRjsnLFxuICAnYCc6ICcmI3g2MDsnLFxuICAnPSc6ICcmI3gzRDsnXG59O1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoL1smPD5cIidgPVxcL10vZywgZnVuY3Rpb24gZnJvbUVudGl0eU1hcCAocykge1xuICAgIHJldHVybiBlbnRpdHlNYXBbc107XG4gIH0pO1xufVxuXG52YXIgd2hpdGVSZSA9IC9cXHMqLztcbnZhciBzcGFjZVJlID0gL1xccysvO1xudmFyIGVxdWFsc1JlID0gL1xccyo9LztcbnZhciBjdXJseVJlID0gL1xccypcXH0vO1xudmFyIHRhZ1JlID0gLyN8XFxefFxcL3w+fFxce3wmfD18IS87XG5cbi8qKlxuICogQnJlYWtzIHVwIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHN0cmluZyBpbnRvIGEgdHJlZSBvZiB0b2tlbnMuIElmIHRoZSBgdGFnc2BcbiAqIGFyZ3VtZW50IGlzIGdpdmVuIGhlcmUgaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3byBzdHJpbmcgdmFsdWVzOiB0aGVcbiAqIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSAoZS5nLiBbIFwiPCVcIiwgXCIlPlwiIF0pLiBPZlxuICogY291cnNlLCB0aGUgZGVmYXVsdCBpcyB0byB1c2UgbXVzdGFjaGVzIChpLmUuIG11c3RhY2hlLnRhZ3MpLlxuICpcbiAqIEEgdG9rZW4gaXMgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCA0IGVsZW1lbnRzLiBUaGUgZmlyc3QgZWxlbWVudCBpcyB0aGVcbiAqIG11c3RhY2hlIHN5bWJvbCB0aGF0IHdhcyB1c2VkIGluc2lkZSB0aGUgdGFnLCBlLmcuIFwiI1wiIG9yIFwiJlwiLiBJZiB0aGUgdGFnXG4gKiBkaWQgbm90IGNvbnRhaW4gYSBzeW1ib2wgKGkuZS4ge3tteVZhbHVlfX0pIHRoaXMgZWxlbWVudCBpcyBcIm5hbWVcIi4gRm9yXG4gKiBhbGwgdGV4dCB0aGF0IGFwcGVhcnMgb3V0c2lkZSBhIHN5bWJvbCB0aGlzIGVsZW1lbnQgaXMgXCJ0ZXh0XCIuXG4gKlxuICogVGhlIHNlY29uZCBlbGVtZW50IG9mIGEgdG9rZW4gaXMgaXRzIFwidmFsdWVcIi4gRm9yIG11c3RhY2hlIHRhZ3MgdGhpcyBpc1xuICogd2hhdGV2ZXIgZWxzZSB3YXMgaW5zaWRlIHRoZSB0YWcgYmVzaWRlcyB0aGUgb3BlbmluZyBzeW1ib2wuIEZvciB0ZXh0IHRva2Vuc1xuICogdGhpcyBpcyB0aGUgdGV4dCBpdHNlbGYuXG4gKlxuICogVGhlIHRoaXJkIGFuZCBmb3VydGggZWxlbWVudHMgb2YgdGhlIHRva2VuIGFyZSB0aGUgc3RhcnQgYW5kIGVuZCBpbmRpY2VzLFxuICogcmVzcGVjdGl2ZWx5LCBvZiB0aGUgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlLlxuICpcbiAqIFRva2VucyB0aGF0IGFyZSB0aGUgcm9vdCBub2RlIG9mIGEgc3VidHJlZSBjb250YWluIHR3byBtb3JlIGVsZW1lbnRzOiAxKSBhblxuICogYXJyYXkgb2YgdG9rZW5zIGluIHRoZSBzdWJ0cmVlIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlIGF0XG4gKiB3aGljaCB0aGUgY2xvc2luZyB0YWcgZm9yIHRoYXQgc2VjdGlvbiBiZWdpbnMuXG4gKlxuICogVG9rZW5zIGZvciBwYXJ0aWFscyBhbHNvIGNvbnRhaW4gdHdvIG1vcmUgZWxlbWVudHM6IDEpIGEgc3RyaW5nIHZhbHVlIG9mXG4gKiBpbmRlbmRhdGlvbiBwcmlvciB0byB0aGF0IHRhZyBhbmQgMikgdGhlIGluZGV4IG9mIHRoYXQgdGFnIG9uIHRoYXQgbGluZSAtXG4gKiBlZyBhIHZhbHVlIG9mIDIgaW5kaWNhdGVzIHRoZSBwYXJ0aWFsIGlzIHRoZSB0aGlyZCB0YWcgb24gdGhpcyBsaW5lLlxuICovXG5mdW5jdGlvbiBwYXJzZVRlbXBsYXRlICh0ZW1wbGF0ZSwgdGFncykge1xuICBpZiAoIXRlbXBsYXRlKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIGxpbmVIYXNOb25TcGFjZSA9IGZhbHNlO1xuICB2YXIgc2VjdGlvbnMgPSBbXTsgICAgIC8vIFN0YWNrIHRvIGhvbGQgc2VjdGlvbiB0b2tlbnNcbiAgdmFyIHRva2VucyA9IFtdOyAgICAgICAvLyBCdWZmZXIgdG8gaG9sZCB0aGUgdG9rZW5zXG4gIHZhciBzcGFjZXMgPSBbXTsgICAgICAgLy8gSW5kaWNlcyBvZiB3aGl0ZXNwYWNlIHRva2VucyBvbiB0aGUgY3VycmVudCBsaW5lXG4gIHZhciBoYXNUYWcgPSBmYWxzZTsgICAgLy8gSXMgdGhlcmUgYSB7e3RhZ319IG9uIHRoZSBjdXJyZW50IGxpbmU/XG4gIHZhciBub25TcGFjZSA9IGZhbHNlOyAgLy8gSXMgdGhlcmUgYSBub24tc3BhY2UgY2hhciBvbiB0aGUgY3VycmVudCBsaW5lP1xuICB2YXIgaW5kZW50YXRpb24gPSAnJzsgIC8vIFRyYWNrcyBpbmRlbnRhdGlvbiBmb3IgdGFncyB0aGF0IHVzZSBpdFxuICB2YXIgdGFnSW5kZXggPSAwOyAgICAgIC8vIFN0b3JlcyBhIGNvdW50IG9mIG51bWJlciBvZiB0YWdzIGVuY291bnRlcmVkIG9uIGEgbGluZVxuXG4gIC8vIFN0cmlwcyBhbGwgd2hpdGVzcGFjZSB0b2tlbnMgYXJyYXkgZm9yIHRoZSBjdXJyZW50IGxpbmVcbiAgLy8gaWYgdGhlcmUgd2FzIGEge3sjdGFnfX0gb24gaXQgYW5kIG90aGVyd2lzZSBvbmx5IHNwYWNlLlxuICBmdW5jdGlvbiBzdHJpcFNwYWNlICgpIHtcbiAgICBpZiAoaGFzVGFnICYmICFub25TcGFjZSkge1xuICAgICAgd2hpbGUgKHNwYWNlcy5sZW5ndGgpXG4gICAgICAgIGRlbGV0ZSB0b2tlbnNbc3BhY2VzLnBvcCgpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3BhY2VzID0gW107XG4gICAgfVxuXG4gICAgaGFzVGFnID0gZmFsc2U7XG4gICAgbm9uU3BhY2UgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBvcGVuaW5nVGFnUmUsIGNsb3NpbmdUYWdSZSwgY2xvc2luZ0N1cmx5UmU7XG4gIGZ1bmN0aW9uIGNvbXBpbGVUYWdzICh0YWdzVG9Db21waWxlKSB7XG4gICAgaWYgKHR5cGVvZiB0YWdzVG9Db21waWxlID09PSAnc3RyaW5nJylcbiAgICAgIHRhZ3NUb0NvbXBpbGUgPSB0YWdzVG9Db21waWxlLnNwbGl0KHNwYWNlUmUsIDIpO1xuXG4gICAgaWYgKCFpc0FycmF5KHRhZ3NUb0NvbXBpbGUpIHx8IHRhZ3NUb0NvbXBpbGUubGVuZ3RoICE9PSAyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZ3M6ICcgKyB0YWdzVG9Db21waWxlKTtcblxuICAgIG9wZW5pbmdUYWdSZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMF0pICsgJ1xcXFxzKicpO1xuICAgIGNsb3NpbmdUYWdSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAodGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgIGNsb3NpbmdDdXJseVJlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCgnfScgKyB0YWdzVG9Db21waWxlWzFdKSk7XG4gIH1cblxuICBjb21waWxlVGFncyh0YWdzIHx8IG11c3RhY2hlLnRhZ3MpO1xuXG4gIHZhciBzY2FubmVyID0gbmV3IFNjYW5uZXIodGVtcGxhdGUpO1xuXG4gIHZhciBzdGFydCwgdHlwZSwgdmFsdWUsIGNociwgdG9rZW4sIG9wZW5TZWN0aW9uO1xuICB3aGlsZSAoIXNjYW5uZXIuZW9zKCkpIHtcbiAgICBzdGFydCA9IHNjYW5uZXIucG9zO1xuXG4gICAgLy8gTWF0Y2ggYW55IHRleHQgYmV0d2VlbiB0YWdzLlxuICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwob3BlbmluZ1RhZ1JlKTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpIDwgdmFsdWVMZW5ndGg7ICsraSkge1xuICAgICAgICBjaHIgPSB2YWx1ZS5jaGFyQXQoaSk7XG5cbiAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjaHIpKSB7XG4gICAgICAgICAgc3BhY2VzLnB1c2godG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gY2hyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICBsaW5lSGFzTm9uU3BhY2UgPSB0cnVlO1xuICAgICAgICAgIGluZGVudGF0aW9uICs9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2Vucy5wdXNoKFsgJ3RleHQnLCBjaHIsIHN0YXJ0LCBzdGFydCArIDEgXSk7XG4gICAgICAgIHN0YXJ0ICs9IDE7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHdoaXRlc3BhY2Ugb24gdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgaWYgKGNociA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBzdHJpcFNwYWNlKCk7XG4gICAgICAgICAgaW5kZW50YXRpb24gPSAnJztcbiAgICAgICAgICB0YWdJbmRleCA9IDA7XG4gICAgICAgICAgbGluZUhhc05vblNwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYXRjaCB0aGUgb3BlbmluZyB0YWcuXG4gICAgaWYgKCFzY2FubmVyLnNjYW4ob3BlbmluZ1RhZ1JlKSlcbiAgICAgIGJyZWFrO1xuXG4gICAgaGFzVGFnID0gdHJ1ZTtcblxuICAgIC8vIEdldCB0aGUgdGFnIHR5cGUuXG4gICAgdHlwZSA9IHNjYW5uZXIuc2Nhbih0YWdSZSkgfHwgJ25hbWUnO1xuICAgIHNjYW5uZXIuc2Nhbih3aGl0ZVJlKTtcblxuICAgIC8vIEdldCB0aGUgdGFnIHZhbHVlLlxuICAgIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoZXF1YWxzUmUpO1xuICAgICAgc2Nhbm5lci5zY2FuKGVxdWFsc1JlKTtcbiAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAneycpIHtcbiAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ0N1cmx5UmUpO1xuICAgICAgc2Nhbm5lci5zY2FuKGN1cmx5UmUpO1xuICAgICAgc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgIHR5cGUgPSAnJic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICB9XG5cbiAgICAvLyBNYXRjaCB0aGUgY2xvc2luZyB0YWcuXG4gICAgaWYgKCFzY2FubmVyLnNjYW4oY2xvc2luZ1RhZ1JlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgdGFnIGF0ICcgKyBzY2FubmVyLnBvcyk7XG5cbiAgICBpZiAodHlwZSA9PSAnPicpIHtcbiAgICAgIHRva2VuID0gWyB0eXBlLCB2YWx1ZSwgc3RhcnQsIHNjYW5uZXIucG9zLCBpbmRlbnRhdGlvbiwgdGFnSW5kZXgsIGxpbmVIYXNOb25TcGFjZSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2tlbiA9IFsgdHlwZSwgdmFsdWUsIHN0YXJ0LCBzY2FubmVyLnBvcyBdO1xuICAgIH1cbiAgICB0YWdJbmRleCsrO1xuICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblxuICAgIGlmICh0eXBlID09PSAnIycgfHwgdHlwZSA9PT0gJ14nKSB7XG4gICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcvJykge1xuICAgICAgLy8gQ2hlY2sgc2VjdGlvbiBuZXN0aW5nLlxuICAgICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgICAgaWYgKCFvcGVuU2VjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbm9wZW5lZCBzZWN0aW9uIFwiJyArIHZhbHVlICsgJ1wiIGF0ICcgKyBzdGFydCk7XG5cbiAgICAgIGlmIChvcGVuU2VjdGlvblsxXSAhPT0gdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc3RhcnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25hbWUnIHx8IHR5cGUgPT09ICd7JyB8fCB0eXBlID09PSAnJicpIHtcbiAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICc9Jykge1xuICAgICAgLy8gU2V0IHRoZSB0YWdzIGZvciB0aGUgbmV4dCB0aW1lIGFyb3VuZC5cbiAgICAgIGNvbXBpbGVUYWdzKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBzdHJpcFNwYWNlKCk7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBubyBvcGVuIHNlY3Rpb25zIHdoZW4gd2UncmUgZG9uZS5cbiAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICBpZiAob3BlblNlY3Rpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzY2FubmVyLnBvcyk7XG5cbiAgcmV0dXJuIG5lc3RUb2tlbnMoc3F1YXNoVG9rZW5zKHRva2VucykpO1xufVxuXG4vKipcbiAqIENvbWJpbmVzIHRoZSB2YWx1ZXMgb2YgY29uc2VjdXRpdmUgdGV4dCB0b2tlbnMgaW4gdGhlIGdpdmVuIGB0b2tlbnNgIGFycmF5XG4gKiB0byBhIHNpbmdsZSB0b2tlbi5cbiAqL1xuZnVuY3Rpb24gc3F1YXNoVG9rZW5zICh0b2tlbnMpIHtcbiAgdmFyIHNxdWFzaGVkVG9rZW5zID0gW107XG5cbiAgdmFyIHRva2VuLCBsYXN0VG9rZW47XG4gIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbikge1xuICAgICAgaWYgKHRva2VuWzBdID09PSAndGV4dCcgJiYgbGFzdFRva2VuICYmIGxhc3RUb2tlblswXSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGxhc3RUb2tlblsxXSArPSB0b2tlblsxXTtcbiAgICAgICAgbGFzdFRva2VuWzNdID0gdG9rZW5bM107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcXVhc2hlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNxdWFzaGVkVG9rZW5zO1xufVxuXG4vKipcbiAqIEZvcm1zIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCBpbnRvIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlIHdoZXJlXG4gKiB0b2tlbnMgdGhhdCByZXByZXNlbnQgYSBzZWN0aW9uIGhhdmUgdHdvIGFkZGl0aW9uYWwgaXRlbXM6IDEpIGFuIGFycmF5IG9mXG4gKiBhbGwgdG9rZW5zIHRoYXQgYXBwZWFyIGluIHRoYXQgc2VjdGlvbiBhbmQgMikgdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbFxuICogdGVtcGxhdGUgdGhhdCByZXByZXNlbnRzIHRoZSBlbmQgb2YgdGhhdCBzZWN0aW9uLlxuICovXG5mdW5jdGlvbiBuZXN0VG9rZW5zICh0b2tlbnMpIHtcbiAgdmFyIG5lc3RlZFRva2VucyA9IFtdO1xuICB2YXIgY29sbGVjdG9yID0gbmVzdGVkVG9rZW5zO1xuICB2YXIgc2VjdGlvbnMgPSBbXTtcblxuICB2YXIgdG9rZW4sIHNlY3Rpb247XG4gIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgIGNhc2UgJyMnOlxuICAgICAgY2FzZSAnXic6XG4gICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbGxlY3RvciA9IHRva2VuWzRdID0gW107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnLyc6XG4gICAgICAgIHNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcbiAgICAgICAgc2VjdGlvbls1XSA9IHRva2VuWzJdO1xuICAgICAgICBjb2xsZWN0b3IgPSBzZWN0aW9ucy5sZW5ndGggPiAwID8gc2VjdGlvbnNbc2VjdGlvbnMubGVuZ3RoIC0gMV1bNF0gOiBuZXN0ZWRUb2tlbnM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29sbGVjdG9yLnB1c2godG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXN0ZWRUb2tlbnM7XG59XG5cbi8qKlxuICogQSBzaW1wbGUgc3RyaW5nIHNjYW5uZXIgdGhhdCBpcyB1c2VkIGJ5IHRoZSB0ZW1wbGF0ZSBwYXJzZXIgdG8gZmluZFxuICogdG9rZW5zIGluIHRlbXBsYXRlIHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIFNjYW5uZXIgKHN0cmluZykge1xuICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgdGhpcy50YWlsID0gc3RyaW5nO1xuICB0aGlzLnBvcyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRhaWwgaXMgZW1wdHkgKGVuZCBvZiBzdHJpbmcpLlxuICovXG5TY2FubmVyLnByb3RvdHlwZS5lb3MgPSBmdW5jdGlvbiBlb3MgKCkge1xuICByZXR1cm4gdGhpcy50YWlsID09PSAnJztcbn07XG5cbi8qKlxuICogVHJpZXMgdG8gbWF0Y2ggdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAqIFJldHVybnMgdGhlIG1hdGNoZWQgdGV4dCBpZiBpdCBjYW4gbWF0Y2gsIHRoZSBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlLlxuICovXG5TY2FubmVyLnByb3RvdHlwZS5zY2FuID0gZnVuY3Rpb24gc2NhbiAocmUpIHtcbiAgdmFyIG1hdGNoID0gdGhpcy50YWlsLm1hdGNoKHJlKTtcblxuICBpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICE9PSAwKVxuICAgIHJldHVybiAnJztcblxuICB2YXIgc3RyaW5nID0gbWF0Y2hbMF07XG5cbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKTtcbiAgdGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcblxuICByZXR1cm4gc3RyaW5nO1xufTtcblxuLyoqXG4gKiBTa2lwcyBhbGwgdGV4dCB1bnRpbCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGNhbiBiZSBtYXRjaGVkLiBSZXR1cm5zXG4gKiB0aGUgc2tpcHBlZCBzdHJpbmcsIHdoaWNoIGlzIHRoZSBlbnRpcmUgdGFpbCBpZiBubyBtYXRjaCBjYW4gYmUgbWFkZS5cbiAqL1xuU2Nhbm5lci5wcm90b3R5cGUuc2NhblVudGlsID0gZnVuY3Rpb24gc2NhblVudGlsIChyZSkge1xuICB2YXIgaW5kZXggPSB0aGlzLnRhaWwuc2VhcmNoKHJlKSwgbWF0Y2g7XG5cbiAgc3dpdGNoIChpbmRleCkge1xuICAgIGNhc2UgLTE6XG4gICAgICBtYXRjaCA9IHRoaXMudGFpbDtcbiAgICAgIHRoaXMudGFpbCA9ICcnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAwOlxuICAgICAgbWF0Y2ggPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtYXRjaCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhpbmRleCk7XG4gIH1cblxuICB0aGlzLnBvcyArPSBtYXRjaC5sZW5ndGg7XG5cbiAgcmV0dXJuIG1hdGNoO1xufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmVuZGVyaW5nIGNvbnRleHQgYnkgd3JhcHBpbmcgYSB2aWV3IG9iamVjdCBhbmRcbiAqIG1haW50YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gQ29udGV4dCAodmlldywgcGFyZW50Q29udGV4dCkge1xuICB0aGlzLnZpZXcgPSB2aWV3O1xuICB0aGlzLmNhY2hlID0geyAnLic6IHRoaXMudmlldyB9O1xuICB0aGlzLnBhcmVudCA9IHBhcmVudENvbnRleHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBjb250ZXh0IHVzaW5nIHRoZSBnaXZlbiB2aWV3IHdpdGggdGhpcyBjb250ZXh0XG4gKiBhcyB0aGUgcGFyZW50LlxuICovXG5Db250ZXh0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAodmlldykge1xuICByZXR1cm4gbmV3IENvbnRleHQodmlldywgdGhpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoaXMgY29udGV4dCwgdHJhdmVyc2luZ1xuICogdXAgdGhlIGNvbnRleHQgaGllcmFyY2h5IGlmIHRoZSB2YWx1ZSBpcyBhYnNlbnQgaW4gdGhpcyBjb250ZXh0J3Mgdmlldy5cbiAqL1xuQ29udGV4dC5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwIChuYW1lKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cbiAgdmFyIHZhbHVlO1xuICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB2YWx1ZSA9IGNhY2hlW25hbWVdO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcywgaW50ZXJtZWRpYXRlVmFsdWUsIG5hbWVzLCBpbmRleCwgbG9va3VwSGl0ID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoY29udGV4dCkge1xuICAgICAgaWYgKG5hbWUuaW5kZXhPZignLicpID4gMCkge1xuICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZSA9IGNvbnRleHQudmlldztcbiAgICAgICAgbmFtZXMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIGluZGV4ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNpbmcgdGhlIGRvdCBub3Rpb24gcGF0aCBpbiBgbmFtZWAsIHdlIGRlc2NlbmQgdGhyb3VnaCB0aGVcbiAgICAgICAgICogbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIGJlIGNlcnRhaW4gdGhhdCB0aGUgbG9va3VwIGhhcyBiZWVuIHN1Y2Nlc3NmdWwsIHdlIGhhdmUgdG9cbiAgICAgICAgICogY2hlY2sgaWYgdGhlIGxhc3Qgb2JqZWN0IGluIHRoZSBwYXRoIGFjdHVhbGx5IGhhcyB0aGUgcHJvcGVydHlcbiAgICAgICAgICogd2UgYXJlIGxvb2tpbmcgZm9yLiBXZSBzdG9yZSB0aGUgcmVzdWx0IGluIGBsb29rdXBIaXRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHNwZWNpYWxseSBuZWNlc3NhcnkgZm9yIHdoZW4gdGhlIHZhbHVlIGhhcyBiZWVuIHNldCB0b1xuICAgICAgICAgKiBgdW5kZWZpbmVkYCBhbmQgd2Ugd2FudCB0byBhdm9pZCBsb29raW5nIHVwIHBhcmVudCBjb250ZXh0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gdGhlIGNhc2Ugd2hlcmUgZG90IG5vdGF0aW9uIGlzIHVzZWQsIHdlIGNvbnNpZGVyIHRoZSBsb29rdXBcbiAgICAgICAgICogdG8gYmUgc3VjY2Vzc2Z1bCBldmVuIGlmIHRoZSBsYXN0IFwib2JqZWN0XCIgaW4gdGhlIHBhdGggaXNcbiAgICAgICAgICogbm90IGFjdHVhbGx5IGFuIG9iamVjdCBidXQgYSBwcmltaXRpdmUgKGUuZy4sIGEgc3RyaW5nLCBvciBhblxuICAgICAgICAgKiBpbnRlZ2VyKSwgYmVjYXVzZSBpdCBpcyBzb21ldGltZXMgdXNlZnVsIHRvIGFjY2VzcyBhIHByb3BlcnR5XG4gICAgICAgICAqIG9mIGFuIGF1dG9ib3hlZCBwcmltaXRpdmUsIHN1Y2ggYXMgdGhlIGxlbmd0aCBvZiBhIHN0cmluZy5cbiAgICAgICAgICoqL1xuICAgICAgICB3aGlsZSAoaW50ZXJtZWRpYXRlVmFsdWUgIT0gbnVsbCAmJiBpbmRleCA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gbmFtZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIGxvb2t1cEhpdCA9IChcbiAgICAgICAgICAgICAgaGFzUHJvcGVydHkoaW50ZXJtZWRpYXRlVmFsdWUsIG5hbWVzW2luZGV4XSlcbiAgICAgICAgICAgICAgfHwgcHJpbWl0aXZlSGFzT3duUHJvcGVydHkoaW50ZXJtZWRpYXRlVmFsdWUsIG5hbWVzW2luZGV4XSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZSA9IGludGVybWVkaWF0ZVZhbHVlW25hbWVzW2luZGV4KytdXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJtZWRpYXRlVmFsdWUgPSBjb250ZXh0LnZpZXdbbmFtZV07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgY2hlY2tpbmcgYWdhaW5zdCBgaGFzUHJvcGVydHlgLCB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgIGlmXG4gICAgICAgICAqIGBjb250ZXh0LnZpZXdgIGlzIG5vdCBhbiBvYmplY3QuIERlbGliZXJhdGVseSBvbWl0dGluZyB0aGUgY2hlY2tcbiAgICAgICAgICogYWdhaW5zdCBgcHJpbWl0aXZlSGFzT3duUHJvcGVydHlgIGlmIGRvdCBub3RhdGlvbiBpcyBub3QgdXNlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29uc2lkZXIgdGhpcyBleGFtcGxlOlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogTXVzdGFjaGUucmVuZGVyKFwiVGhlIGxlbmd0aCBvZiBhIGZvb3RiYWxsIGZpZWxkIGlzIHt7I2xlbmd0aH19e3tsZW5ndGh9fXt7L2xlbmd0aH19LlwiLCB7bGVuZ3RoOiBcIjEwMCB5YXJkc1wifSlcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHdlIHdlcmUgdG8gY2hlY2sgYWxzbyBhZ2FpbnN0IGBwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eWAsIGFzIHdlIGRvXG4gICAgICAgICAqIGluIHRoZSBkb3Qgbm90YXRpb24gY2FzZSwgdGhlbiByZW5kZXIgY2FsbCB3b3VsZCByZXR1cm46XG4gICAgICAgICAqXG4gICAgICAgICAqIFwiVGhlIGxlbmd0aCBvZiBhIGZvb3RiYWxsIGZpZWxkIGlzIDkuXCJcbiAgICAgICAgICpcbiAgICAgICAgICogcmF0aGVyIHRoYW4gdGhlIGV4cGVjdGVkOlxuICAgICAgICAgKlxuICAgICAgICAgKiBcIlRoZSBsZW5ndGggb2YgYSBmb290YmFsbCBmaWVsZCBpcyAxMDAgeWFyZHMuXCJcbiAgICAgICAgICoqL1xuICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eShjb250ZXh0LnZpZXcsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9va3VwSGl0KSB7XG4gICAgICAgIHZhbHVlID0gaW50ZXJtZWRpYXRlVmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgY2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSlcbiAgICB2YWx1ZSA9IHZhbHVlLmNhbGwodGhpcy52aWV3KTtcblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIEEgV3JpdGVyIGtub3dzIGhvdyB0byB0YWtlIGEgc3RyZWFtIG9mIHRva2VucyBhbmQgcmVuZGVyIHRoZW0gdG8gYVxuICogc3RyaW5nLCBnaXZlbiBhIGNvbnRleHQuIEl0IGFsc28gbWFpbnRhaW5zIGEgY2FjaGUgb2YgdGVtcGxhdGVzIHRvXG4gKiBhdm9pZCB0aGUgbmVlZCB0byBwYXJzZSB0aGUgc2FtZSB0ZW1wbGF0ZSB0d2ljZS5cbiAqL1xuZnVuY3Rpb24gV3JpdGVyICgpIHtcbiAgdGhpcy50ZW1wbGF0ZUNhY2hlID0ge1xuICAgIF9jYWNoZToge30sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQgKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX2NhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0IChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZVtrZXldO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGlzIHdyaXRlci5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSAoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy50ZW1wbGF0ZUNhY2hlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMudGVtcGxhdGVDYWNoZS5jbGVhcigpO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiBgdGVtcGxhdGVgIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gYHRhZ3NgIG9yXG4gKiBgbXVzdGFjaGUudGFnc2AgaWYgYHRhZ3NgIGlzIG9taXR0ZWQsICBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgdG9rZW5zXG4gKiB0aGF0IGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBwYXJzZS5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICh0ZW1wbGF0ZSwgdGFncykge1xuICB2YXIgY2FjaGUgPSB0aGlzLnRlbXBsYXRlQ2FjaGU7XG4gIHZhciBjYWNoZUtleSA9IHRlbXBsYXRlICsgJzonICsgKHRhZ3MgfHwgbXVzdGFjaGUudGFncykuam9pbignOicpO1xuICB2YXIgaXNDYWNoZUVuYWJsZWQgPSB0eXBlb2YgY2FjaGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgdG9rZW5zID0gaXNDYWNoZUVuYWJsZWQgPyBjYWNoZS5nZXQoY2FjaGVLZXkpIDogdW5kZWZpbmVkO1xuXG4gIGlmICh0b2tlbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgdG9rZW5zID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGFncyk7XG4gICAgaXNDYWNoZUVuYWJsZWQgJiYgY2FjaGUuc2V0KGNhY2hlS2V5LCB0b2tlbnMpO1xuICB9XG4gIHJldHVybiB0b2tlbnM7XG59O1xuXG4vKipcbiAqIEhpZ2gtbGV2ZWwgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgd2l0aFxuICogdGhlIGdpdmVuIGB2aWV3YC5cbiAqXG4gKiBUaGUgb3B0aW9uYWwgYHBhcnRpYWxzYCBhcmd1bWVudCBtYXkgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG4gKiBuYW1lcyBhbmQgdGVtcGxhdGVzIG9mIHBhcnRpYWxzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLiBJdCBtYXlcbiAqIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gbG9hZCBwYXJ0aWFsIHRlbXBsYXRlcyBvbiB0aGUgZmx5XG4gKiB0aGF0IHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50OiB0aGUgbmFtZSBvZiB0aGUgcGFydGlhbC5cbiAqXG4gKiBJZiB0aGUgb3B0aW9uYWwgYGNvbmZpZ2AgYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSwgdGhlbiBpdCBzaG91bGQgYmUgYW5cbiAqIG9iamVjdCB3aXRoIGEgYHRhZ3NgIGF0dHJpYnV0ZSBvciBhbiBgZXNjYXBlYCBhdHRyaWJ1dGUgb3IgYm90aC5cbiAqIElmIGFuIGFycmF5IGlzIHBhc3NlZCwgdGhlbiBpdCB3aWxsIGJlIGludGVycHJldGVkIHRoZSBzYW1lIHdheSBhc1xuICogYSBgdGFnc2AgYXR0cmlidXRlIG9uIGEgYGNvbmZpZ2Agb2JqZWN0LlxuICpcbiAqIFRoZSBgdGFnc2AgYXR0cmlidXRlIG9mIGEgYGNvbmZpZ2Agb2JqZWN0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d29cbiAqIHN0cmluZyB2YWx1ZXM6IHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy5cbiAqIFsgXCI8JVwiLCBcIiU+XCIgXSkuIFRoZSBkZWZhdWx0IGlzIHRvIG11c3RhY2hlLnRhZ3MuXG4gKlxuICogVGhlIGBlc2NhcGVgIGF0dHJpYnV0ZSBvZiBhIGBjb25maWdgIG9iamVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gd2hpY2hcbiAqIGFjY2VwdHMgYSBzdHJpbmcgYXMgaW5wdXQgYW5kIG91dHB1dHMgYSBzYWZlbHkgZXNjYXBlZCBzdHJpbmcuXG4gKiBJZiBhbiBgZXNjYXBlYCBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQsIHRoZW4gYW4gSFRNTC1zYWZlIHN0cmluZ1xuICogZXNjYXBpbmcgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgZGVmYXVsdC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgY29uZmlnKSB7XG4gIHZhciB0YWdzID0gdGhpcy5nZXRDb25maWdUYWdzKGNvbmZpZyk7XG4gIHZhciB0b2tlbnMgPSB0aGlzLnBhcnNlKHRlbXBsYXRlLCB0YWdzKTtcbiAgdmFyIGNvbnRleHQgPSAodmlldyBpbnN0YW5jZW9mIENvbnRleHQpID8gdmlldyA6IG5ldyBDb250ZXh0KHZpZXcsIHVuZGVmaW5lZCk7XG4gIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCB0ZW1wbGF0ZSwgY29uZmlnKTtcbn07XG5cbi8qKlxuICogTG93LWxldmVsIG1ldGhvZCB0aGF0IHJlbmRlcnMgdGhlIGdpdmVuIGFycmF5IG9mIGB0b2tlbnNgIHVzaW5nXG4gKiB0aGUgZ2l2ZW4gYGNvbnRleHRgIGFuZCBgcGFydGlhbHNgLlxuICpcbiAqIE5vdGU6IFRoZSBgb3JpZ2luYWxUZW1wbGF0ZWAgaXMgb25seSBldmVyIHVzZWQgdG8gZXh0cmFjdCB0aGUgcG9ydGlvblxuICogb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgd2FzIGNvbnRhaW5lZCBpbiBhIGhpZ2hlci1vcmRlciBzZWN0aW9uLlxuICogSWYgdGhlIHRlbXBsYXRlIGRvZXNuJ3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucywgdGhpcyBhcmd1bWVudCBtYXlcbiAqIGJlIG9taXR0ZWQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUucmVuZGVyVG9rZW5zID0gZnVuY3Rpb24gcmVuZGVyVG9rZW5zICh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpIHtcbiAgdmFyIGJ1ZmZlciA9ICcnO1xuXG4gIHZhciB0b2tlbiwgc3ltYm9sLCB2YWx1ZTtcbiAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgIHN5bWJvbCA9IHRva2VuWzBdO1xuXG4gICAgaWYgKHN5bWJvbCA9PT0gJyMnKSB2YWx1ZSA9IHRoaXMucmVuZGVyU2VjdGlvbih0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG4gICAgZWxzZSBpZiAoc3ltYm9sID09PSAnXicpIHZhbHVlID0gdGhpcy5yZW5kZXJJbnZlcnRlZCh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG4gICAgZWxzZSBpZiAoc3ltYm9sID09PSAnPicpIHZhbHVlID0gdGhpcy5yZW5kZXJQYXJ0aWFsKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgY29uZmlnKTtcbiAgICBlbHNlIGlmIChzeW1ib2wgPT09ICcmJykgdmFsdWUgPSB0aGlzLnVuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0KTtcbiAgICBlbHNlIGlmIChzeW1ib2wgPT09ICduYW1lJykgdmFsdWUgPSB0aGlzLmVzY2FwZWRWYWx1ZSh0b2tlbiwgY29udGV4dCwgY29uZmlnKTtcbiAgICBlbHNlIGlmIChzeW1ib2wgPT09ICd0ZXh0JykgdmFsdWUgPSB0aGlzLnJhd1ZhbHVlKHRva2VuKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbldyaXRlci5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIHJlbmRlclNlY3Rpb24gKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGJ1ZmZlciA9ICcnO1xuICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlbmRlciBhbiBhcmJpdHJhcnkgdGVtcGxhdGVcbiAgLy8gaW4gdGhlIGN1cnJlbnQgY29udGV4dCBieSBoaWdoZXItb3JkZXIgc2VjdGlvbnMuXG4gIGZ1bmN0aW9uIHN1YlJlbmRlciAodGVtcGxhdGUpIHtcbiAgICByZXR1cm4gc2VsZi5yZW5kZXIodGVtcGxhdGUsIGNvbnRleHQsIHBhcnRpYWxzLCBjb25maWcpO1xuICB9XG5cbiAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuXG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGogPSAwLCB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaiA8IHZhbHVlTGVuZ3RoOyArK2opIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlW2pdKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LnB1c2godmFsdWUpLCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUZW1wbGF0ZSAhPT0gJ3N0cmluZycpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zIHdpdGhvdXQgdGhlIG9yaWdpbmFsIHRlbXBsYXRlJyk7XG5cbiAgICAvLyBFeHRyYWN0IHRoZSBwb3J0aW9uIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHRoZSBzZWN0aW9uIGNvbnRhaW5zLlxuICAgIHZhbHVlID0gdmFsdWUuY2FsbChjb250ZXh0LnZpZXcsIG9yaWdpbmFsVGVtcGxhdGUuc2xpY2UodG9rZW5bM10sIHRva2VuWzVdKSwgc3ViUmVuZGVyKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbldyaXRlci5wcm90b3R5cGUucmVuZGVySW52ZXJ0ZWQgPSBmdW5jdGlvbiByZW5kZXJJbnZlcnRlZCAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpIHtcbiAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuXG4gIC8vIFVzZSBKYXZhU2NyaXB0J3MgZGVmaW5pdGlvbiBvZiBmYWxzeS4gSW5jbHVkZSBlbXB0eSBhcnJheXMuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg2XG4gIGlmICghdmFsdWUgfHwgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkpXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbn07XG5cbldyaXRlci5wcm90b3R5cGUuaW5kZW50UGFydGlhbCA9IGZ1bmN0aW9uIGluZGVudFBhcnRpYWwgKHBhcnRpYWwsIGluZGVudGF0aW9uLCBsaW5lSGFzTm9uU3BhY2UpIHtcbiAgdmFyIGZpbHRlcmVkSW5kZW50YXRpb24gPSBpbmRlbnRhdGlvbi5yZXBsYWNlKC9bXiBcXHRdL2csICcnKTtcbiAgdmFyIHBhcnRpYWxCeU5sID0gcGFydGlhbC5zcGxpdCgnXFxuJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydGlhbEJ5TmwubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFydGlhbEJ5TmxbaV0ubGVuZ3RoICYmIChpID4gMCB8fCAhbGluZUhhc05vblNwYWNlKSkge1xuICAgICAgcGFydGlhbEJ5TmxbaV0gPSBmaWx0ZXJlZEluZGVudGF0aW9uICsgcGFydGlhbEJ5TmxbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0aWFsQnlObC5qb2luKCdcXG4nKTtcbn07XG5cbldyaXRlci5wcm90b3R5cGUucmVuZGVyUGFydGlhbCA9IGZ1bmN0aW9uIHJlbmRlclBhcnRpYWwgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgY29uZmlnKSB7XG4gIGlmICghcGFydGlhbHMpIHJldHVybjtcbiAgdmFyIHRhZ3MgPSB0aGlzLmdldENvbmZpZ1RhZ3MoY29uZmlnKTtcblxuICB2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKHBhcnRpYWxzKSA/IHBhcnRpYWxzKHRva2VuWzFdKSA6IHBhcnRpYWxzW3Rva2VuWzFdXTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB2YXIgbGluZUhhc05vblNwYWNlID0gdG9rZW5bNl07XG4gICAgdmFyIHRhZ0luZGV4ID0gdG9rZW5bNV07XG4gICAgdmFyIGluZGVudGF0aW9uID0gdG9rZW5bNF07XG4gICAgdmFyIGluZGVudGVkVmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodGFnSW5kZXggPT0gMCAmJiBpbmRlbnRhdGlvbikge1xuICAgICAgaW5kZW50ZWRWYWx1ZSA9IHRoaXMuaW5kZW50UGFydGlhbCh2YWx1ZSwgaW5kZW50YXRpb24sIGxpbmVIYXNOb25TcGFjZSk7XG4gICAgfVxuICAgIHZhciB0b2tlbnMgPSB0aGlzLnBhcnNlKGluZGVudGVkVmFsdWUsIHRhZ3MpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCBpbmRlbnRlZFZhbHVlLCBjb25maWcpO1xuICB9XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLnVuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gdW5lc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcbiAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiBlc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0LCBjb25maWcpIHtcbiAgdmFyIGVzY2FwZSA9IHRoaXMuZ2V0Q29uZmlnRXNjYXBlKGNvbmZpZykgfHwgbXVzdGFjaGUuZXNjYXBlO1xuICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBlc2NhcGUgPT09IG11c3RhY2hlLmVzY2FwZSkgPyBTdHJpbmcodmFsdWUpIDogZXNjYXBlKHZhbHVlKTtcbn07XG5cbldyaXRlci5wcm90b3R5cGUucmF3VmFsdWUgPSBmdW5jdGlvbiByYXdWYWx1ZSAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5nZXRDb25maWdUYWdzID0gZnVuY3Rpb24gZ2V0Q29uZmlnVGFncyAoY29uZmlnKSB7XG4gIGlmIChpc0FycmF5KGNvbmZpZykpIHtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIGVsc2UgaWYgKGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBjb25maWcudGFncztcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLmdldENvbmZpZ0VzY2FwZSA9IGZ1bmN0aW9uIGdldENvbmZpZ0VzY2FwZSAoY29uZmlnKSB7XG4gIGlmIChjb25maWcgJiYgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkoY29uZmlnKSkge1xuICAgIHJldHVybiBjb25maWcuZXNjYXBlO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbnZhciBtdXN0YWNoZSA9IHtcbiAgbmFtZTogJ211c3RhY2hlLmpzJyxcbiAgdmVyc2lvbjogJzQuMi4wJyxcbiAgdGFnczogWyAne3snLCAnfX0nIF0sXG4gIGNsZWFyQ2FjaGU6IHVuZGVmaW5lZCxcbiAgZXNjYXBlOiB1bmRlZmluZWQsXG4gIHBhcnNlOiB1bmRlZmluZWQsXG4gIHJlbmRlcjogdW5kZWZpbmVkLFxuICBTY2FubmVyOiB1bmRlZmluZWQsXG4gIENvbnRleHQ6IHVuZGVmaW5lZCxcbiAgV3JpdGVyOiB1bmRlZmluZWQsXG4gIC8qKlxuICAgKiBBbGxvd3MgYSB1c2VyIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGNhY2hpbmcgc3RyYXRlZ3ksIGJ5IHByb3ZpZGluZyBhblxuICAgKiBvYmplY3Qgd2l0aCBzZXQsIGdldCBhbmQgY2xlYXIgbWV0aG9kcy4gVGhpcyBjYW4gYWxzbyBiZSB1c2VkIHRvIGRpc2FibGVcbiAgICogdGhlIGNhY2hlIGJ5IHNldHRpbmcgaXQgdG8gdGhlIGxpdGVyYWwgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBzZXQgdGVtcGxhdGVDYWNoZSAoY2FjaGUpIHtcbiAgICBkZWZhdWx0V3JpdGVyLnRlbXBsYXRlQ2FjaGUgPSBjYWNoZTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgdGhlIGRlZmF1bHQgb3Igb3ZlcnJpZGRlbiBjYWNoaW5nIG9iamVjdCBmcm9tIHRoZSBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIGdldCB0ZW1wbGF0ZUNhY2hlICgpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci50ZW1wbGF0ZUNhY2hlO1xuICB9XG59O1xuXG4vLyBBbGwgaGlnaC1sZXZlbCBtdXN0YWNoZS4qIGZ1bmN0aW9ucyB1c2UgdGhpcyB3cml0ZXIuXG52YXIgZGVmYXVsdFdyaXRlciA9IG5ldyBXcml0ZXIoKTtcblxuLyoqXG4gKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhlIGRlZmF1bHQgd3JpdGVyLlxuICovXG5tdXN0YWNoZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSAoKSB7XG4gIHJldHVybiBkZWZhdWx0V3JpdGVyLmNsZWFyQ2FjaGUoKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIHRlbXBsYXRlIGluIHRoZSBkZWZhdWx0IHdyaXRlciBhbmQgcmV0dXJucyB0aGVcbiAqIGFycmF5IG9mIHRva2VucyBpdCBjb250YWlucy4gRG9pbmcgdGhpcyBhaGVhZCBvZiB0aW1lIGF2b2lkcyB0aGUgbmVlZCB0b1xuICogcGFyc2UgdGVtcGxhdGVzIG9uIHRoZSBmbHkgYXMgdGhleSBhcmUgcmVuZGVyZWQuXG4gKi9cbm11c3RhY2hlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gIHJldHVybiBkZWZhdWx0V3JpdGVyLnBhcnNlKHRlbXBsYXRlLCB0YWdzKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgYHRlbXBsYXRlYCB3aXRoIHRoZSBnaXZlbiBgdmlld2AsIGBwYXJ0aWFsc2AsIGFuZCBgY29uZmlnYFxuICogdXNpbmcgdGhlIGRlZmF1bHQgd3JpdGVyLlxuICovXG5tdXN0YWNoZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgY29uZmlnKSB7XG4gIGlmICh0eXBlb2YgdGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0ZW1wbGF0ZSEgVGVtcGxhdGUgc2hvdWxkIGJlIGEgXCJzdHJpbmdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXQgXCInICsgdHlwZVN0cih0ZW1wbGF0ZSkgKyAnXCIgd2FzIGdpdmVuIGFzIHRoZSBmaXJzdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmd1bWVudCBmb3IgbXVzdGFjaGUjcmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyknKTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0V3JpdGVyLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIGNvbmZpZyk7XG59O1xuXG4vLyBFeHBvcnQgdGhlIGVzY2FwaW5nIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIHVzZXIgbWF5IG92ZXJyaWRlIGl0LlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8yNDRcbm11c3RhY2hlLmVzY2FwZSA9IGVzY2FwZUh0bWw7XG5cbi8vIEV4cG9ydCB0aGVzZSBtYWlubHkgZm9yIHRlc3RpbmcsIGJ1dCBhbHNvIGZvciBhZHZhbmNlZCB1c2FnZS5cbm11c3RhY2hlLlNjYW5uZXIgPSBTY2FubmVyO1xubXVzdGFjaGUuQ29udGV4dCA9IENvbnRleHQ7XG5tdXN0YWNoZS5Xcml0ZXIgPSBXcml0ZXI7XG5cbmV4cG9ydCBkZWZhdWx0IG11c3RhY2hlO1xuIiwgImltcG9ydCBNdXN0YWNoZSBmcm9tICdtdXN0YWNoZSc7XG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBjb25zdCBURU1QTEFURV9WQVJJQUJMRVMgPSBge3twcmVfY3Vyc29yfX1cXG57e3Bvc3RfY3Vyc29yfX0gXFxue3thY3RpdmVfc2VudGVuY2V9fSBcXG57e2xhc3RfbGluZX19YDtcblxuaW50ZXJmYWNlIFRlbXBsYXRlQXJncyB7XG4gICAgcHJlX2N1cnNvcjogc3RyaW5nO1xuICAgIHBvc3RfY3Vyc29yOiBzdHJpbmc7XG4gICAgYWN0aXZlX3NlbnRlbmNlOiBzdHJpbmc7XG4gICAgbGFzdF9saW5lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFByb21wdCh0ZW1wbGF0ZTogc3RyaW5nLCBhcmdzOiBUZW1wbGF0ZUFyZ3MpOiBzdHJpbmcge1xuICAgIHJldHVybiBNdXN0YWNoZS5yZW5kZXIodGVtcGxhdGUsIGFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVByb21wdChlZGl0b3I6IEVkaXRvciwgdGVtcGxhdGU6IHN0cmluZyA9IFRFTVBMQVRFX1ZBUklBQkxFUyk6IHN0cmluZyB7XG4gICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgIGNvbnN0IHByZUN1cnNvciA9IGVkaXRvci5nZXRSYW5nZSh7IGxpbmU6IDAsIGNoOiAwIH0sIGN1cnNvcik7XG4gICAgY29uc3QgcG9zdEN1cnNvciA9IGVkaXRvci5nZXRSYW5nZShjdXJzb3IsIHsgbGluZTogZWRpdG9yLmxhc3RMaW5lKCksIGNoOiBlZGl0b3IuZ2V0TGluZShlZGl0b3IubGFzdExpbmUoKSkubGVuZ3RoIH0pO1xuICAgIGNvbnN0IGFjdGl2ZVNlbnRlbmNlID0gc2VudGVuY2VBdEN1cnNvcihlZGl0b3IpO1xuICAgIGNvbnN0IGxhc3RMaW5lID0gZWRpdG9yLmdldExpbmUoZWRpdG9yLmxhc3RMaW5lKCkpO1xuXG4gICAgcmV0dXJuIGJ1aWxkUHJvbXB0KHRlbXBsYXRlLCB7XG4gICAgICAgIHByZV9jdXJzb3I6IHByZUN1cnNvcixcbiAgICAgICAgcG9zdF9jdXJzb3I6IHBvc3RDdXJzb3IsXG4gICAgICAgIGFjdGl2ZV9zZW50ZW5jZTogYWN0aXZlU2VudGVuY2UsXG4gICAgICAgIGxhc3RfbGluZTogbGFzdExpbmVcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2VudGVuY2VBdEN1cnNvcihlZGl0b3I6IEVkaXRvcik6IHN0cmluZyB7XG4gICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgIGxldCBjdXJyZW50TGluZSA9IGN1cnNvci5saW5lO1xuICAgIGxldCBzZW50ZW5jZUxpbmVzID0gW2VkaXRvci5nZXRMaW5lKGN1cnJlbnRMaW5lKV07XG5cbiAgICAvLyBTZWFyY2ggYmFja3dhcmRzIHVudGlsIHNlbnRlbmNlIHN0YXJ0IGZvdW5kXG4gICAgd2hpbGUgKGN1cnJlbnRMaW5lID4gMCkge1xuICAgICAgICBjdXJyZW50TGluZS0tO1xuICAgICAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoY3VycmVudExpbmUpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHByZXZpb3VzIGxpbmUgZW5kcyB3aXRoIHNlbnRlbmNlIGVuZGluZ1xuICAgICAgICBpZiAoL1suIT9dXFxzKiQvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VudGVuY2VMaW5lcy51bnNoaWZ0KGxpbmUpO1xuICAgIH1cblxuICAgIC8vIEpvaW4gbGluZXMgYW5kIGNsZWFuIHVwIHdoaXRlc3BhY2VcbiAgICByZXR1cm4gc2VudGVuY2VMaW5lc1xuICAgICAgICAuam9pbignICcpXG4gICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJylcbiAgICAgICAgLnRyaW0oKTtcbn0iLCAiaW1wb3J0IHsgTW9kZWxSZXNwb25zZSwgT2xsYW1hIH0gZnJvbSBcIm9sbGFtYVwiO1xuaW1wb3J0IHsgT2xsYW1hU2V0dGluZ3MgfSBmcm9tIFwiLi9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tIFwiLi5cIjtcbmltcG9ydCB7IEVkaXRvciB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgcHJlcGFyZVByb21wdCB9IGZyb20gXCJzcmMvcHJvbXB0L3Byb21wdFwiO1xuaW1wb3J0IHsgQ29tcGxldGlvbk9wdGlvbnMgfSBmcm9tIFwic3JjL3NldHRpbmdzXCI7XG5cbmV4cG9ydCBjbGFzcyBPbGxhbWFQcm92aWRlciBpbXBsZW1lbnRzIFByb3ZpZGVyIHtcbiAgICBjbGllbnQ6IE9sbGFtYVxuICAgIHNldHRpbmdzOiBPbGxhbWFTZXR0aW5ncztcbiAgICBhYm9ydGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5zOiBPbGxhbWFTZXR0aW5ncykge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGlucztcbiAgICAgICAgdGhpcy5jbGllbnQgPSBuZXcgT2xsYW1hKHsgaG9zdDogdGhpcy5zZXR0aW5ncy5ob3N0IH0pO1xuICAgIH1cblxuICAgIGFzeW5jICpnZW5lcmF0ZShlZGl0b3I6IEVkaXRvciwgb3B0aW9uczogQ29tcGxldGlvbk9wdGlvbnMpOiBBc3luY0dlbmVyYXRvcjxzdHJpbmc+IHtcbiAgICAgICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHByb21wdCA9IHByZXBhcmVQcm9tcHQoZWRpdG9yLCBvcHRpb25zLnVzZXJQcm9tcHQpO1xuXG4gICAgICAgIGNvbnN0IGNvbXBsZXRpb25JdGVyYXRvciA9IGF3YWl0IHRoaXMuY2xpZW50LmdlbmVyYXRlKHtcbiAgICAgICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHQsXG4gICAgICAgICAgICBzeXN0ZW06IG9wdGlvbnMuc3lzdGVtUHJvbXB0LFxuICAgICAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiBvcHRpb25zLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBpbml0aWFsUG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGxldCBjb21wbGV0aW9uID0gXCJcIjtcbiAgICAgICAgZm9yIGF3YWl0IChsZXQgcmVzcG9uc2Ugb2YgY29tcGxldGlvbkl0ZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbi5saW5lICE9PSBpbml0aWFsUG9zaXRpb24ubGluZSB8fCBjdXJyZW50UG9zaXRpb24uY2ggIT09IGluaXRpYWxQb3NpdGlvbi5jaCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY3Vyc29yIG1vdmVkLCBhYm9ydGluZyBjb21wbGV0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wbGV0aW9uICs9IHJlc3BvbnNlLnJlc3BvbnNlO1xuICAgICAgICAgICAgeWllbGQgY29tcGxldGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgIHRoaXMuY2xpZW50LmFib3J0KCk7XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiYWJvcnRlZCBjb21wbGV0aW9uXCIpO1xuICAgIH1cblxuICAgIGFzeW5jIHVwZGF0ZU1vZGVscygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQubGlzdCgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UubW9kZWxzLm1hcCgobW9kZWw6IE1vZGVsUmVzcG9uc2UpID0+IG1vZGVsLm5hbWUpO1xuICAgIH1cbn1cblxuXG4iLCAiaW1wb3J0IHsgU2V0dGluZ3MgfSBmcm9tIFwic3JjL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBPcGVuQUlQcm92aWRlciB9IGZyb20gXCIuL29wZW5haVwiO1xuaW1wb3J0IHsgT2xsYW1hUHJvdmlkZXIgfSBmcm9tIFwiLi9vbGxhbWFcIjtcblxuZXhwb3J0ICogZnJvbSBcIi4vcHJvdmlkZXJcIjtcblxuZXhwb3J0IGVudW0gUHJvdmlkZXJUeXBlIHtcbiAgICBPTExBTUEgPSBcIm9sbGFtYVwiLFxuICAgIE9QRU5BSSA9IFwib3BlbmFpXCIsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvdmlkZXJzIHtcbiAgICBbUHJvdmlkZXJUeXBlLk9MTEFNQV06IE9sbGFtYVByb3ZpZGVyLFxuICAgIFtQcm92aWRlclR5cGUuT1BFTkFJXTogT3BlbkFJUHJvdmlkZXIsXG59XG5cbmV4cG9ydCBjb25zdCBidWlsZFByb3ZpZGVycyA9IChzZXR0aW5nczogU2V0dGluZ3MpOiBQcm92aWRlcnMgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtQcm92aWRlclR5cGUuT0xMQU1BXTogbmV3IE9sbGFtYVByb3ZpZGVyKHNldHRpbmdzLnByb3ZpZGVycy5vbGxhbWEpLFxuICAgICAgICBbUHJvdmlkZXJUeXBlLk9QRU5BSV06IG5ldyBPcGVuQUlQcm92aWRlcihzZXR0aW5ncy5wcm92aWRlcnMub3BlbmFpKSxcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBCdXR0b25Db21wb25lbnQsIEV4dHJhQnV0dG9uQ29tcG9uZW50LCBEcm9wZG93bkNvbXBvbmVudCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgVEVNUExBVEVfVkFSSUFCTEVTIH0gZnJvbSBcInNyYy9wcm9tcHQvcHJvbXB0XCI7XG5pbXBvcnQgeyBTcGxpdFN0cmF0ZWd5IH0gZnJvbSBcInNyYy9leHRlbnNpb25cIjtcbmltcG9ydCBJbnNjcmliZSBmcm9tIFwic3JjL21haW5cIjtcbmltcG9ydCB7IFByb3ZpZGVyVHlwZSB9IGZyb20gXCJzcmMvcHJvdmlkZXJzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BST0ZJTEUsIG5ld1Byb2ZpbGUsIFByb2ZpbGUgfSBmcm9tIFwiLi9pbmRleFwiO1xuaW1wb3J0IHsgUHJvdmlkZXJTZXR0aW5nc01vZGFsIH0gZnJvbSBcIi4vcHJvdmlkZXItbW9kYWxcIjtcblxuZXhwb3J0IGNsYXNzIEluc2NyaWJlU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNlY3Rpb25zOiB7XG4gICAgICAgIHByb3ZpZGVyczogSFRNTEVsZW1lbnQ7XG4gICAgICAgIHByb2ZpbGVzOiBIVE1MRWxlbWVudDtcbiAgICAgICAgcHJvZmlsZTogSFRNTEVsZW1lbnQ7XG4gICAgICAgIHBhdGhNYXBwaW5nczogSFRNTEVsZW1lbnQ7XG4gICAgfTtcbiAgICBwcml2YXRlIGRpc3BsYXllZFByb2ZpbGVJZDogc3RyaW5nID0gREVGQVVMVF9QUk9GSUxFO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHByaXZhdGUgcGx1Z2luOiBJbnNjcmliZSkge1xuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgICAgIHRoaXMuc2VjdGlvbnMgPSB7XG4gICAgICAgICAgICBwcm92aWRlcnM6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgcHJvZmlsZXM6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgcHJvZmlsZTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICBwYXRoTWFwcGluZ3M6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzcGxheSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIHNlY3Rpb24gY29udGFpbmVycyB3aXRoIHByb3BlciBzcGFjaW5nXG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5zZWN0aW9ucykuZm9yRWFjaChzZWN0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLmFwcGVuZENoaWxkKHNlY3Rpb24pO1xuICAgICAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJiclwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJQcm92aWRlcnMoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJQcm9maWxlcygpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlclBhdGhNYXBwaW5ncygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcmVuZGVyUHJvdmlkZXJzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB7IHByb3ZpZGVycyB9ID0gdGhpcy5zZWN0aW9ucztcbiAgICAgICAgcHJvdmlkZXJzLmVtcHR5KCk7XG5cbiAgICAgICAgcHJvdmlkZXJzLmNyZWF0ZUVsKFwiaDNcIiwgeyB0ZXh0OiBcIlByb3ZpZGVyc1wiIH0pO1xuICAgICAgICBwcm92aWRlcnMuY3JlYXRlRWwoXCJwXCIsIHsgdGV4dDogXCJDb25maWd1cmUgdGhlIEFJIHByb3ZpZGVycyB5b3Ugd2FudCB0byB1c2UgZm9yIGNvbXBsZXRpb25zXCIgfSk7XG5cbiAgICAgICAgLy8gT2xsYW1hIFByb3ZpZGVyXG4gICAgICAgIG5ldyBTZXR0aW5nKHByb3ZpZGVycylcbiAgICAgICAgICAgIC5zZXROYW1lKFwiT2xsYW1hXCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkxvY2FsIEFJIHByb3ZpZGVyIHJ1bm5pbmcgb24geW91ciBtYWNoaW5lXCIpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKChidXR0b246IEJ1dHRvbkNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChcIkNvbmZpZ3VyZVwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkNvbmZpZ3VyZSBPbGxhbWFcIilcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4gdGhpcy5vcGVuUHJvdmlkZXJNb2RhbChQcm92aWRlclR5cGUuT0xMQU1BKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBPcGVuQUkgUHJvdmlkZXJcbiAgICAgICAgbmV3IFNldHRpbmcocHJvdmlkZXJzKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJPcGVuQUlcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiT3BlbkFJIEFQSSBwcm92aWRlclwiKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbigoYnV0dG9uOiBCdXR0b25Db21wb25lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoXCJDb25maWd1cmVcIilcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJDb25maWd1cmUgT3BlbkFJXCIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHRoaXMub3BlblByb3ZpZGVyTW9kYWwoUHJvdmlkZXJUeXBlLk9QRU5BSSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBvcGVuUHJvdmlkZXJNb2RhbCh0eXBlOiBQcm92aWRlclR5cGUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgbmV3IFByb3ZpZGVyU2V0dGluZ3NNb2RhbChcbiAgICAgICAgICAgIHRoaXMuYXBwLFxuICAgICAgICAgICAgdGhpcy5wbHVnaW4sXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5yZW5kZXJQcm92aWRlcnMoKVxuICAgICAgICApLm9wZW4oKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlbmRlclByb2ZpbGVzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB7IHByb2ZpbGVzIH0gPSB0aGlzLnNlY3Rpb25zO1xuICAgICAgICBwcm9maWxlcy5lbXB0eSgpO1xuXG4gICAgICAgIHByb2ZpbGVzLmNyZWF0ZUVsKFwiaDNcIiwgeyB0ZXh0OiBcIlByb2ZpbGVzXCIgfSk7XG4gICAgICAgIHByb2ZpbGVzLmNyZWF0ZUVsKFwicFwiLCB7IHRleHQ6IFwiQ29uZmlndXJlIHRoZSBzZXR0aW5ncyBmb3IgZWFjaCBwcm9maWxlLiBBIHByb2ZpbGUgY2FuIGJlIGFzc2lnbmVkIHRvIHBhdGhzLiBUaGUgZGVmYXVsdCBwcm9maWxlIGlzIHVzZWQgd2hlbiBubyBwcm9maWxlIGlzIGFzc2lnbmVkLlwiIH0pO1xuXG4gICAgICAgIGNvbnN0IGRpc3BsYXllZFByb2ZpbGUgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9maWxlc1t0aGlzLmRpc3BsYXllZFByb2ZpbGVJZF07XG4gICAgICAgIGF3YWl0IHRoaXMucmVuZGVyUHJvZmlsZVNlbGVjdGlvbigpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlclByb2ZpbGVTZXR0aW5ncyhkaXNwbGF5ZWRQcm9maWxlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlbmRlclByb2ZpbGVTZWxlY3Rpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIC8vYWRkZCBwYWRkaW5nXG4gICAgICAgIHRoaXMuc2VjdGlvbnMucHJvZmlsZXMuY3JlYXRlRWwoXCJiclwiKTtcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5zZWN0aW9ucy5wcm9maWxlcylcbiAgICAgICAgICAgIC5zZXRIZWFkaW5nKClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiTWFuYWdlIHByb2ZpbGVcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiU2VsZWN0IGEgcHJvZmlsZSB0byBjb25maWd1cmUgaXRzIHNldHRpbmdzXCIpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24odGhpcy5jcmVhdGVQcm9maWxlRHJvcGRvd24uYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbih0aGlzLmNyZWF0ZU5ld1Byb2ZpbGVCdXR0b24uYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbih0aGlzLmNyZWF0ZURlbGV0ZVByb2ZpbGVCdXR0b24uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVQcm9maWxlRHJvcGRvd24oZHJvcGRvd246IERyb3Bkb3duQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2ZpbGVzKS5mb3JFYWNoKChbaWQsIHByb2ZpbGVdKSA9PiB7XG4gICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24oaWQsIHByb2ZpbGUubmFtZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyb3Bkb3duXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5kaXNwbGF5ZWRQcm9maWxlSWQpXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRQcm9maWxlSWQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlclByb2ZpbGVTZXR0aW5ncyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9maWxlc1t2YWx1ZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVOZXdQcm9maWxlQnV0dG9uKGJ1dHRvbjogRXh0cmFCdXR0b25Db21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgYnV0dG9uXG4gICAgICAgICAgICAuc2V0SWNvbihcInBsdXNcIilcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiQ3JlYXRlIG5ldyBwcm9maWxlXCIpXG4gICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRQcm9maWxlSWQgPSBuZXdQcm9maWxlKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2ZpbGVzKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlclByb2ZpbGVzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZURlbGV0ZVByb2ZpbGVCdXR0b24oYnV0dG9uOiBFeHRyYUJ1dHRvbkNvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCBpc0RlZmF1bHQgPSB0aGlzLmRpc3BsYXllZFByb2ZpbGVJZCA9PT0gREVGQVVMVF9QUk9GSUxFO1xuICAgICAgICBidXR0b25cbiAgICAgICAgICAgIC5zZXREaXNhYmxlZChpc0RlZmF1bHQpXG4gICAgICAgICAgICAuc2V0SWNvbihcInRyYXNoXCIpXG4gICAgICAgICAgICAuc2V0VG9vbHRpcChpc0RlZmF1bHQgPyBcIkNhbm5vdCBkZWxldGUgZGVmYXVsdCBwcm9maWxlXCIgOiBcIkRlbGV0ZSBwcm9maWxlXCIpXG4gICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2ZpbGVzW3RoaXMuZGlzcGxheWVkUHJvZmlsZUlkXTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXllZFByb2ZpbGVJZCA9IERFRkFVTFRfUFJPRklMRTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlclByb2ZpbGVzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlbmRlclByb2ZpbGVTZXR0aW5ncyhwcm9maWxlOiBQcm9maWxlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHsgcHJvZmlsZTogcHJvZmlsZVNlY3Rpb24gfSA9IHRoaXMuc2VjdGlvbnM7XG4gICAgICAgIHByb2ZpbGVTZWN0aW9uLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gUHJvZmlsZSBOYW1lXG4gICAgICAgIG5ldyBTZXR0aW5nKHByb2ZpbGVTZWN0aW9uKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJQcm9maWxlIE5hbWVcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiTmFtZSBvZiB0aGUgcHJvZmlsZVwiKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShwcm9maWxlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGUubmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJvdmlkZXIgU2VsZWN0aW9uXG4gICAgICAgIG5ldyBTZXR0aW5nKHByb2ZpbGVTZWN0aW9uKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJBSSBQcm92aWRlclwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJDaG9vc2UgeW91ciBwcmVmZXJyZWQgQUkgcHJvdmlkZXJcIilcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFByb3ZpZGVyVHlwZS5PTExBTUEsIFwiT2xsYW1hXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oUHJvdmlkZXJUeXBlLk9QRU5BSSwgXCJPcGVuQUlcIilcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHByb2ZpbGUucHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IFByb3ZpZGVyVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZS5wcm92aWRlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTW9kZWwgU2VsZWN0aW9uXG4gICAgICAgIG5ldyBTZXR0aW5nKHByb2ZpbGVTZWN0aW9uKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJNb2RlbFwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJTZWxlY3QgdGhlIG1vZGVsIHRvIHVzZSBmb3IgY29tcGxldGlvbnNcIilcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbHMgPSBwcm9maWxlLnByb3ZpZGVyID09PSBQcm92aWRlclR5cGUuT0xMQU1BXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXJzLm9sbGFtYS5tb2RlbHNcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlcnMub3BlbmFpLm1vZGVscztcblxuICAgICAgICAgICAgICAgIG1vZGVscy5mb3JFYWNoKG1vZGVsID0+IGRyb3Bkb3duLmFkZE9wdGlvbihtb2RlbCwgbW9kZWwpKTtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocHJvZmlsZS5jb21wbGV0aW9uT3B0aW9ucy5tb2RlbClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZS5jb21wbGV0aW9uT3B0aW9ucy5tb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGVtcGVyYXR1cmUgU2V0dGluZ1xuICAgICAgICBuZXcgU2V0dGluZyhwcm9maWxlU2VjdGlvbilcbiAgICAgICAgICAgIC5zZXROYW1lKFwiVGVtcGVyYXR1cmVcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiQ29udHJvbCB0aGUgcmFuZG9tbmVzcyBvZiBjb21wbGV0aW9ucyAoMCA9IGRldGVybWluaXN0aWMsIDEgPSBjcmVhdGl2ZSlcIilcbiAgICAgICAgICAgIC5hZGRTbGlkZXIoKHNsaWRlcikgPT4ge1xuICAgICAgICAgICAgICAgIHNsaWRlclxuICAgICAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDAsIDEsIDAuMSlcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHByb2ZpbGUuY29tcGxldGlvbk9wdGlvbnMudGVtcGVyYXR1cmUpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREeW5hbWljVG9vbHRpcCgpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGUuY29tcGxldGlvbk9wdGlvbnMudGVtcGVyYXR1cmUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERlbGF5IFNldHRpbmdcbiAgICAgICAgbmV3IFNldHRpbmcocHJvZmlsZVNlY3Rpb24pXG4gICAgICAgICAgICAuc2V0TmFtZShcIlN1Z2dlc3Rpb24gRGVsYXlcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiRGVsYXkgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSBmZXRjaGluZyBzdWdnZXN0aW9uc1wiKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0QXR0cihcInR5cGVcIiwgXCJudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCIxMDAwXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShTdHJpbmcocHJvZmlsZS5kZWxheU1zKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZS5kZWxheU1zID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3BsaXQgU3RyYXRlZ3kgU2V0dGluZ1xuICAgICAgICBuZXcgU2V0dGluZyhwcm9maWxlU2VjdGlvbilcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQ29tcGxldGlvbiBTdHJhdGVneVwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJDaG9vc2UgaG93IGNvbXBsZXRpb25zIHNob3VsZCBiZSBzcGxpdCBhbmQgYWNjZXB0ZWRcIilcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwid29yZFwiLCBcIldvcmQgYnkgV29yZFwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwic2VudGVuY2VcIiwgXCJTZW50ZW5jZSBieSBTZW50ZW5jZVwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwicGFyYWdyYXBoXCIsIFwiUGFyYWdyYXBoIGJ5IFBhcmFncmFwaFwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwiZnVsbFwiLCBcIkZ1bGwgQ29tcGxldGlvblwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocHJvZmlsZS5zcGxpdFN0cmF0ZWd5KVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBTcGxpdFN0cmF0ZWd5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9maWxlLnNwbGl0U3RyYXRlZ3kgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN5c3RlbSBQcm9tcHRcbiAgICAgICAgbmV3IFNldHRpbmcocHJvZmlsZVNlY3Rpb24pXG4gICAgICAgICAgICAuc2V0TmFtZShcIlN5c3RlbSBQcm9tcHRcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiU2V0IHN5c3RlbSBwcm9tcHRcIilcbiAgICAgICAgICAgIC5hZGRUZXh0QXJlYSgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5yb3dzID0gMztcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0Q3NzU3R5bGVzKHsgd2lkdGg6IFwiMTAwJVwiLCByZXNpemU6IFwidmVydGljYWxcIiwgcG9zaXRpb246IFwicmVsYXRpdmVcIiB9KTsgdGV4dFxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocHJvZmlsZS5jb21wbGV0aW9uT3B0aW9ucy5zeXN0ZW1Qcm9tcHQpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGUuY29tcGxldGlvbk9wdGlvbnMuc3lzdGVtUHJvbXB0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBVc2VyIFByb21wdFxuICAgICAgICBuZXcgU2V0dGluZyhwcm9maWxlU2VjdGlvbilcbiAgICAgICAgICAgIC5zZXROYW1lKFwiVXNlciBQcm9tcHRcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiVXNlciBwcm9tcHQgdGVtcGxhdGUgXCIpXG4gICAgICAgICAgICAuYWRkRXh0cmFCdXR0b24oKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbihcImxpc3RcIilcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJJbnNlcnQgbXVzdGFjaGUgdGVtcGxhdGUgdmFyaWFibGVzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBwcm9maWxlLmNvbXBsZXRpb25PcHRpb25zLnVzZXJQcm9tcHQgKyBcIlxcblwiICsgVEVNUExBVEVfVkFSSUFCTEVTO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZS5jb21wbGV0aW9uT3B0aW9ucy51c2VyUHJvbXB0ID0gdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJQcm9maWxlU2V0dGluZ3MocHJvZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hZGRUZXh0QXJlYSgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5yb3dzID0gMztcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0Q3NzU3R5bGVzKHsgd2lkdGg6IFwiMTAwJVwiLCByZXNpemU6IFwidmVydGljYWxcIiwgcG9zaXRpb246IFwicmVsYXRpdmVcIiB9KTtcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShwcm9maWxlLmNvbXBsZXRpb25PcHRpb25zLnVzZXJQcm9tcHQpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGUuY29tcGxldGlvbk9wdGlvbnMudXNlclByb21wdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyByZW5kZXJQYXRoTWFwcGluZ3MoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHsgcGF0aE1hcHBpbmdzOiBwYXRoUHJvZmlsZU1hcHBpbmdzIH0gPSB0aGlzLnNlY3Rpb25zO1xuICAgICAgICBwYXRoUHJvZmlsZU1hcHBpbmdzLmVtcHR5KCk7XG5cbiAgICAgICAgcGF0aFByb2ZpbGVNYXBwaW5ncy5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJEeW5hbWljIFByb2ZpbGUgTWFwcGluZ1wiIH0pO1xuICAgICAgICBwYXRoUHJvZmlsZU1hcHBpbmdzLmNyZWF0ZUVsKFwicFwiLCB7IHRleHQ6IFwiQ29uZmlndXJlIHdoaWNoIHByb2ZpbGUgdG8gdXNlIGZvciBzcGVjaWZpYyBwYXRocy4gUGF0aHMgYXJlIG1hdGNoZWQgYnkgcHJlZml4LCB3aXRoIGxvbmdlciBwYXRocyB0YWtpbmcgcHJlY2VkZW5jZS4gRm9yIGV4YW1wbGUsICcvRGFpbHknIHdpbGwgbWF0Y2ggYWxsIGZpbGVzIGluIHRoZSBEYWlseSBmb2xkZXIuXCIgfSk7XG5cbiAgICAgICAgLy8gQWRkIHNwYWNpbmdcbiAgICAgICAgcGF0aFByb2ZpbGVNYXBwaW5ncy5jcmVhdGVFbChcImJyXCIpO1xuXG4gICAgICAgIC8vIEFkZCBidXR0b24gdG8gY3JlYXRlIG5ldyBtYXBwaW5nXG4gICAgICAgIG5ldyBTZXR0aW5nKHBhdGhQcm9maWxlTWFwcGluZ3MpXG4gICAgICAgICAgICAuc2V0SGVhZGluZygpXG4gICAgICAgICAgICAuc2V0TmFtZShcIkFkZCBQYXRoIFByb2ZpbGUgTWFwcGluZ1wiKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbigoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICAgICAgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KFwiQWRkXCIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhIG5ldyBlbXB0eSBtYXBwaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXRoX3Byb2ZpbGVfbWFwcGluZ3NbXCJcIl0gPSBERUZBVUxUX1BST0ZJTEU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyUGF0aE1hcHBpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIHNwYWNpbmdcbiAgICAgICAgcGF0aFByb2ZpbGVNYXBwaW5ncy5jcmVhdGVFbChcImJyXCIpO1xuXG4gICAgICAgIC8vIFJlbmRlciBleGlzdGluZyBtYXBwaW5nc1xuICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXRoX3Byb2ZpbGVfbWFwcGluZ3MpLmZvckVhY2goKFtwYXRoLCBwcm9maWxlTmFtZV0pID0+IHtcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKHBhdGhQcm9maWxlTWFwcGluZ3MpXG4gICAgICAgICAgICAgICAgLnNldE5hbWUocGF0aCB8fCBcIlJvb3RcIilcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJFbnRlciBwYXRoIChlLmcuLCBEYWlseS9Xb3JrKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBtYXBwaW5nIGFuZCBhZGQgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXRoX3Byb2ZpbGVfbWFwcGluZ3NbcGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGF0aF9wcm9maWxlX21hcHBpbmdzW3ZhbHVlXSA9IHByb2ZpbGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYWRkRHJvcGRvd24oKGRyb3Bkb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgYXZhaWxhYmxlIHByb2ZpbGVzIHRvIHRoZSBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9maWxlcykuZm9yRWFjaCgoW2lkLCBwcm9maWxlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKGlkLCBwcm9maWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShwcm9maWxlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXRoX3Byb2ZpbGVfbWFwcGluZ3NbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKChidXR0b24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbihcInRyYXNoXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkRlbGV0ZSBtYXBwaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucGx1Z2luLnNldHRpbmdzLnBhdGhfcHJvZmlsZV9tYXBwaW5nc1twYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlclBhdGhNYXBwaW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBNb2RhbCwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgUHJvdmlkZXJUeXBlIH0gZnJvbSBcInNyYy9wcm92aWRlcnNcIjtcbmltcG9ydCB7IFNldHRpbmdzIH0gZnJvbSBcIi5cIjtcbmltcG9ydCBJbnNjcmliZSBmcm9tIFwic3JjL21haW5cIjtcblxuZXhwb3J0IGNsYXNzIFByb3ZpZGVyU2V0dGluZ3NNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgYXBwOiBBcHAsXG4gICAgICAgIHByaXZhdGUgcGx1Z2luOiBJbnNjcmliZSxcbiAgICAgICAgcHJpdmF0ZSBwcm92aWRlclR5cGU6IFByb3ZpZGVyVHlwZSxcbiAgICAgICAgcHJpdmF0ZSBvblNhdmU6ICgpID0+IHZvaWRcbiAgICApIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICB9XG5cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuXG4gICAgICAgIC8vIEFwcGx5IGN1c3RvbSBtb2RhbCBzdHlsZXNcbiAgICAgICAgdGhpcy5tb2RhbEVsLmFkZENsYXNzKCdpbnNjcmliZS1wcm92aWRlci1tb2RhbCcpO1xuICAgICAgICB0aGlzLm1vZGFsRWwuc3R5bGUud2lkdGggPSAnNjB2dyc7XG4gICAgICAgIHRoaXMubW9kYWxFbC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgY29udGFpbmVyIGZvciBiZXR0ZXIgc3R5bGluZ1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAnaW5zY3JpYmUtbW9kYWwtY29udGFpbmVyJyB9KTtcblxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJUeXBlID09PSBQcm92aWRlclR5cGUuT0xMQU1BID9cbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVycy5vbGxhbWEgOlxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXJzLm9wZW5haTtcblxuICAgICAgICAvLyBIZWFkZXIgc2VjdGlvblxuICAgICAgICBjb25zdCBoZWFkZXIgPSBjb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAnaW5zY3JpYmUtbW9kYWwtaGVhZGVyJyB9KTtcbiAgICAgICAgaGVhZGVyLmNyZWF0ZUVsKFwiaDJcIiwge1xuICAgICAgICAgICAgdGV4dDogYENvbmZpZ3VyZSAke3Byb3ZpZGVyLm5hbWV9YCxcbiAgICAgICAgICAgIGNsczogJ2luc2NyaWJlLW1vZGFsLXRpdGxlJ1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb250ZW50IHNlY3Rpb25cbiAgICAgICAgY29uc3QgY29udGVudCA9IGNvbnRhaW5lci5jcmVhdGVEaXYoeyBjbHM6ICdpbnNjcmliZS1tb2RhbC1jb250ZW50JyB9KTtcblxuICAgICAgICBpZiAodGhpcy5wcm92aWRlclR5cGUgPT09IFByb3ZpZGVyVHlwZS5PTExBTUEpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sbGFtYVByb3ZpZGVyID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXJzLm9sbGFtYTtcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnQpXG4gICAgICAgICAgICAgICAgLnNldENsYXNzKCdpbnNjcmliZS1tb2RhbC1zZXR0aW5nJylcbiAgICAgICAgICAgICAgICAuc2V0TmFtZShcIkhvc3RcIilcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhcIllvdXIgT2xsYW1hIGluc3RhbmNlIFVSTFwiKVxuICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcImh0dHA6Ly9sb2NhbGhvc3Q6MTE0MzRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShvbGxhbWFQcm92aWRlci5ob3N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sbGFtYVByb3ZpZGVyLmhvc3QgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuYWRkQ2xhc3MoJ2luc2NyaWJlLW1vZGFsLWlucHV0Jyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvcGVuYWlQcm92aWRlciA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVycy5vcGVuYWk7XG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50KVxuICAgICAgICAgICAgICAgIC5zZXRDbGFzcygnaW5zY3JpYmUtbW9kYWwtc2V0dGluZycpXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoXCJBUEkgS2V5XCIpXG4gICAgICAgICAgICAgICAgLnNldERlc2MoXCJZb3VyIE9wZW5BSSBBUEkga2V5XCIpXG4gICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwic2stLi4uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUob3BlbmFpUHJvdmlkZXIuYXBpS2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5haVByb3ZpZGVyLmFwaUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5hZGRDbGFzcygnaW5zY3JpYmUtbW9kYWwtaW5wdXQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBjdXN0b20gc3R5bGVzXG4gICAgICAgIHRoaXMuYWRkU3R5bGVzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRTdHlsZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUuaWQgPSAnaW5zY3JpYmUtbW9kYWwtc3R5bGVzJztcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBgXG4gICAgICAgICAgICAuaW5zY3JpYmUtcHJvdmlkZXItbW9kYWwge1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogODAwcHggIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgICBtYXgtaGVpZ2h0OiA4MHZoICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDYwdncgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGF1dG8gIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5pbnNjcmliZS1tb2RhbC1jb250YWluZXIge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLmluc2NyaWJlLW1vZGFsLWhlYWRlciB7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMjRweCAzMnB4O1xuICAgICAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5pbnNjcmliZS1tb2RhbC10aXRsZSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41ZW07XG4gICAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgICAgICAgICAgICBjb2xvcjogdmFyKC0tdGV4dC1ub3JtYWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuaW5zY3JpYmUtbW9kYWwtY29udGVudCB7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMjRweCAzMnB4O1xuICAgICAgICAgICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5pbnNjcmliZS1tb2RhbC1zZXR0aW5nIHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAxcmVtIDA7XG4gICAgICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuaW5zY3JpYmUtbW9kYWwtc2V0dGluZyAuc2V0dGluZy1pdGVtLWluZm8ge1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAgMXJlbSAwIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5pbnNjcmliZS1tb2RhbC1pbnB1dCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiA4cHggMTJweCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDZweCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItZm9ybS1maWVsZCkgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGUgb25DbG9zZSgpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIC8vIFJlbW92ZSBjdXN0b20gc3R5bGVzXG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luc2NyaWJlLW1vZGFsLXN0eWxlcycpO1xuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuICAgICAgICB0aGlzLm9uU2F2ZSgpO1xuICAgIH1cbn0gIiwgImltcG9ydCB7IFByb3ZpZGVyVHlwZSB9IGZyb20gXCJzcmMvcHJvdmlkZXJzXCI7XG5pbXBvcnQgeyBTcGxpdFN0cmF0ZWd5IH0gZnJvbSBcInNyYy9leHRlbnNpb25cIjtcbmltcG9ydCB7IE9sbGFtYVNldHRpbmdzIH0gZnJvbSBcInNyYy9wcm92aWRlcnMvb2xsYW1hXCI7XG5pbXBvcnQgeyBPcGVuQUlTZXR0aW5ncyB9IGZyb20gXCJzcmMvcHJvdmlkZXJzL29wZW5haVwiO1xuXG4vLyBDb21wbGV0aW9uIG9wdGlvbnMgZm9yIGEgcHJvZmlsZVxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uT3B0aW9ucyB7XG4gICAgbW9kZWw6IHN0cmluZyxcbiAgICB1c2VyUHJvbXB0OiBzdHJpbmcsXG4gICAgc3lzdGVtUHJvbXB0OiBzdHJpbmcsXG4gICAgdGVtcGVyYXR1cmU6IG51bWJlclxufVxuXG4vLyBQcm9maWxlIHNldHRpbmdzXG5leHBvcnQgaW50ZXJmYWNlIFByb2ZpbGUge1xuICAgIG5hbWU6IHN0cmluZyxcbiAgICBwcm92aWRlcjogUHJvdmlkZXJUeXBlLFxuICAgIGRlbGF5TXM6IG51bWJlcixcbiAgICBzcGxpdFN0cmF0ZWd5OiBTcGxpdFN0cmF0ZWd5XG4gICAgY29tcGxldGlvbk9wdGlvbnM6IENvbXBsZXRpb25PcHRpb25zLFxufVxuXG5leHBvcnQgdHlwZSBQcm9maWxlTmFtZSA9IHN0cmluZztcbmV4cG9ydCB0eXBlIFByb2ZpbGVzID0gUmVjb3JkPFByb2ZpbGVOYW1lLCBQcm9maWxlPlxuXG5leHBvcnQgaW50ZXJmYWNlIFNldHRpbmdzIHtcbiAgICAvLyBhdmFpbGFibGUgcHJvdmlkZXJzXG4gICAgcHJvdmlkZXJzOiB7XG4gICAgICAgIG9sbGFtYTogT2xsYW1hU2V0dGluZ3MsXG4gICAgICAgIG9wZW5haTogT3BlbkFJU2V0dGluZ3MsXG4gICAgfSxcbiAgICAvLyBwcm9maWxlc1xuICAgIHByb2ZpbGVzOiBQcm9maWxlcyxcbiAgICAvLyBwYXRoIHRvIHByb2ZpbGUgbWFwcGluZ3NcbiAgICBwYXRoX3Byb2ZpbGVfbWFwcGluZ3M6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1BST0ZJTEU6IFByb2ZpbGVOYW1lID0gXCJkZWZhdWx0XCI7XG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogU2V0dGluZ3MgPSB7XG4gICAgcHJvdmlkZXJzOiB7XG4gICAgICAgIG9wZW5haToge1xuICAgICAgICAgICAgaW50ZWdyYXRpb246IFByb3ZpZGVyVHlwZS5PUEVOQUksXG4gICAgICAgICAgICBuYW1lOiBcIk9wZW4gQUlcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlVzZSBPcGVuQUkgQVBJcyB0byBnZW5lcmF0ZSB0ZXh0LlwiLFxuICAgICAgICAgICAgYXBpS2V5OiBcIlwiLFxuICAgICAgICAgICAgbW9kZWw6IFwiZ3B0LTRvXCIsXG4gICAgICAgICAgICBtb2RlbHM6IFtcImdwdC00XCIsIFwiZ3B0LTMuNS10dXJib1wiLCBcImdwdC0zLjVcIiwgXCJncHQtM1wiLCBcImdwdC0yXCIsIFwiZ3B0LTFcIl0sXG4gICAgICAgICAgICBjb25maWd1cmVkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgb2xsYW1hOiB7XG4gICAgICAgICAgICBpbnRlZ3JhdGlvbjogUHJvdmlkZXJUeXBlLk9MTEFNQSxcbiAgICAgICAgICAgIG5hbWU6IFwiT2xsYW1hXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJVc2UgeW91ciBvd24gT2xsYW1hIGluc3RhbmNlIHRvIGdlbmVyYXRlIHRleHQuXCIsXG4gICAgICAgICAgICBob3N0OiBcImh0dHA6Ly9sb2NhbGhvc3Q6MTE0MzRcIixcbiAgICAgICAgICAgIG1vZGVsczogW1wibGxhbWEzLjI6bGF0ZXN0XCIsIFwibWlzdHJhbC1uZW1vXCJdLFxuICAgICAgICAgICAgY29uZmlndXJlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHByb2ZpbGVzOiB7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiRGVmYXVsdCBQcm9maWxlXCIsXG4gICAgICAgICAgICBwcm92aWRlcjogUHJvdmlkZXJUeXBlLk9MTEFNQSxcbiAgICAgICAgICAgIGRlbGF5TXM6IDUwMCxcbiAgICAgICAgICAgIHNwbGl0U3RyYXRlZ3k6IFwid29yZFwiLFxuICAgICAgICAgICAgY29tcGxldGlvbk9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBtb2RlbDogXCJtaXN0cmFsLW5lbW9cIixcbiAgICAgICAgICAgICAgICB1c2VyUHJvbXB0OiAnQ29tcGxldGUgZm9sbG93aW5nIHRleHQ6XFxuIHt7cHJlX2N1cnNvcn19fScsXG4gICAgICAgICAgICAgICAgc3lzdGVtUHJvbXB0OiBcIllvdSBhcmUgYW4gaGVscGZ1bCBBSSBjb21wbGV0ZXIuIEZvbGxvdyBpbnN0cnVjdGlvbnNcIixcbiAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogMC41LFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0sXG4gICAgcGF0aF9wcm9maWxlX21hcHBpbmdzOiB7XG4gICAgICAgIFwiL1wiOiBERUZBVUxUX1BST0ZJTEUsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdQcm9maWxlKHByb2ZpbGVzOiBQcm9maWxlcyk6IHN0cmluZyB7XG4gICAgY29uc3QgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgNik7XG5cbiAgICAvLyBnZW5lcmF0ZSBhIG5ldyBwcm9maWxlIG5hbWVcbiAgICBsZXQgbmFtZSA9IFwiTmV3IFByb2ZpbGVcIjtcbiAgICAvLyBsb29wIHRocm91Z2ggdGhlIHByb2ZpbGVzIHRvIG1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB1bmlxdWVcbiAgICBsZXQgaSA9IDE7XG4gICAgT2JqZWN0LmVudHJpZXMocHJvZmlsZXMpLmZvckVhY2goKFssIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgbmFtZSA9IGBOZXcgUHJvZmlsZSAke2l9YDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gY29weSB0aGUgZGVmYXVsdCBwcm9maWxlXG4gICAgY29uc3QgZGVmYXVsdFByb2ZpbGUgPSBwcm9maWxlc1tERUZBVUxUX1BST0ZJTEVdO1xuICAgIGNvbnN0IHByb2ZpbGUgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRQcm9maWxlLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgIH07XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBwcm9maWxlXG4gICAgcHJvZmlsZXNbaWRdID0gcHJvZmlsZTtcblxuICAgIHJldHVybiBpZDtcbn1cblxuZXhwb3J0ICogZnJvbSBcIi4vdGFiXCI7XG5cbiIsICJpbXBvcnQgeyBFZGl0b3IgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IFN1Z2dlc3Rpb24gfSBmcm9tIFwic3JjL2V4dGVuc2lvblwiO1xuaW1wb3J0IHsgUHJvdmlkZXIsIFByb3ZpZGVycyB9IGZyb20gXCJzcmMvcHJvdmlkZXJzXCI7XG5pbXBvcnQgeyBDb21wbGV0aW9uT3B0aW9ucywgREVGQVVMVF9QUk9GSUxFLCBQcm9maWxlLCBTZXR0aW5ncyB9IGZyb20gXCJzcmMvc2V0dGluZ3NcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0ZUNvbXBsZXRpb24oZWRpdG9yOiBFZGl0b3IsIHByb3ZpZGVyOiBQcm92aWRlciwgb3B0aW9uczogQ29tcGxldGlvbk9wdGlvbnMpOiBBc3luY0dlbmVyYXRvcjxTdWdnZXN0aW9uPiB7XG4gICAgYXdhaXQgcHJvdmlkZXIuYWJvcnQoKTtcbiAgICBjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cbiAgICAvLyBJZiB0aGUgY3VycmVudCBsaW5lIGlzIGVtcHR5LCBkb24ndCBzdWdnZXN0IGFueXRoaW5nLlxuICAgIGNvbnN0IGN1cnJlbnRMaW5lID0gZWRpdG9yLmdldExpbmUoY3Vyc29yLmxpbmUpO1xuICAgIGlmICghY3VycmVudExpbmUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGlmIHRoZSBsYXN0IGNoYXJhY3RlciBpcyBhIHNwYWNlIG9yIGRvdCwgc3VnZ2VzdCBjb21wbGV0aW9ucy5cbiAgICBjb25zdCBsYXN0Q2hhciA9IGN1cnJlbnRMaW5lW2N1cnNvci5jaCAtIDFdO1xuICAgIGlmIChsYXN0Q2hhciAhPT0gXCIgXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciBhd2FpdCAoY29uc3QgdGV4dCBvZiBwcm92aWRlci5nZW5lcmF0ZShlZGl0b3IsIG9wdGlvbnMpKSB7XG4gICAgICAgIHlpZWxkIHsgdGV4dDogdGV4dCB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQcm9maWxlKHNldHRpbmdzOiBTZXR0aW5ncywgcHJvdmlkZXJzOiBQcm92aWRlcnMsIGZpbGVQYXRoOiBzdHJpbmcpOiBbUHJvdmlkZXIsIFByb2ZpbGVdIHtcbiAgICBjb25zdCBwcm9maWxlTmFtZSA9IHJlc29sdmVQcm9maWxlRnJvbVBhdGgoc2V0dGluZ3MsIGZpbGVQYXRoKTtcbiAgICBjb25zdCBwcm9maWxlID0gc2V0dGluZ3MucHJvZmlsZXNbcHJvZmlsZU5hbWVdO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gcHJvdmlkZXJzW3Byb2ZpbGUucHJvdmlkZXJdO1xuICAgIHJldHVybiBbcHJvdmlkZXIsIHByb2ZpbGVdO1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBwcm9maWxlIG5hbWUgYmFzZWQgb24gdGhlIGZpbGUgcGF0aFxuICogQHBhcmFtIHNldHRpbmdzIFBsdWdpbiBzZXR0aW5ncyBjb250YWluaW5nIHBhdGggbWFwcGluZ3MgYW5kIHByb2ZpbGVzXG4gKiBAcGFyYW0gZmlsZVBhdGggVGhlIHBhdGggb2YgdGhlIGZpbGUgcmVsYXRpdmUgdG8gdGhlIHZhdWx0IHJvb3RcbiAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSBwcm9maWxlIHRvIHVzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVByb2ZpbGVGcm9tUGF0aChzZXR0aW5nczogU2V0dGluZ3MsIGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIElmIG5vIHBhdGggbWFwcGluZ3MgZXhpc3QsIHJldHVybiBkZWZhdWx0IHByb2ZpbGVcbiAgICBpZiAoIXNldHRpbmdzLnBhdGhfcHJvZmlsZV9tYXBwaW5ncyB8fCBPYmplY3Qua2V5cyhzZXR0aW5ncy5wYXRoX3Byb2ZpbGVfbWFwcGluZ3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gREVGQVVMVF9QUk9GSUxFO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgZmlsZSBwYXRoIChyZW1vdmUgbGVhZGluZy90cmFpbGluZyBzbGFzaGVzKVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gZmlsZVBhdGgucmVwbGFjZSgvXlxcLyt8XFwvKyQvZywgJycpO1xuXG4gICAgLy8gRmluZCB0aGUgbG9uZ2VzdCBtYXRjaGluZyBwYXRoIHByZWZpeFxuICAgIGxldCBsb25nZXN0TWF0Y2ggPSAnJztcbiAgICBsZXQgbWF0Y2hlZFByb2ZpbGUgPSBERUZBVUxUX1BST0ZJTEU7XG5cbiAgICBPYmplY3QuZW50cmllcyhzZXR0aW5ncy5wYXRoX3Byb2ZpbGVfbWFwcGluZ3MpLmZvckVhY2goKFtwYXRoLCBwcm9maWxlXSkgPT4ge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTWFwcGluZ1BhdGggPSBwYXRoLnJlcGxhY2UoL15cXC8rfFxcLyskL2csICcnKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmlsZSBwYXRoIHN0YXJ0cyB3aXRoIHRoZSBtYXBwaW5nIHBhdGhcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRQYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZE1hcHBpbmdQYXRoKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGxvbmdlciBtYXRjaCB0aGFuIG91ciBjdXJyZW50IGxvbmdlc3QsIHVwZGF0ZSBpdFxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRNYXBwaW5nUGF0aC5sZW5ndGggPiBsb25nZXN0TWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9uZ2VzdE1hdGNoID0gbm9ybWFsaXplZE1hcHBpbmdQYXRoO1xuICAgICAgICAgICAgICAgIG1hdGNoZWRQcm9maWxlID0gcHJvZmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hdGNoZWRQcm9maWxlO1xufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQXVCOzs7QUNVdkIsa0JBT087QUFDUCxtQkFRTztBQXFEUCxJQUFNLHNCQUFzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLeEIsTUFBTSxDQUFDLFNBQWlCO0FBQ3BCLFVBQU0sWUFBWSxLQUFLLFFBQVEsR0FBRztBQUNsQyxXQUFPLGNBQWMsS0FDZixFQUFFLFVBQVUsTUFBTSxXQUFXLEdBQUcsSUFDaEM7QUFBQSxNQUNFLFVBQVUsS0FBSyxNQUFNLEdBQUcsWUFBWSxDQUFDO0FBQUEsTUFDckMsV0FBVyxLQUFLLE1BQU0sWUFBWSxDQUFDO0FBQUEsSUFDdkM7QUFBQSxFQUNSO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxVQUFVLENBQUMsU0FBaUI7QUFDeEIsVUFBTSxRQUFRLEtBQUssTUFBTSxVQUFVO0FBQ25DLFFBQUksU0FBUyxNQUFNLFVBQVUsUUFBVztBQUNwQyxhQUFP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QUFiLG1CQUFtQixTQUFRO0FBQzVDLFVBQU0sQ0FBQyxVQUFVLE9BQU8sSUFBSSxlQUFlLEtBQUssVUFBVSxLQUFLLFdBQVcsUUFBUTtBQUNsRixTQUFLLHdCQUF3QixVQUFVLFFBQVE7QUFDL0MsU0FBSyx3QkFBd0IsZ0JBQWdCLFFBQVE7QUFDckQsV0FBTyxtQkFBbUIsYUFBYSxRQUFRLFVBQVUsUUFBUSxpQkFBaUI7QUFBQSxFQUNuRjtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFNBQUssV0FBVyxPQUFPO0FBQUEsTUFDdEIsQ0FBQztBQUFBLE1BQ0Q7QUFBQSxNQUNBLE1BQU0sS0FBSyxTQUFTO0FBQUEsSUFDckI7QUFBQSxFQUNEO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDcEIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQ2pDLFVBQU0sS0FBSyxjQUFjO0FBQUEsRUFDMUI7QUFDRDsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgImZldGNoIiwgInJlc29sdmUiLCAicmVzb2x2ZSIsICJmZXRjaCIsICJmZXRjaCIsICJfX2RlZlByb3AiLCAiT2xsYW1hIiwgImZzIiwgImluZGV4IiwgImdldCIsICJzZWxmIiwgImNsZWFyQ2FjaGUiLCAicGFyc2UiLCAicmVuZGVyIiwgIk9sbGFtYSIsICJpbXBvcnRfb2JzaWRpYW4iXQp9Cg==
