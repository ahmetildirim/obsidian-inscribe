/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Inscribe
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/extension/index.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var TextSplitStrategies = {
  /**
   * Word-level segmentation (space-delimited).
   * Accepts text until (and including) the first space.
   */
  word: (text) => {
    const nextSpace = text.indexOf(" ");
    return nextSpace === -1 ? { accepted: text, remaining: "" } : {
      accepted: text.slice(0, nextSpace + 1),
      remaining: text.slice(nextSpace + 1)
    };
  },
  /**
   * Sentence-level segmentation (punctuation followed by whitespace).
   */
  sentence: (text) => {
    const match = text.match(/[.!?]\s+/);
    if (match && match.index !== void 0) {
      return {
        accepted: text.slice(0, match.index + 1),
        remaining: text.slice(match.index + 1)
      };
    }
    return { accepted: text, remaining: "" };
  },
  /**
   * Paragraph-level segmentation (double newline).
   */
  paragraph: (text) => {
    const paragraphEnd = text.indexOf("\n\n");
    return paragraphEnd === -1 ? { accepted: text, remaining: "" } : {
      accepted: text.slice(0, paragraphEnd + 2),
      remaining: text.slice(paragraphEnd + 2)
    };
  },
  /**
   * Atomic acceptance â€“ consume the entire suggestion.
   */
  full: (text) => ({ accepted: text, remaining: "" })
};
var SuggestionUpdateEffect = import_state.StateEffect.define();
var suggestionSessionState = import_state.StateField.define({
  create: () => getResetSession(),
  update(session, transaction) {
    const effect = transaction.effects.find(
      (e) => e.is(SuggestionUpdateEffect)
    );
    if (effect)
      return updateSessionFromEffect(effect.value);
    if (transaction.docChanged && session.remainingText && session.anchorPosition !== null) {
      return updateSessionOnDocumentChange(session, transaction);
    }
    if (session.remainingText !== null && session.anchorPosition !== null) {
      return updateSessionOnCursorDrift(session, transaction);
    }
    return session;
  }
});
function getResetSession() {
  return {
    fullText: null,
    remainingText: null,
    baselineDocument: null,
    anchorPosition: null
  };
}
function updateSessionFromEffect(effect) {
  return effect.content === null ? getResetSession() : initializeSession(effect);
}
function initializeSession(effect) {
  return {
    fullText: effect.content,
    remainingText: effect.content,
    baselineDocument: effect.document,
    anchorPosition: effect.anchor
  };
}
function updateSessionOnDocumentChange(session, transaction) {
  let insertedContent = "";
  let insertionAtAnchor = false;
  transaction.changes.iterChanges((fromA, toA, _fromB, _toB, inserted) => {
    if (fromA === session.anchorPosition && toA === fromA) {
      insertedContent = inserted.toString();
      insertionAtAnchor = true;
    }
  });
  if (!insertionAtAnchor || !session.remainingText) {
    return invalidateSession(session);
  }
  if (session.remainingText.startsWith(insertedContent)) {
    return advanceSession(session, insertedContent.length);
  }
  return invalidateSession(session);
}
function advanceSession(session, consumedLength) {
  return {
    ...session,
    remainingText: session.remainingText.slice(consumedLength).length > 0 ? session.remainingText.slice(consumedLength) : null,
    anchorPosition: session.anchorPosition + consumedLength
  };
}
function invalidateSession(session) {
  return {
    ...session,
    remainingText: null,
    anchorPosition: null
  };
}
function updateSessionOnCursorDrift(session, transaction) {
  return transaction.state.selection.main.head !== session.anchorPosition ? invalidateSession(session) : session;
}
var _SuggestionWidget = class extends import_view.WidgetType {
  constructor(content) {
    super();
    this.content = content;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = _SuggestionWidget.CSS_CLASS;
    span.style.opacity = _SuggestionWidget.OPACITY.toString();
    span.textContent = this.content;
    return span;
  }
};
var SuggestionWidget = _SuggestionWidget;
SuggestionWidget.OPACITY = 0.4;
SuggestionWidget.CSS_CLASS = "cm-inline-prediction";
var suggestionRenderer = import_view.ViewPlugin.fromClass(
  class {
    constructor() {
      this.decorations = import_view.Decoration.none;
    }
    update(update) {
      const session = update.state.field(suggestionSessionState);
      this.decorations = session.remainingText ? this.createDecoration(update.view, session.remainingText) : import_view.Decoration.none;
    }
    createDecoration(view, suggestionText) {
      const cursorPosition = view.state.selection.main.head;
      return import_view.Decoration.set([
        import_view.Decoration.widget({
          widget: new SuggestionWidget(suggestionText),
          side: 1
        }).range(cursorPosition)
      ]);
    }
  },
  { decorations: (v) => v.decorations }
);
var createDebouncedFetcher = (fetch3, getDelay) => {
  let activeRequest = true;
  let timeoutId;
  const throttledFetch = async function* (state) {
    clearTimeout(timeoutId);
    activeRequest = true;
    await new Promise((resolve2) => {
      timeoutId = setTimeout(resolve2, getDelay());
    });
    if (activeRequest)
      yield* fetch3(state);
  };
  const fetcherPlugin = import_view.ViewPlugin.fromClass(
    class {
      constructor() {
        this.currentRequestId = 0;
      }
      async update(update) {
        const state = update.state;
        if (!update.docChanged || state.field(suggestionSessionState).remainingText)
          return;
        const requestId = ++this.currentRequestId;
        for await (const suggestion of throttledFetch(state)) {
          if (requestId !== this.currentRequestId)
            return;
          update.view.dispatch({
            effects: SuggestionUpdateEffect.of({
              content: suggestion.text,
              document: state.doc,
              anchor: state.selection.main.head
            })
          });
        }
      }
    }
  );
  return {
    fetcherPlugin,
    terminate: () => {
      activeRequest = false;
      clearTimeout(timeoutId);
    }
  };
};
var createAcceptanceHandler = (terminateFetch, hotkey, getOptions) => import_state.Prec.highest(
  import_view.keymap.of([
    {
      key: hotkey,
      run: (view) => {
        var _a;
        const session = view.state.field(suggestionSessionState);
        if (!session.remainingText)
          return false;
        const dynamicOptions = getOptions();
        const segmentationKey = (_a = dynamicOptions.splitStrategy) != null ? _a : "word";
        const { accepted, remaining } = TextSplitStrategies[segmentationKey](session.remainingText);
        if (!accepted)
          return false;
        view.dispatch({
          ...insertCompletion(view.state, accepted),
          effects: SuggestionUpdateEffect.of({
            content: remaining || null,
            document: remaining ? session.baselineDocument : null,
            anchor: remaining ? session.anchorPosition + accepted.length : null
          })
        });
        if (!remaining)
          terminateFetch();
        return true;
      }
    }
  ])
);
var insertCompletion = (state, text) => {
  const cursorPos = state.selection.main.head;
  return {
    ...state.changeByRange(() => ({
      changes: { from: cursorPos, insert: text },
      range: import_state.EditorSelection.cursor(cursorPos + text.length)
    })),
    userEvent: "completion.accept"
  };
};
function inlineSuggestions(config) {
  const { fetchFunc, getOptions } = config;
  const staticHotkey = config.acceptanceHotkey || "Tab";
  const normalizeFetch = async function* (state) {
    const result = await fetchFunc(state);
    if (Symbol.asyncIterator in result) {
      yield* result;
    } else {
      yield result;
    }
  };
  const getDelay = () => {
    var _a;
    return (_a = getOptions().delayMs) != null ? _a : 300;
  };
  const { fetcherPlugin, terminate } = createDebouncedFetcher(normalizeFetch, getDelay);
  const acceptanceHandler = createAcceptanceHandler(terminate, staticHotkey, getOptions);
  return [
    suggestionSessionState,
    fetcherPlugin,
    suggestionRenderer,
    acceptanceHandler
  ];
}

// src/providers/openai/provider.ts
var OpenAIProvider = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateModels() {
    return ["gpt-4", "davinci"];
  }
};

// node_modules/ollama/dist/index.mjs
var import_fs = __toESM(require("fs"), 1);
var import_path = require("path");

// node_modules/whatwg-fetch/fetch.js
var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g,
  iterable: "Symbol" in g && "iterator" in Symbol,
  blob: "FileReader" in g && "Blob" in g && function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: "FormData" in g,
  arrayBuffer: "ArrayBuffer" in g
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve2, reject) {
    reader.onload = function() {
      resolve2(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};
Response.error = function() {
  var response = new Response(null, { status: 200, statusText: "" });
  response.ok = false;
  response.status = 0;
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response(null, { status, headers: { location: url } });
};
var DOMException = g.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch2(input, init) {
  return new Promise(function(resolve2, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve2(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch2.polyfill = true;
if (!g.fetch) {
  g.fetch = fetch2;
  g.Headers = Headers;
  g.Request = Request;
  g.Response = Response;
}

// node_modules/ollama/dist/browser.mjs
var version = "0.5.12";
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ResponseError = class extends Error {
  constructor(error, status_code) {
    super(error);
    this.error = error;
    this.status_code = status_code;
    this.name = "ResponseError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ResponseError);
    }
  }
};
var AbortableAsyncIterator = class {
  constructor(abortController, itr, doneCallback) {
    __publicField$1(this, "abortController");
    __publicField$1(this, "itr");
    __publicField$1(this, "doneCallback");
    this.abortController = abortController;
    this.itr = itr;
    this.doneCallback = doneCallback;
  }
  abort() {
    this.abortController.abort();
  }
  async *[Symbol.asyncIterator]() {
    for await (const message of this.itr) {
      if ("error" in message) {
        throw new Error(message.error);
      }
      yield message;
      if (message.done || message.status === "success") {
        this.doneCallback();
        return;
      }
    }
    throw new Error("Did not receive done or success response in stream.");
  }
};
var checkOk = async (response) => {
  var _a;
  if (response.ok) {
    return;
  }
  let message = `Error ${response.status}: ${response.statusText}`;
  let errorData = null;
  if ((_a = response.headers.get("content-type")) == null ? void 0 : _a.includes("application/json")) {
    try {
      errorData = await response.json();
      message = errorData.error || message;
    } catch (error) {
      console.log("Failed to parse error response as JSON");
    }
  } else {
    try {
      console.log("Getting text from response");
      const textResponse = await response.text();
      message = textResponse || message;
    } catch (error) {
      console.log("Failed to get text from error response");
    }
  }
  throw new ResponseError(message, response.status);
};
function getPlatform() {
  if (typeof window !== "undefined" && window.navigator) {
    return `${window.navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;
  } else if (typeof process !== "undefined") {
    return `${process.arch} ${process.platform} Node.js/${process.version}`;
  }
  return "";
}
var fetchWithHeaders = async (fetch3, url, options = {}) => {
  const defaultHeaders = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "User-Agent": `ollama-js/${version} (${getPlatform()})`
  };
  if (!options.headers) {
    options.headers = {};
  }
  const customHeaders = Object.fromEntries(
    Object.entries(options.headers).filter(([key]) => !Object.keys(defaultHeaders).some((defaultKey) => defaultKey.toLowerCase() === key.toLowerCase()))
  );
  options.headers = {
    ...defaultHeaders,
    ...customHeaders
  };
  return fetch3(url, options);
};
var get = async (fetch3, host, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var post = async (fetch3, host, data, options) => {
  const isRecord = (input) => {
    return input !== null && typeof input === "object" && !Array.isArray(input);
  };
  const formattedData = isRecord(data) ? JSON.stringify(data) : data;
  const response = await fetchWithHeaders(fetch3, host, {
    method: "POST",
    body: formattedData,
    signal: options == null ? void 0 : options.signal,
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var del = async (fetch3, host, data, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    method: "DELETE",
    body: JSON.stringify(data),
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var parseJSON = async function* (itr) {
  var _a;
  const decoder = new TextDecoder("utf-8");
  let buffer = "";
  const reader = itr.getReader();
  while (true) {
    const { done, value: chunk } = await reader.read();
    if (done) {
      break;
    }
    buffer += decoder.decode(chunk);
    const parts = buffer.split("\n");
    buffer = (_a = parts.pop()) != null ? _a : "";
    for (const part of parts) {
      try {
        yield JSON.parse(part);
      } catch (error) {
        console.warn("invalid json: ", part);
      }
    }
  }
  for (const part of buffer.split("\n").filter((p) => p !== "")) {
    try {
      yield JSON.parse(part);
    } catch (error) {
      console.warn("invalid json: ", part);
    }
  }
};
var formatHost = (host) => {
  if (!host) {
    return "http://127.0.0.1:11434";
  }
  let isExplicitProtocol = host.includes("://");
  if (host.startsWith(":")) {
    host = `http://127.0.0.1${host}`;
    isExplicitProtocol = true;
  }
  if (!isExplicitProtocol) {
    host = `http://${host}`;
  }
  const url = new URL(host);
  let port = url.port;
  if (!port) {
    if (!isExplicitProtocol) {
      port = "11434";
    } else {
      port = url.protocol === "https:" ? "443" : "80";
    }
  }
  let formattedHost = `${url.protocol}//${url.hostname}:${port}${url.pathname}`;
  if (formattedHost.endsWith("/")) {
    formattedHost = formattedHost.slice(0, -1);
  }
  return formattedHost;
};
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var Ollama$1 = class Ollama {
  constructor(config) {
    var _a, _b;
    __publicField(this, "config");
    __publicField(this, "fetch");
    __publicField(this, "ongoingStreamedRequests", []);
    this.config = {
      host: "",
      headers: config == null ? void 0 : config.headers
    };
    if (!(config == null ? void 0 : config.proxy)) {
      this.config.host = formatHost((_a = config == null ? void 0 : config.host) != null ? _a : "http://127.0.0.1:11434");
    }
    this.fetch = (_b = config == null ? void 0 : config.fetch) != null ? _b : fetch;
  }
  // Abort any ongoing streamed requests to Ollama
  abort() {
    for (const request of this.ongoingStreamedRequests) {
      request.abort();
    }
    this.ongoingStreamedRequests.length = 0;
  }
  /**
   * Processes a request to the Ollama server. If the request is streamable, it will return a
   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
   * object.
   * @param endpoint {string} - The endpoint to send the request to.
   * @param request {object} - The request object to send to the endpoint.
   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
   * response messages.
   * @throws {Error} - If the response body is missing or if the response is an error.
   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
   */
  async processStreamableRequest(endpoint, request) {
    var _a;
    request.stream = (_a = request.stream) != null ? _a : false;
    const host = `${this.config.host}/api/${endpoint}`;
    if (request.stream) {
      const abortController = new AbortController();
      const response2 = await post(this.fetch, host, request, {
        signal: abortController.signal,
        headers: this.config.headers
      });
      if (!response2.body) {
        throw new Error("Missing body");
      }
      const itr = parseJSON(response2.body);
      const abortableAsyncIterator = new AbortableAsyncIterator(
        abortController,
        itr,
        () => {
          const i = this.ongoingStreamedRequests.indexOf(abortableAsyncIterator);
          if (i > -1) {
            this.ongoingStreamedRequests.splice(i, 1);
          }
        }
      );
      this.ongoingStreamedRequests.push(abortableAsyncIterator);
      return abortableAsyncIterator;
    }
    const response = await post(this.fetch, host, request, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Encodes an image to base64 if it is a Uint8Array.
   * @param image {Uint8Array | string} - The image to encode.
   * @returns {Promise<string>} - The base64 encoded image.
   */
  async encodeImage(image) {
    if (typeof image !== "string") {
      const uint8Array = new Uint8Array(image);
      let byteString = "";
      const len = uint8Array.byteLength;
      for (let i = 0; i < len; i++) {
        byteString += String.fromCharCode(uint8Array[i]);
      }
      return btoa(byteString);
    }
    return image;
  }
  /**
   * Generates a response from a text prompt.
   * @param request {GenerateRequest} - The request object.
   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async generate(request) {
    if (request.images) {
      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));
    }
    return this.processStreamableRequest("generate", request);
  }
  /**
   * Chats with the model. The request object can contain messages with images that are either
   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
   * request.
   * @param request {ChatRequest} - The request object.
   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
   * AbortableAsyncIterator that yields response messages.
   */
  async chat(request) {
    if (request.messages) {
      for (const message of request.messages) {
        if (message.images) {
          message.images = await Promise.all(
            message.images.map(this.encodeImage.bind(this))
          );
        }
      }
    }
    return this.processStreamableRequest("chat", request);
  }
  /**
   * Creates a new model from a stream of data.
   * @param request {CreateRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
   */
  async create(request) {
    return this.processStreamableRequest("create", {
      ...request
    });
  }
  /**
   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PullRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async pull(request) {
    return this.processStreamableRequest("pull", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PushRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async push(request) {
    return this.processStreamableRequest("push", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Deletes a model from the server. The request object should contain the name of the model to
   * delete.
   * @param request {DeleteRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async delete(request) {
    await del(
      this.fetch,
      `${this.config.host}/api/delete`,
      { name: request.model },
      { headers: this.config.headers }
    );
    return { status: "success" };
  }
  /**
   * Copies a model from one name to another. The request object should contain the name of the
   * model to copy and the new name.
   * @param request {CopyRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async copy(request) {
    await post(this.fetch, `${this.config.host}/api/copy`, { ...request }, {
      headers: this.config.headers
    });
    return { status: "success" };
  }
  /**
   * Lists the models on the server.
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async list() {
    const response = await get(this.fetch, `${this.config.host}/api/tags`, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Shows the metadata of a model. The request object should contain the name of the model.
   * @param request {ShowRequest} - The request object.
   * @returns {Promise<ShowResponse>} - The response object.
   */
  async show(request) {
    const response = await post(this.fetch, `${this.config.host}/api/show`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds text input into vectors.
   * @param request {EmbedRequest} - The request object.
   * @returns {Promise<EmbedResponse>} - The response object.
   */
  async embed(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embed`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds a text prompt into a vector.
   * @param request {EmbeddingsRequest} - The request object.
   * @returns {Promise<EmbeddingsResponse>} - The response object.
   */
  async embeddings(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Lists the running models on the server
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async ps() {
    const response = await get(this.fetch, `${this.config.host}/api/ps`, {
      headers: this.config.headers
    });
    return await response.json();
  }
};
var browser = new Ollama$1();

// node_modules/ollama/dist/index.mjs
var Ollama2 = class extends Ollama$1 {
  async encodeImage(image) {
    if (typeof image !== "string") {
      return Buffer.from(image).toString("base64");
    }
    try {
      if (import_fs.default.existsSync(image)) {
        const fileBuffer = await import_fs.promises.readFile((0, import_path.resolve)(image));
        return Buffer.from(fileBuffer).toString("base64");
      }
    } catch (e) {
    }
    return image;
  }
  /**
   * checks if a file exists
   * @param path {string} - The path to the file
   * @private @internal
   * @returns {Promise<boolean>} - Whether the file exists or not
   */
  async fileExists(path) {
    try {
      await import_fs.promises.access(path);
      return true;
    } catch (e) {
      return false;
    }
  }
  async create(request) {
    if (request.from && await this.fileExists((0, import_path.resolve)(request.from))) {
      throw Error("Creating with a local path is not currently supported from ollama-js");
    }
    if (request.stream) {
      return super.create(request);
    } else {
      return super.create(request);
    }
  }
};
var index = new Ollama2();

// node_modules/mustache/mustache.mjs
var objectToString = Object.prototype.toString;
var isArray = Array.isArray || function isArrayPolyfill(object) {
  return objectToString.call(object) === "[object Array]";
};
function isFunction(object) {
  return typeof object === "function";
}
function typeStr(obj) {
  return isArray(obj) ? "array" : typeof obj;
}
function escapeRegExp(string) {
  return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function hasProperty(obj, propName) {
  return obj != null && typeof obj === "object" && propName in obj;
}
function primitiveHasOwnProperty(primitive, propName) {
  return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
}
var regExpTest = RegExp.prototype.test;
function testRegExp(re, string) {
  return regExpTest.call(re, string);
}
var nonSpaceRe = /\S/;
function isWhitespace(string) {
  return !testRegExp(nonSpaceRe, string);
}
var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(string) {
  return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
    return entityMap[s];
  });
}
var whiteRe = /\s*/;
var spaceRe = /\s+/;
var equalsRe = /\s*=/;
var curlyRe = /\s*\}/;
var tagRe = /#|\^|\/|>|\{|&|=|!/;
function parseTemplate(template, tags) {
  if (!template)
    return [];
  var lineHasNonSpace = false;
  var sections = [];
  var tokens = [];
  var spaces = [];
  var hasTag = false;
  var nonSpace = false;
  var indentation = "";
  var tagIndex = 0;
  function stripSpace() {
    if (hasTag && !nonSpace) {
      while (spaces.length)
        delete tokens[spaces.pop()];
    } else {
      spaces = [];
    }
    hasTag = false;
    nonSpace = false;
  }
  var openingTagRe, closingTagRe, closingCurlyRe;
  function compileTags(tagsToCompile) {
    if (typeof tagsToCompile === "string")
      tagsToCompile = tagsToCompile.split(spaceRe, 2);
    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
      throw new Error("Invalid tags: " + tagsToCompile);
    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
    closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
    closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
  }
  compileTags(tags || mustache.tags);
  var scanner = new Scanner(template);
  var start, type, value, chr, token, openSection;
  while (!scanner.eos()) {
    start = scanner.pos;
    value = scanner.scanUntil(openingTagRe);
    if (value) {
      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
        chr = value.charAt(i);
        if (isWhitespace(chr)) {
          spaces.push(tokens.length);
          indentation += chr;
        } else {
          nonSpace = true;
          lineHasNonSpace = true;
          indentation += " ";
        }
        tokens.push(["text", chr, start, start + 1]);
        start += 1;
        if (chr === "\n") {
          stripSpace();
          indentation = "";
          tagIndex = 0;
          lineHasNonSpace = false;
        }
      }
    }
    if (!scanner.scan(openingTagRe))
      break;
    hasTag = true;
    type = scanner.scan(tagRe) || "name";
    scanner.scan(whiteRe);
    if (type === "=") {
      value = scanner.scanUntil(equalsRe);
      scanner.scan(equalsRe);
      scanner.scanUntil(closingTagRe);
    } else if (type === "{") {
      value = scanner.scanUntil(closingCurlyRe);
      scanner.scan(curlyRe);
      scanner.scanUntil(closingTagRe);
      type = "&";
    } else {
      value = scanner.scanUntil(closingTagRe);
    }
    if (!scanner.scan(closingTagRe))
      throw new Error("Unclosed tag at " + scanner.pos);
    if (type == ">") {
      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
    } else {
      token = [type, value, start, scanner.pos];
    }
    tagIndex++;
    tokens.push(token);
    if (type === "#" || type === "^") {
      sections.push(token);
    } else if (type === "/") {
      openSection = sections.pop();
      if (!openSection)
        throw new Error('Unopened section "' + value + '" at ' + start);
      if (openSection[1] !== value)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
    } else if (type === "name" || type === "{" || type === "&") {
      nonSpace = true;
    } else if (type === "=") {
      compileTags(value);
    }
  }
  stripSpace();
  openSection = sections.pop();
  if (openSection)
    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
  return nestTokens(squashTokens(tokens));
}
function squashTokens(tokens) {
  var squashedTokens = [];
  var token, lastToken;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    if (token) {
      if (token[0] === "text" && lastToken && lastToken[0] === "text") {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        squashedTokens.push(token);
        lastToken = token;
      }
    }
  }
  return squashedTokens;
}
function nestTokens(tokens) {
  var nestedTokens = [];
  var collector = nestedTokens;
  var sections = [];
  var token, section;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    switch (token[0]) {
      case "#":
      case "^":
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case "/":
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
    }
  }
  return nestedTokens;
}
function Scanner(string) {
  this.string = string;
  this.tail = string;
  this.pos = 0;
}
Scanner.prototype.eos = function eos() {
  return this.tail === "";
};
Scanner.prototype.scan = function scan(re) {
  var match = this.tail.match(re);
  if (!match || match.index !== 0)
    return "";
  var string = match[0];
  this.tail = this.tail.substring(string.length);
  this.pos += string.length;
  return string;
};
Scanner.prototype.scanUntil = function scanUntil(re) {
  var index2 = this.tail.search(re), match;
  switch (index2) {
    case -1:
      match = this.tail;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, index2);
      this.tail = this.tail.substring(index2);
  }
  this.pos += match.length;
  return match;
};
function Context(view, parentContext) {
  this.view = view;
  this.cache = { ".": this.view };
  this.parent = parentContext;
}
Context.prototype.push = function push(view) {
  return new Context(view, this);
};
Context.prototype.lookup = function lookup(name) {
  var cache = this.cache;
  var value;
  if (cache.hasOwnProperty(name)) {
    value = cache[name];
  } else {
    var context = this, intermediateValue, names, index2, lookupHit = false;
    while (context) {
      if (name.indexOf(".") > 0) {
        intermediateValue = context.view;
        names = name.split(".");
        index2 = 0;
        while (intermediateValue != null && index2 < names.length) {
          if (index2 === names.length - 1)
            lookupHit = hasProperty(intermediateValue, names[index2]) || primitiveHasOwnProperty(intermediateValue, names[index2]);
          intermediateValue = intermediateValue[names[index2++]];
        }
      } else {
        intermediateValue = context.view[name];
        lookupHit = hasProperty(context.view, name);
      }
      if (lookupHit) {
        value = intermediateValue;
        break;
      }
      context = context.parent;
    }
    cache[name] = value;
  }
  if (isFunction(value))
    value = value.call(this.view);
  return value;
};
function Writer() {
  this.templateCache = {
    _cache: {},
    set: function set(key, value) {
      this._cache[key] = value;
    },
    get: function get2(key) {
      return this._cache[key];
    },
    clear: function clear() {
      this._cache = {};
    }
  };
}
Writer.prototype.clearCache = function clearCache() {
  if (typeof this.templateCache !== "undefined") {
    this.templateCache.clear();
  }
};
Writer.prototype.parse = function parse(template, tags) {
  var cache = this.templateCache;
  var cacheKey = template + ":" + (tags || mustache.tags).join(":");
  var isCacheEnabled = typeof cache !== "undefined";
  var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
  if (tokens == void 0) {
    tokens = parseTemplate(template, tags);
    isCacheEnabled && cache.set(cacheKey, tokens);
  }
  return tokens;
};
Writer.prototype.render = function render(template, view, partials, config) {
  var tags = this.getConfigTags(config);
  var tokens = this.parse(template, tags);
  var context = view instanceof Context ? view : new Context(view, void 0);
  return this.renderTokens(tokens, context, partials, template, config);
};
Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
  var buffer = "";
  var token, symbol, value;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    value = void 0;
    token = tokens[i];
    symbol = token[0];
    if (symbol === "#")
      value = this.renderSection(token, context, partials, originalTemplate, config);
    else if (symbol === "^")
      value = this.renderInverted(token, context, partials, originalTemplate, config);
    else if (symbol === ">")
      value = this.renderPartial(token, context, partials, config);
    else if (symbol === "&")
      value = this.unescapedValue(token, context);
    else if (symbol === "name")
      value = this.escapedValue(token, context, config);
    else if (symbol === "text")
      value = this.rawValue(token);
    if (value !== void 0)
      buffer += value;
  }
  return buffer;
};
Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
  var self2 = this;
  var buffer = "";
  var value = context.lookup(token[1]);
  function subRender(template) {
    return self2.render(template, context, partials, config);
  }
  if (!value)
    return;
  if (isArray(value)) {
    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
    }
  } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
  } else if (isFunction(value)) {
    if (typeof originalTemplate !== "string")
      throw new Error("Cannot use higher-order sections without the original template");
    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
    if (value != null)
      buffer += value;
  } else {
    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
  }
  return buffer;
};
Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
  var value = context.lookup(token[1]);
  if (!value || isArray(value) && value.length === 0)
    return this.renderTokens(token[4], context, partials, originalTemplate, config);
};
Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
  var filteredIndentation = indentation.replace(/[^ \t]/g, "");
  var partialByNl = partial.split("\n");
  for (var i = 0; i < partialByNl.length; i++) {
    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
      partialByNl[i] = filteredIndentation + partialByNl[i];
    }
  }
  return partialByNl.join("\n");
};
Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
  if (!partials)
    return;
  var tags = this.getConfigTags(config);
  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
  if (value != null) {
    var lineHasNonSpace = token[6];
    var tagIndex = token[5];
    var indentation = token[4];
    var indentedValue = value;
    if (tagIndex == 0 && indentation) {
      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
    }
    var tokens = this.parse(indentedValue, tags);
    return this.renderTokens(tokens, context, partials, indentedValue, config);
  }
};
Writer.prototype.unescapedValue = function unescapedValue(token, context) {
  var value = context.lookup(token[1]);
  if (value != null)
    return value;
};
Writer.prototype.escapedValue = function escapedValue(token, context, config) {
  var escape = this.getConfigEscape(config) || mustache.escape;
  var value = context.lookup(token[1]);
  if (value != null)
    return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
};
Writer.prototype.rawValue = function rawValue(token) {
  return token[1];
};
Writer.prototype.getConfigTags = function getConfigTags(config) {
  if (isArray(config)) {
    return config;
  } else if (config && typeof config === "object") {
    return config.tags;
  } else {
    return void 0;
  }
};
Writer.prototype.getConfigEscape = function getConfigEscape(config) {
  if (config && typeof config === "object" && !isArray(config)) {
    return config.escape;
  } else {
    return void 0;
  }
};
var mustache = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  /**
   * Allows a user to override the default caching strategy, by providing an
   * object with set, get and clear methods. This can also be used to disable
   * the cache by setting it to the literal `undefined`.
   */
  set templateCache(cache) {
    defaultWriter.templateCache = cache;
  },
  /**
   * Gets the default or overridden caching object from the default writer.
   */
  get templateCache() {
    return defaultWriter.templateCache;
  }
};
var defaultWriter = new Writer();
mustache.clearCache = function clearCache2() {
  return defaultWriter.clearCache();
};
mustache.parse = function parse2(template, tags) {
  return defaultWriter.parse(template, tags);
};
mustache.render = function render2(template, view, partials, config) {
  if (typeof template !== "string") {
    throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
  }
  return defaultWriter.render(template, view, partials, config);
};
mustache.escape = escapeHtml;
mustache.Scanner = Scanner;
mustache.Context = Context;
mustache.Writer = Writer;
var mustache_default = mustache;

// src/prompt/prompt.ts
var TEMPLATE_VARIABLES = `{{pre_cursor}}
{{post_cursor}} 
{{active_sentence}} 
{{last_line}}`;
function buildPrompt(template, args) {
  return mustache_default.render(template, args);
}
function preparePrompt(editor, template = TEMPLATE_VARIABLES) {
  const cursor = editor.getCursor();
  const preCursor = editor.getRange({ line: 0, ch: 0 }, cursor);
  const postCursor = editor.getRange(cursor, { line: editor.lastLine(), ch: editor.getLine(editor.lastLine()).length });
  const activeSentence = sentenceAtCursor(editor);
  const lastLine = editor.getLine(editor.lastLine());
  return buildPrompt(template, {
    pre_cursor: preCursor,
    post_cursor: postCursor,
    active_sentence: activeSentence,
    last_line: lastLine
  });
}
function sentenceAtCursor(editor) {
  const cursor = editor.getCursor();
  let currentLine = cursor.line;
  let sentenceLines = [editor.getLine(currentLine)];
  while (currentLine > 0) {
    currentLine--;
    const line = editor.getLine(currentLine);
    if (/[.!?]\s*$/.test(line)) {
      break;
    }
    sentenceLines.unshift(line);
  }
  return sentenceLines.join(" ").replace(/\s+/g, " ").trim();
}

// src/providers/ollama/provider.ts
var OllamaProvider = class {
  constructor(settins) {
    this.aborted = false;
    this.settings = settins;
    this.client = new Ollama2({ host: this.settings.host });
  }
  async *generate(editor, options) {
    this.aborted = false;
    const prompt = preparePrompt(editor, options.userPrompt);
    const completionIterator = await this.client.generate({
      model: options.model,
      prompt,
      system: options.systemPrompt,
      stream: true,
      options: {
        temperature: options.temperature
      }
    });
    const initialPosition = editor.getCursor();
    let completion = "";
    for await (let response of completionIterator) {
      if (this.aborted) {
        return;
      }
      const currentPosition = editor.getCursor();
      if (currentPosition.line !== initialPosition.line || currentPosition.ch !== initialPosition.ch) {
        console.log("cursor moved, aborting completion");
        this.abort();
        return;
      }
      completion += response.response;
      yield completion;
    }
  }
  async abort() {
    if (this.aborted)
      return;
    this.client.abort();
    this.aborted = true;
    console.log("aborted completion");
  }
  async updateModels() {
    const response = await this.client.list();
    this.settings.models = response.models.map((model) => model.name);
    return this.settings.models;
  }
};

// src/providers/index.ts
var buildProviders = (settings) => {
  return {
    ["ollama" /* OLLAMA */]: new OllamaProvider(settings.providers.ollama),
    ["openai" /* OPENAI */]: new OpenAIProvider(settings.providers.openai)
  };
};

// src/settings/settings.ts
var DEFAULT_PROFILE = "default";
var DEFAULT_SETTINGS = {
  providers: {
    openai: {
      integration: "openai" /* OPENAI */,
      name: "Open AI",
      description: "Use OpenAI APIs to generate text.",
      apiKey: "",
      model: "gpt-4o",
      models: ["gpt-4", "gpt-3.5-turbo", "gpt-3.5", "gpt-3", "gpt-2", "gpt-1"],
      configured: false
    },
    ollama: {
      integration: "ollama" /* OLLAMA */,
      name: "Ollama",
      description: "Use your own Ollama instance to generate text.",
      host: "http://localhost:11434",
      models: ["llama3.2:latest", "mistral-nemo"],
      configured: true
    }
  },
  profiles: {
    default: {
      name: "Default Profile",
      provider: "ollama" /* OLLAMA */,
      delayMs: 500,
      splitStrategy: "word",
      completionOptions: {
        model: "mistral-nemo",
        userPrompt: "Complete following text:\n {{pre_cursor}}}",
        systemPrompt: "You are an helpful AI completer. Follow instructions",
        temperature: 0.5
      }
    }
  },
  path_profile_mappings: {
    "/": DEFAULT_PROFILE
  }
};
function newProfile(profiles) {
  const id = Math.random().toString(36).substring(2, 6);
  let name = "New Profile";
  let i = 1;
  Object.entries(profiles).forEach(([, value]) => {
    if (value.name === name) {
      name = `New Profile ${i}`;
      i++;
    }
  });
  const defaultProfile = profiles[DEFAULT_PROFILE];
  const profile = {
    ...defaultProfile,
    name
  };
  profiles[id] = profile;
  return id;
}

// src/settings/settings-tab.ts
var import_obsidian2 = require("obsidian");

// src/settings/provider-modal.ts
var import_obsidian = require("obsidian");
var ProviderSettingsModal = class extends import_obsidian.Modal {
  constructor(app, plugin, providerType, onSave) {
    super(app);
    this.plugin = plugin;
    this.providerType = providerType;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    this.modalEl.addClass("inscribe-provider-modal");
    this.modalEl.style.width = "60vw";
    this.modalEl.style.height = "auto";
    const container = contentEl.createDiv({ cls: "inscribe-modal-container" });
    const provider = this.providerType === "ollama" /* OLLAMA */ ? this.plugin.settings.providers.ollama : this.plugin.settings.providers.openai;
    const header = container.createDiv({ cls: "inscribe-modal-header" });
    header.createEl("h2", {
      text: `Configure ${provider.name}`,
      cls: "inscribe-modal-title"
    });
    const content = container.createDiv({ cls: "inscribe-modal-content" });
    if (this.providerType === "ollama" /* OLLAMA */) {
      const ollamaProvider = this.plugin.settings.providers.ollama;
      new import_obsidian.Setting(content).setClass("inscribe-modal-setting").setName("Host").setDesc("Your Ollama instance URL").addText((text) => {
        text.setPlaceholder("http://localhost:11434").setValue(ollamaProvider.host).onChange(async (value) => {
          ollamaProvider.host = value;
          await this.plugin.saveSettings();
        });
        text.inputEl.addClass("inscribe-modal-input");
      });
    } else {
      const openaiProvider = this.plugin.settings.providers.openai;
      new import_obsidian.Setting(content).setClass("inscribe-modal-setting").setName("API Key").setDesc("Your OpenAI API key").addText((text) => {
        text.setPlaceholder("sk-...").setValue(openaiProvider.apiKey).onChange(async (value) => {
          openaiProvider.apiKey = value;
          await this.plugin.saveSettings();
        });
        text.inputEl.addClass("inscribe-modal-input");
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    const style = document.getElementById("inscribe-modal-styles");
    if (style) {
      style.remove();
    }
    contentEl.empty();
    this.onSave();
  }
};

// src/settings/settings-tab.ts
var InscribeSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    this.containerEl.empty();
    const providersContainer = document.createElement("div");
    this.containerEl.appendChild(providersContainer);
    this.providersSection = new ProvidersSection(providersContainer, this.app, this.plugin);
    await this.providersSection.render();
    const profilesContainer = document.createElement("div");
    this.containerEl.appendChild(profilesContainer);
    this.profilesSection = new ProfilesSection(profilesContainer, this.plugin);
    await this.profilesSection.render();
    const pathMappingsContainer = document.createElement("div");
    this.containerEl.appendChild(pathMappingsContainer);
    this.pathMappingsSection = new PathMappingsSection(pathMappingsContainer, this.plugin);
    await this.pathMappingsSection.render();
  }
};
var ProvidersSection = class {
  constructor(container, app, plugin) {
    this.container = container;
    this.plugin = plugin;
  }
  async render() {
    this.container.empty();
    this.container.createEl("h3", { text: "Providers" });
    this.container.createEl("p", {
      text: "Configure the AI providers you want to use for completions"
    });
    new import_obsidian2.Setting(this.container).setName("Ollama").setDesc("Local AI provider running on your machine").addButton((button) => {
      button.setButtonText("Configure").setTooltip("Configure Ollama").onClick(() => this.openProviderModal("ollama" /* OLLAMA */));
    });
    new import_obsidian2.Setting(this.container).setName("OpenAI").setDesc("OpenAI API provider").addButton((button) => {
      button.setButtonText("Configure").setTooltip("Configure OpenAI").onClick(() => this.openProviderModal("openai" /* OPENAI */));
    });
  }
  openProviderModal(type) {
    new ProviderSettingsModal(this.app, this.plugin, type, () => {
      this.render();
    }).open();
  }
};
var ProfilesSection = class {
  constructor(container, plugin) {
    this.displayedProfileId = DEFAULT_PROFILE;
    this.container = container;
    this.plugin = plugin;
    this.selectionContainer = document.createElement("div");
    this.profileContainer = document.createElement("div");
    this.container.appendChild(this.selectionContainer);
    this.container.appendChild(this.profileContainer);
  }
  async render() {
    this.container.empty();
    this.container.createEl("h3", { text: "Profiles" });
    this.container.createEl("p", {
      text: "Configure the settings for each profile. A profile can be assigned to paths. The default profile is used when no profile is assigned."
    });
    this.container.appendChild(this.selectionContainer);
    this.container.appendChild(this.profileContainer);
    await this.renderProfileSelection();
    const displayedProfile = this.plugin.settings.profiles[this.displayedProfileId];
    await this.renderProfileSettings(displayedProfile);
  }
  async renderProfileSelection() {
    this.selectionContainer.empty();
    this.selectionContainer.createEl("br");
    new import_obsidian2.Setting(this.selectionContainer).setHeading().setName("Manage profile").setDesc("Select a profile to configure its settings").addDropdown((dropdown) => this.createProfileDropdown(dropdown)).addExtraButton((button) => this.createNewProfileButton(button)).addExtraButton((button) => this.createDeleteProfileButton(button));
  }
  createProfileDropdown(dropdown) {
    Object.entries(this.plugin.settings.profiles).forEach(([id, profile]) => {
      dropdown.addOption(id, profile.name);
    });
    dropdown.setValue(this.displayedProfileId).onChange(async (value) => {
      this.displayedProfileId = value;
      await this.renderProfileSettings(this.plugin.settings.profiles[value]);
    });
  }
  createNewProfileButton(button) {
    button.setIcon("plus").setTooltip("Create new profile").onClick(async () => {
      this.displayedProfileId = newProfile(this.plugin.settings.profiles);
      await this.plugin.saveSettings();
      await this.render();
    });
  }
  createDeleteProfileButton(button) {
    const isDefault = this.displayedProfileId === DEFAULT_PROFILE;
    button.setDisabled(isDefault).setIcon("trash").setTooltip(isDefault ? "Cannot delete default profile" : "Delete profile").onClick(async () => {
      delete this.plugin.settings.profiles[this.displayedProfileId];
      this.displayedProfileId = DEFAULT_PROFILE;
      await this.plugin.saveSettings();
      await this.render();
    });
  }
  async renderProfileSettings(profile) {
    this.profileContainer.empty();
    new import_obsidian2.Setting(this.profileContainer).setName("Profile Name").setDesc("Name of the profile").addText((text) => {
      text.setValue(profile.name).onChange(async (value) => {
        profile.name = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(this.profileContainer).setName("AI Provider").setDesc("Choose your preferred AI provider").addDropdown((dropdown) => {
      dropdown.addOption("ollama" /* OLLAMA */, "Ollama").addOption("openai" /* OPENAI */, "OpenAI").setValue(profile.provider).onChange(async (value) => {
        profile.provider = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(this.profileContainer).setName("Model").setDesc("Select the model to use for completions").addExtraButton((button) => {
      button.setIcon("refresh-ccw").setTooltip("Update model list").onClick(async () => {
        this.plugin.providerManager.updateModels(profile.provider);
        await this.plugin.saveSettings();
        await this.renderProfileSettings(profile);
      });
    }).addDropdown(async (dropdown) => {
      const models = this.plugin.settings.providers[profile.provider].models;
      dropdown.addOptions(Object.fromEntries(models.map((model) => [model, model]))).setValue(profile.completionOptions.model).onChange(async (value) => {
        profile.completionOptions.model = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(this.profileContainer).setName("Temperature").setDesc("Control the randomness of completions (0 = deterministic, 1 = creative)").addSlider((slider) => {
      slider.setLimits(0, 1, 0.1).setValue(profile.completionOptions.temperature).setDynamicTooltip().onChange(async (value) => {
        profile.completionOptions.temperature = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(this.profileContainer).setName("Suggestion Delay").setDesc("Delay in milliseconds before fetching suggestions").addText((text) => {
      text.inputEl.setAttr("type", "number");
      text.setPlaceholder("1000").setValue(String(profile.delayMs)).onChange(async (value) => {
        profile.delayMs = parseInt(value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(this.profileContainer).setName("Completion Strategy").setDesc("Choose how completions should be split and accepted").addDropdown((dropdown) => {
      dropdown.addOption("word", "Word by Word").addOption("sentence", "Sentence by Sentence").addOption("paragraph", "Paragraph by Paragraph").addOption("full", "Full Completion").setValue(profile.splitStrategy).onChange(async (value) => {
        profile.splitStrategy = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(this.profileContainer).setName("System Prompt").setDesc("Set system prompt").addTextArea((text) => {
      text.inputEl.rows = 3;
      text.inputEl.setCssStyles({
        width: "100%",
        resize: "vertical",
        position: "relative"
      });
      text.setValue(profile.completionOptions.systemPrompt).onChange(
        async (value) => {
          profile.completionOptions.systemPrompt = value;
          await this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian2.Setting(this.profileContainer).setName("User Prompt").setDesc("User prompt template").addExtraButton((button) => {
      button.setIcon("list").setTooltip("Insert mustache template variables").onClick(async () => {
        const text = profile.completionOptions.userPrompt + "\n" + TEMPLATE_VARIABLES;
        profile.completionOptions.userPrompt = text;
        await this.plugin.saveSettings();
        await this.renderProfileSettings(profile);
      });
    }).addTextArea((text) => {
      text.inputEl.rows = 3;
      text.inputEl.setCssStyles({
        width: "100%",
        resize: "vertical",
        position: "relative"
      });
      text.setValue(profile.completionOptions.userPrompt).onChange(
        async (value) => {
          profile.completionOptions.userPrompt = value;
          await this.plugin.saveSettings();
        }
      );
    });
  }
};
var PathMappingsSection = class {
  constructor(container, plugin) {
    this.container = container;
    this.plugin = plugin;
    this.tableContainer = document.createElement("div");
  }
  async render() {
    this.container.empty();
    this.container.createEl("h3", { text: "Dynamic Profile Mapping" });
    this.container.createEl("p", {
      text: "You can assign profiles to paths. Paths are matched by prefix, with longer paths taking precedence. For example, '/Daily' will match all files in the Daily folder."
    });
    this.container.createEl("br");
    this.container.appendChild(this.tableContainer);
    await this.renderMappingsTable();
  }
  async renderMappingsTable() {
    this.tableContainer.empty();
    const table = this.tableContainer.createEl("table", { cls: "mapping-table" });
    const header = table.createEl("tr");
    header.createEl("th", { text: "Path" });
    header.createEl("th", { text: "Profile" });
    header.createEl("th", { text: "" });
    const newRow = table.createEl("tr", { cls: "new-mapping-row" });
    let pathInput = "";
    let selectedProfile = DEFAULT_PROFILE;
    const pathCell = newRow.createEl("td");
    const pathInputEl = pathCell.createEl("input", {
      type: "text",
      placeholder: "Enter path (e.g., Daily/Work)",
      cls: "path-input"
    });
    pathInputEl.addEventListener("input", (e) => {
      pathInput = e.target.value;
    });
    const profileCell = newRow.createEl("td");
    const profileDropdown = new import_obsidian2.DropdownComponent(profileCell).setValue(selectedProfile);
    Object.entries(this.plugin.settings.profiles).forEach(([id, profile]) => {
      profileDropdown.addOption(id, profile.name);
    });
    profileDropdown.onChange((value) => {
      selectedProfile = value;
    });
    const actionCell = newRow.createEl("td");
    const addButton = new import_obsidian2.ExtraButtonComponent(actionCell).setIcon("plus").setTooltip("Add profile mapping").onClick(async () => {
      this.plugin.settings.path_profile_mappings[pathInput] = selectedProfile;
      await this.plugin.saveSettings();
      await this.render();
    });
    Object.entries(this.plugin.settings.path_profile_mappings).forEach(([path, profileId]) => {
      const row = table.createEl("tr");
      row.createEl("td", { text: path || "Root" });
      const isDefaultMapping = path === "";
      const profileCell2 = row.createEl("td");
      const profileDropdown2 = new import_obsidian2.DropdownComponent(profileCell2).setDisabled(isDefaultMapping);
      Object.entries(this.plugin.settings.profiles).forEach(([id, profile]) => {
        profileDropdown2.addOption(id, profile.name);
      });
      profileDropdown2.setValue(profileId);
      profileDropdown2.onChange(async (value) => {
        this.plugin.settings.path_profile_mappings[path] = value;
        await this.plugin.saveSettings();
        await this.render();
      });
      const actionsCell = row.createEl("td");
      new import_obsidian2.ExtraButtonComponent(actionsCell).setIcon("trash").setDisabled(isDefaultMapping).setTooltip("Delete mapping").onClick(async () => {
        delete this.plugin.settings.path_profile_mappings[path];
        await this.plugin.saveSettings();
        await this.render();
      });
    });
  }
};

// src/providers/manager.ts
var ProviderManager = class {
  constructor(app, settings) {
    this.inlineSuggestionOptions = { delayMs: 300, splitStrategy: "sentence" };
    this.app = app;
    this.settings = settings;
    this.providers = buildProviders(settings);
  }
  async *fetchSuggestions() {
    var _a;
    const activeEditor = this.app.workspace.activeEditor;
    if (!activeEditor)
      return;
    if (!activeEditor.editor)
      return;
    const filePath = ((_a = activeEditor.file) == null ? void 0 : _a.path) || "";
    const [provider, profile] = this.resolveProfile(filePath);
    this.inlineSuggestionOptions = { delayMs: profile.delayMs, splitStrategy: profile.splitStrategy };
    yield* this.generateCompletion(activeEditor.editor, provider, profile.completionOptions);
  }
  getOptions() {
    return this.inlineSuggestionOptions;
  }
  loadProviders() {
    this.providers = buildProviders(this.settings);
  }
  async *generateCompletion(editor, provider, options) {
    await provider.abort();
    const cursor = editor.getCursor();
    const currentLine = editor.getLine(cursor.line);
    if (!currentLine.length)
      return;
    const lastChar = currentLine[cursor.ch - 1];
    if (lastChar !== " ")
      return;
    for await (const text of provider.generate(editor, options)) {
      yield { text };
    }
  }
  resolveProfile(filePath) {
    const profileName = this.resolveProfileFromPath(filePath);
    const profile = this.settings.profiles[profileName];
    const provider = this.providers[profile.provider];
    return [provider, profile];
  }
  resolveProfileFromPath(filePath) {
    if (!this.settings.path_profile_mappings || Object.keys(this.settings.path_profile_mappings).length === 0) {
      return DEFAULT_PROFILE;
    }
    const normalizedPath = filePath.replace(/^\/+|\/+$/g, "");
    let longestMatch = "";
    let matchedProfile = DEFAULT_PROFILE;
    Object.entries(this.settings.path_profile_mappings).forEach(([path, profile]) => {
      const normalizedMappingPath = path.replace(/^\/+|\/+$/g, "");
      if (normalizedPath.startsWith(normalizedMappingPath)) {
        if (normalizedMappingPath.length > longestMatch.length) {
          longestMatch = normalizedMappingPath;
          matchedProfile = profile;
        }
      }
    });
    return matchedProfile;
  }
  async updateModels(provider) {
    return this.providers[provider].updateModels();
  }
};

// src/main.ts
var Inscribe = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    await this.loadProviderManager();
    await this.setupExtention();
    this.addSettingTab(new InscribeSettingsTab(this.app, this));
  }
  async loadProviderManager() {
    this.providerManager = new ProviderManager(this.app, this.settings);
  }
  async setupExtention() {
    const extension = inlineSuggestions({
      fetchFunc: () => this.providerManager.fetchSuggestions(),
      getOptions: () => this.providerManager.getOptions()
    });
    this.registerEditorExtension(extension);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.providerManager.loadProviders();
  }
};
/*! Bundled license information:

mustache/mustache.mjs:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL2V4dGVuc2lvbi9pbmRleC50cyIsICJzcmMvcHJvdmlkZXJzL29wZW5haS9wcm92aWRlci50cyIsICJub2RlX21vZHVsZXMvb2xsYW1hL2Rpc3QvaW5kZXgubWpzIiwgIm5vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCAibm9kZV9tb2R1bGVzL29sbGFtYS9kaXN0L2Jyb3dzZXIubWpzIiwgIm5vZGVfbW9kdWxlcy9tdXN0YWNoZS9tdXN0YWNoZS5tanMiLCAic3JjL3Byb21wdC9wcm9tcHQudHMiLCAic3JjL3Byb3ZpZGVycy9vbGxhbWEvcHJvdmlkZXIudHMiLCAic3JjL3Byb3ZpZGVycy9pbmRleC50cyIsICJzcmMvc2V0dGluZ3Mvc2V0dGluZ3MudHMiLCAic3JjL3NldHRpbmdzL3NldHRpbmdzLXRhYi50cyIsICJzcmMvc2V0dGluZ3MvcHJvdmlkZXItbW9kYWwudHMiLCAic3JjL3Byb3ZpZGVycy9tYW5hZ2VyLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBpbmxpbmVTdWdnZXN0aW9ucyB9IGZyb20gXCIuL2V4dGVuc2lvblwiO1xuaW1wb3J0IHsgU2V0dGluZ3MsIERFRkFVTFRfU0VUVElOR1MgfSBmcm9tICcuL3NldHRpbmdzL3NldHRpbmdzJztcbmltcG9ydCBJbnNjcmliZVNldHRpbmdzVGFiIGZyb20gJy4vc2V0dGluZ3Mvc2V0dGluZ3MtdGFiJztcbmltcG9ydCB7IFByb3ZpZGVyTWFuYWdlciB9IGZyb20gJy4vcHJvdmlkZXJzL21hbmFnZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnNjcmliZSBleHRlbmRzIFBsdWdpbiB7XG5cdHNldHRpbmdzOiBTZXR0aW5ncztcblx0cHJvdmlkZXJNYW5hZ2VyOiBQcm92aWRlck1hbmFnZXI7XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cdFx0YXdhaXQgdGhpcy5sb2FkUHJvdmlkZXJNYW5hZ2VyKCk7XG5cdFx0YXdhaXQgdGhpcy5zZXR1cEV4dGVudGlvbigpO1xuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgSW5zY3JpYmVTZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXHR9XG5cblx0YXN5bmMgbG9hZFByb3ZpZGVyTWFuYWdlcigpIHtcblx0XHR0aGlzLnByb3ZpZGVyTWFuYWdlciA9IG5ldyBQcm92aWRlck1hbmFnZXIodGhpcy5hcHAsIHRoaXMuc2V0dGluZ3MpO1xuXHR9XG5cblx0YXN5bmMgc2V0dXBFeHRlbnRpb24oKSB7XG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gaW5saW5lU3VnZ2VzdGlvbnMoe1xuXHRcdFx0ZmV0Y2hGdW5jOiAoKSA9PiB0aGlzLnByb3ZpZGVyTWFuYWdlci5mZXRjaFN1Z2dlc3Rpb25zKCksXG5cdFx0XHRnZXRPcHRpb25zOiAoKSA9PiB0aGlzLnByb3ZpZGVyTWFuYWdlci5nZXRPcHRpb25zKClcblx0XHR9KTtcblx0XHR0aGlzLnJlZ2lzdGVyRWRpdG9yRXh0ZW5zaW9uKGV4dGVuc2lvbik7XG5cdH1cblxuXHRhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oXG5cdFx0XHR7fSxcblx0XHRcdERFRkFVTFRfU0VUVElOR1MsXG5cdFx0XHRhd2FpdCB0aGlzLmxvYWREYXRhKClcblx0XHQpO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdFx0dGhpcy5wcm92aWRlck1hbmFnZXIubG9hZFByb3ZpZGVycygpO1xuXHR9XG59IiwgIi8qKlxuICogSW50ZWxsaWdlbnQgSW5saW5lIENvbXBsZXRpb25zIGZvciBDb2RlTWlycm9yXG4gKlxuICogVGhpcyBleHRlbnNpb24gb2ZmZXJzIEFJLXBvd2VyZWQgaW5saW5lIHN1Z2dlc3Rpb25zIHdpdGg6XG4gKiAtIENvbmZpZ3VyYWJsZSBzdWdnZXN0aW9uIGZldGNoaW5nIHN0cmF0ZWdpZXNcbiAqIC0gTXVsdGlwbGUgdGV4dCBzZWdtZW50YXRpb24gYXBwcm9hY2hlc1xuICogLSBEZWJvdW5jZWQgbmV0d29yayByZXF1ZXN0c1xuICogLSBOb24taW52YXNpdmUgc3VnZ2VzdGlvbiByZW5kZXJpbmdcbiAqL1xuXG5pbXBvcnQge1xuICAgIFZpZXdQbHVnaW4sXG4gICAgRWRpdG9yVmlldyxcbiAgICBWaWV3VXBkYXRlLFxuICAgIERlY29yYXRpb24sXG4gICAgV2lkZ2V0VHlwZSxcbiAgICBrZXltYXAsXG59IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHtcbiAgICBTdGF0ZUVmZmVjdCxcbiAgICBUZXh0LFxuICAgIFN0YXRlRmllbGQsXG4gICAgRWRpdG9yU3RhdGUsXG4gICAgRWRpdG9yU2VsZWN0aW9uLFxuICAgIFRyYW5zYWN0aW9uLFxuICAgIFByZWMsXG59IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgIFR5cGUgRGVmaW5pdGlvbnNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyoqIFN1cHBvcnRlZCBzZWdtZW50YXRpb24gc3RyYXRlZ2llcyAqL1xuZXhwb3J0IHR5cGUgU3BsaXRTdHJhdGVneSA9IGtleW9mIHR5cGVvZiBUZXh0U3BsaXRTdHJhdGVnaWVzO1xuXG4vKiogSW5saW5lIHN1Z2dlc3Rpb24gc3RydWN0dXJlIFx1MjAxMyBub3cgb25seSBjYXJyaWVzIHRleHQuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1Z2dlc3Rpb24ge1xuICAgIHRleHQ6IHN0cmluZztcbn1cblxuLyoqIElubGluZSBjb21wbGV0aW9uIGNvbmZpZ3VyYXRpb24uXG4gKiBcbiAqIE5vdGU6IEluc3RlYWQgb2YgZWFjaCBzdWdnZXN0aW9uIGNhcnJ5aW5nIGl0cyBzcGxpdCBzdHJhdGVneSxcbiAqIHlvdSBzdXBwbHkgYSBkeW5hbWljIGdldHRlciBmdW5jdGlvbiAoYGdldE9wdGlvbnNgKSBzbyB0aGF0IHRoZSBleHRlbnNpb25cbiAqIGFsd2F5cyB1c2VzIHRoZSBjdXJyZW50IHNldHRpbmdzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElubGluZUNvbXBsZXRpb25Db25maWcge1xuICAgIGZldGNoRnVuYzogKFxuICAgICAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICApID0+IEFzeW5jR2VuZXJhdG9yPFN1Z2dlc3Rpb24+IHwgUHJvbWlzZTxTdWdnZXN0aW9uPjtcbiAgICAvKiogKE9wdGlvbmFsKSBBIHN0YXRpYyBob3RrZXkgZm9yIGFjY2VwdGluZyBzdWdnZXN0aW9ucy4gKi9cbiAgICBhY2NlcHRhbmNlSG90a2V5Pzogc3RyaW5nO1xuICAgIC8qKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBjdXJyZW50IG9wdGlvbnMuICovXG4gICAgZ2V0T3B0aW9uczogKCkgPT4gSW5saW5lQ29tcGxldGlvbk9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5saW5lQ29tcGxldGlvbk9wdGlvbnMge1xuICAgIGRlbGF5TXM/OiBudW1iZXI7XG4gICAgc3BsaXRTdHJhdGVneT86IFNwbGl0U3RyYXRlZ3k7XG59XG5cbi8qKiBJbnRlcm5hbCBzdGF0ZSBmb3IgdGhlIGN1cnJlbnQgc3VnZ2VzdGlvbiBzZXNzaW9uLlxuICogTm90ZTogVGhlIHByZXZpb3VzIFwic2VnbWVudGF0aW9uXCIgcHJvcGVydHkgaGFzIGJlZW4gcmVtb3ZlZC5cbiAqL1xuaW50ZXJmYWNlIFN1Z2dlc3Rpb25TZXNzaW9uIHtcbiAgICBmdWxsVGV4dDogc3RyaW5nIHwgbnVsbDtcbiAgICByZW1haW5pbmdUZXh0OiBzdHJpbmcgfCBudWxsO1xuICAgIGJhc2VsaW5lRG9jdW1lbnQ6IFRleHQgfCBudWxsO1xuICAgIGFuY2hvclBvc2l0aW9uOiBudW1iZXIgfCBudWxsO1xufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgVGV4dCBTZWdtZW50YXRpb24gU3RyYXRlZ2llc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKipcbiAqIEEgc2V0IG9mIHRleHQgc3BsaXR0aW5nIGZ1bmN0aW9ucyB1c2VkIHRvIGRldGVybWluZSBob3cgbXVjaCBvZiB0aGVcbiAqIHN1Z2dlc3Rpb24gdG8gYWNjZXB0IHdoZW4gdHJpZ2dlcmVkLlxuICovXG5jb25zdCBUZXh0U3BsaXRTdHJhdGVnaWVzID0ge1xuICAgIC8qKlxuICAgICAqIFdvcmQtbGV2ZWwgc2VnbWVudGF0aW9uIChzcGFjZS1kZWxpbWl0ZWQpLlxuICAgICAqIEFjY2VwdHMgdGV4dCB1bnRpbCAoYW5kIGluY2x1ZGluZykgdGhlIGZpcnN0IHNwYWNlLlxuICAgICAqL1xuICAgIHdvcmQ6ICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dFNwYWNlID0gdGV4dC5pbmRleE9mKCcgJyk7XG4gICAgICAgIHJldHVybiBuZXh0U3BhY2UgPT09IC0xXG4gICAgICAgICAgICA/IHsgYWNjZXB0ZWQ6IHRleHQsIHJlbWFpbmluZzogJycgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgYWNjZXB0ZWQ6IHRleHQuc2xpY2UoMCwgbmV4dFNwYWNlICsgMSksXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nOiB0ZXh0LnNsaWNlKG5leHRTcGFjZSArIDEpLFxuICAgICAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VudGVuY2UtbGV2ZWwgc2VnbWVudGF0aW9uIChwdW5jdHVhdGlvbiBmb2xsb3dlZCBieSB3aGl0ZXNwYWNlKS5cbiAgICAgKi9cbiAgICBzZW50ZW5jZTogKHRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2goL1suIT9dXFxzKy8pO1xuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY2NlcHRlZDogdGV4dC5zbGljZSgwLCBtYXRjaC5pbmRleCArIDEpLFxuICAgICAgICAgICAgICAgIHJlbWFpbmluZzogdGV4dC5zbGljZShtYXRjaC5pbmRleCArIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBhY2NlcHRlZDogdGV4dCwgcmVtYWluaW5nOiAnJyB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJhZ3JhcGgtbGV2ZWwgc2VnbWVudGF0aW9uIChkb3VibGUgbmV3bGluZSkuXG4gICAgICovXG4gICAgcGFyYWdyYXBoOiAodGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFncmFwaEVuZCA9IHRleHQuaW5kZXhPZignXFxuXFxuJyk7XG4gICAgICAgIHJldHVybiBwYXJhZ3JhcGhFbmQgPT09IC0xXG4gICAgICAgICAgICA/IHsgYWNjZXB0ZWQ6IHRleHQsIHJlbWFpbmluZzogJycgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgYWNjZXB0ZWQ6IHRleHQuc2xpY2UoMCwgcGFyYWdyYXBoRW5kICsgMiksXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nOiB0ZXh0LnNsaWNlKHBhcmFncmFwaEVuZCArIDIpLFxuICAgICAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXRvbWljIGFjY2VwdGFuY2UgXHUyMDEzIGNvbnN1bWUgdGhlIGVudGlyZSBzdWdnZXN0aW9uLlxuICAgICAqL1xuICAgIGZ1bGw6ICh0ZXh0OiBzdHJpbmcpID0+ICh7IGFjY2VwdGVkOiB0ZXh0LCByZW1haW5pbmc6ICcnIH0pLFxufSBhcyBjb25zdDtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgIFN1Z2dlc3Rpb24gU2Vzc2lvbiBTdGF0ZSBNYW5hZ2VtZW50XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKlxuICogRWZmZWN0IHRvIHVwZGF0ZSB0aGUgc3VnZ2VzdGlvbiBzZXNzaW9uIHN0YXRlLlxuICogQSBgbnVsbGAgY29udGVudCBzaWduYWxzIGEgcmVzZXQuXG4gKi9cbmNvbnN0IFN1Z2dlc3Rpb25VcGRhdGVFZmZlY3QgPSBTdGF0ZUVmZmVjdC5kZWZpbmU8e1xuICAgIGNvbnRlbnQ6IHN0cmluZyB8IG51bGw7XG4gICAgZG9jdW1lbnQ6IFRleHQgfCBudWxsO1xuICAgIGFuY2hvcjogbnVtYmVyIHwgbnVsbDtcbn0+KCk7XG5cbi8qKlxuICogVGhlIHN0YXRlIGZpZWxkIHRoYXQgaG9sZHMgdGhlIGN1cnJlbnQgc3VnZ2VzdGlvbiBzZXNzaW9uLlxuICovXG5jb25zdCBzdWdnZXN0aW9uU2Vzc2lvblN0YXRlID0gU3RhdGVGaWVsZC5kZWZpbmU8U3VnZ2VzdGlvblNlc3Npb24+KHtcbiAgICBjcmVhdGU6ICgpID0+IGdldFJlc2V0U2Vzc2lvbigpLFxuXG4gICAgdXBkYXRlKHNlc3Npb24sIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIFByb2Nlc3MgZXhwbGljaXQgc2Vzc2lvbiB1cGRhdGUgZWZmZWN0cy5cbiAgICAgICAgY29uc3QgZWZmZWN0ID0gdHJhbnNhY3Rpb24uZWZmZWN0cy5maW5kKChlKSA9PlxuICAgICAgICAgICAgZS5pcyhTdWdnZXN0aW9uVXBkYXRlRWZmZWN0KVxuICAgICAgICApO1xuICAgICAgICBpZiAoZWZmZWN0KSByZXR1cm4gdXBkYXRlU2Vzc2lvbkZyb21FZmZlY3QoZWZmZWN0LnZhbHVlKTtcblxuICAgICAgICAvLyBJZiB0aGUgZG9jdW1lbnQgaGFzIGNoYW5nZWQsIGFkanVzdCB0aGUgc2Vzc2lvbi5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCAmJlxuICAgICAgICAgICAgc2Vzc2lvbi5yZW1haW5pbmdUZXh0ICYmXG4gICAgICAgICAgICBzZXNzaW9uLmFuY2hvclBvc2l0aW9uICE9PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNlc3Npb25PbkRvY3VtZW50Q2hhbmdlKHNlc3Npb24sIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGFjdGl2ZSBzdWdnZXN0aW9uIGJ1dCB0aGUgY3Vyc29yIGhhcyBtb3ZlZCwgY2FuY2VsIGl0LlxuICAgICAgICBpZiAoc2Vzc2lvbi5yZW1haW5pbmdUZXh0ICE9PSBudWxsICYmIHNlc3Npb24uYW5jaG9yUG9zaXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTZXNzaW9uT25DdXJzb3JEcmlmdChzZXNzaW9uLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICB9LFxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZyZXNoLCBlbXB0eSBzdWdnZXN0aW9uIHNlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIGdldFJlc2V0U2Vzc2lvbigpOiBTdWdnZXN0aW9uU2Vzc2lvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVsbFRleHQ6IG51bGwsXG4gICAgICAgIHJlbWFpbmluZ1RleHQ6IG51bGwsXG4gICAgICAgIGJhc2VsaW5lRG9jdW1lbnQ6IG51bGwsXG4gICAgICAgIGFuY2hvclBvc2l0aW9uOiBudWxsLFxuICAgIH07XG59XG5cbi8qKlxuICogVXBkYXRlIHNlc3Npb24gc3RhdGUgYmFzZWQgb24gYW4gaW5jb21pbmcgZWZmZWN0LlxuICovXG5mdW5jdGlvbiB1cGRhdGVTZXNzaW9uRnJvbUVmZmVjdChlZmZlY3Q6IHtcbiAgICBjb250ZW50OiBzdHJpbmcgfCBudWxsO1xuICAgIGRvY3VtZW50OiBUZXh0IHwgbnVsbDtcbiAgICBhbmNob3I6IG51bWJlciB8IG51bGw7XG59KTogU3VnZ2VzdGlvblNlc3Npb24ge1xuICAgIHJldHVybiBlZmZlY3QuY29udGVudCA9PT0gbnVsbFxuICAgICAgICA/IGdldFJlc2V0U2Vzc2lvbigpXG4gICAgICAgIDogaW5pdGlhbGl6ZVNlc3Npb24oZWZmZWN0IGFzIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICAgICAgICAgIGRvY3VtZW50OiBUZXh0O1xuICAgICAgICAgICAgYW5jaG9yOiBudW1iZXI7XG4gICAgICAgIH0pO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGEgbmV3IHN1Z2dlc3Rpb24gc2Vzc2lvbiB3aXRoIHByb3ZpZGVkIGVmZmVjdCBkYXRhLlxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplU2Vzc2lvbihlZmZlY3Q6IHtcbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgZG9jdW1lbnQ6IFRleHQ7XG4gICAgYW5jaG9yOiBudW1iZXI7XG59KTogU3VnZ2VzdGlvblNlc3Npb24ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZ1bGxUZXh0OiBlZmZlY3QuY29udGVudCxcbiAgICAgICAgcmVtYWluaW5nVGV4dDogZWZmZWN0LmNvbnRlbnQsXG4gICAgICAgIGJhc2VsaW5lRG9jdW1lbnQ6IGVmZmVjdC5kb2N1bWVudCxcbiAgICAgICAgYW5jaG9yUG9zaXRpb246IGVmZmVjdC5hbmNob3IsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBBZGp1c3QgdGhlIHN1Z2dlc3Rpb24gc2Vzc2lvbiBpbiByZXNwb25zZSB0byBkb2N1bWVudCBjaGFuZ2VzLlxuICovXG5mdW5jdGlvbiB1cGRhdGVTZXNzaW9uT25Eb2N1bWVudENoYW5nZShcbiAgICBzZXNzaW9uOiBTdWdnZXN0aW9uU2Vzc2lvbixcbiAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cbik6IFN1Z2dlc3Rpb25TZXNzaW9uIHtcbiAgICBsZXQgaW5zZXJ0ZWRDb250ZW50ID0gJyc7XG4gICAgbGV0IGluc2VydGlvbkF0QW5jaG9yID0gZmFsc2U7XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZG9jdW1lbnQgY2hhbmdlcyB0byBkZXRlY3QgYW4gaW5zZXJ0aW9uIGF0IHRoZSBzdWdnZXN0aW9uJ3MgYW5jaG9yLlxuICAgIHRyYW5zYWN0aW9uLmNoYW5nZXMuaXRlckNoYW5nZXMoKGZyb21BLCB0b0EsIF9mcm9tQiwgX3RvQiwgaW5zZXJ0ZWQpID0+IHtcbiAgICAgICAgaWYgKGZyb21BID09PSBzZXNzaW9uLmFuY2hvclBvc2l0aW9uICYmIHRvQSA9PT0gZnJvbUEpIHtcbiAgICAgICAgICAgIGluc2VydGVkQ29udGVudCA9IGluc2VydGVkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpbnNlcnRpb25BdEFuY2hvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghaW5zZXJ0aW9uQXRBbmNob3IgfHwgIXNlc3Npb24ucmVtYWluaW5nVGV4dCkge1xuICAgICAgICByZXR1cm4gaW52YWxpZGF0ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IHRoZSBpbnNlcnRlZCB0ZXh0IG1hdGNoZXMgdGhlIHBlbmRpbmcgc3VnZ2VzdGlvbi5cbiAgICBpZiAoc2Vzc2lvbi5yZW1haW5pbmdUZXh0LnN0YXJ0c1dpdGgoaW5zZXJ0ZWRDb250ZW50KSkge1xuICAgICAgICByZXR1cm4gYWR2YW5jZVNlc3Npb24oc2Vzc2lvbiwgaW5zZXJ0ZWRDb250ZW50Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludmFsaWRhdGVTZXNzaW9uKHNlc3Npb24pO1xufVxuXG4vKipcbiAqIEFkdmFuY2UgdGhlIHNlc3Npb24gYnkgY29uc3VtaW5nIGFjY2VwdGVkIHRleHQuXG4gKi9cbmZ1bmN0aW9uIGFkdmFuY2VTZXNzaW9uKFxuICAgIHNlc3Npb246IFN1Z2dlc3Rpb25TZXNzaW9uLFxuICAgIGNvbnN1bWVkTGVuZ3RoOiBudW1iZXJcbik6IFN1Z2dlc3Rpb25TZXNzaW9uIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zZXNzaW9uLFxuICAgICAgICByZW1haW5pbmdUZXh0OlxuICAgICAgICAgICAgc2Vzc2lvbi5yZW1haW5pbmdUZXh0IS5zbGljZShjb25zdW1lZExlbmd0aCkubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gc2Vzc2lvbi5yZW1haW5pbmdUZXh0IS5zbGljZShjb25zdW1lZExlbmd0aClcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIGFuY2hvclBvc2l0aW9uOiBzZXNzaW9uLmFuY2hvclBvc2l0aW9uISArIGNvbnN1bWVkTGVuZ3RoLFxuICAgIH07XG59XG5cbi8qKlxuICogSW52YWxpZGF0ZSB0aGUgc2Vzc2lvbiwgZWZmZWN0aXZlbHkgY2FuY2VsbGluZyBhbnkgcGVuZGluZyBzdWdnZXN0aW9uLlxuICovXG5mdW5jdGlvbiBpbnZhbGlkYXRlU2Vzc2lvbihzZXNzaW9uOiBTdWdnZXN0aW9uU2Vzc2lvbik6IFN1Z2dlc3Rpb25TZXNzaW9uIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zZXNzaW9uLFxuICAgICAgICByZW1haW5pbmdUZXh0OiBudWxsLFxuICAgICAgICBhbmNob3JQb3NpdGlvbjogbnVsbCxcbiAgICB9O1xufVxuXG4vKipcbiAqIENhbmNlbCB0aGUgc3VnZ2VzdGlvbiBpZiB0aGUgY3Vyc29yIGhhcyBkcmlmdGVkIGF3YXkuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVNlc3Npb25PbkN1cnNvckRyaWZ0KFxuICAgIHNlc3Npb246IFN1Z2dlc3Rpb25TZXNzaW9uLFxuICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuKTogU3VnZ2VzdGlvblNlc3Npb24ge1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkICE9PSBzZXNzaW9uLmFuY2hvclBvc2l0aW9uXG4gICAgICAgID8gaW52YWxpZGF0ZVNlc3Npb24oc2Vzc2lvbilcbiAgICAgICAgOiBzZXNzaW9uO1xufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgU3VnZ2VzdGlvbiBSZW5kZXJpbmcgKFZpc3VhbGl6YXRpb24gTGF5ZXIpXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKlxuICogV2lkZ2V0IGZvciByZW5kZXJpbmcgaW5saW5lIHN1Z2dlc3Rpb24gdGV4dC5cbiAqL1xuY2xhc3MgU3VnZ2VzdGlvbldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIHN0YXRpYyByZWFkb25seSBPUEFDSVRZID0gMC40O1xuICAgIHN0YXRpYyByZWFkb25seSBDU1NfQ0xBU1MgPSAnY20taW5saW5lLXByZWRpY3Rpb24nO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjb250ZW50OiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICB0b0RPTSgpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gU3VnZ2VzdGlvbldpZGdldC5DU1NfQ0xBU1M7XG4gICAgICAgIHNwYW4uc3R5bGUub3BhY2l0eSA9IFN1Z2dlc3Rpb25XaWRnZXQuT1BBQ0lUWS50b1N0cmluZygpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG5cbi8qKlxuICogUGx1Z2luIHRoYXQgcmVuZGVycyBpbmxpbmUgc3VnZ2VzdGlvbiBkZWNvcmF0aW9ucy5cbiAqL1xuY29uc3Qgc3VnZ2VzdGlvblJlbmRlcmVyID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoXG4gICAgY2xhc3Mge1xuICAgICAgICBkZWNvcmF0aW9ucyA9IERlY29yYXRpb24ubm9uZTtcblxuICAgICAgICB1cGRhdGUodXBkYXRlOiBWaWV3VXBkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gdXBkYXRlLnN0YXRlLmZpZWxkKHN1Z2dlc3Rpb25TZXNzaW9uU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHNlc3Npb24ucmVtYWluaW5nVGV4dFxuICAgICAgICAgICAgICAgID8gdGhpcy5jcmVhdGVEZWNvcmF0aW9uKHVwZGF0ZS52aWV3LCBzZXNzaW9uLnJlbWFpbmluZ1RleHQpXG4gICAgICAgICAgICAgICAgOiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBwcml2YXRlIGNyZWF0ZURlY29yYXRpb24odmlldzogRWRpdG9yVmlldywgc3VnZ2VzdGlvblRleHQ6IHN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9zaXRpb24gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoW1xuICAgICAgICAgICAgICAgIERlY29yYXRpb24ud2lkZ2V0KHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgU3VnZ2VzdGlvbldpZGdldChzdWdnZXN0aW9uVGV4dCksXG4gICAgICAgICAgICAgICAgICAgIHNpZGU6IDEsXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UoY3Vyc29yUG9zaXRpb24pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHsgZGVjb3JhdGlvbnM6ICh2KSA9PiB2LmRlY29yYXRpb25zIH1cbik7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICBTdWdnZXN0aW9uIEZldGNoaW5nIChEZWJvdW5jZWQgRmV0Y2hlcilcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZldGNoZXIgZm9yIHN1Z2dlc3Rpb25zLlxuICpcbiAqIEBwYXJhbSBmZXRjaCAtIFRoZSBzdWdnZXN0aW9uIGZldGNoIGZ1bmN0aW9uLlxuICogQHBhcmFtIGdldERlbGF5IC0gQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGN1cnJlbnQgZGVib3VuY2UgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5jb25zdCBjcmVhdGVEZWJvdW5jZWRGZXRjaGVyID0gKFxuICAgIGZldGNoOiAoc3RhdGU6IEVkaXRvclN0YXRlKSA9PiBBc3luY0dlbmVyYXRvcjxTdWdnZXN0aW9uPixcbiAgICBnZXREZWxheTogKCkgPT4gbnVtYmVyXG4pID0+IHtcbiAgICBsZXQgYWN0aXZlUmVxdWVzdCA9IHRydWU7XG4gICAgbGV0IHRpbWVvdXRJZDogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD47XG5cbiAgICAvKipcbiAgICAgKiBUaHJvdHRsZWQgZmV0Y2ggdGhhdCB3YWl0cyBmb3IgdGhlIGRlYm91bmNlIGludGVydmFsLlxuICAgICAqL1xuICAgIGNvbnN0IHRocm90dGxlZEZldGNoID0gYXN5bmMgZnVuY3Rpb24qIChzdGF0ZTogRWRpdG9yU3RhdGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGFjdGl2ZVJlcXVlc3QgPSB0cnVlO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChyZXNvbHZlLCBnZXREZWxheSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3RpdmVSZXF1ZXN0KSB5aWVsZCogZmV0Y2goc3RhdGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQbHVnaW4gdGhhdCBpbml0aWF0ZXMgc3VnZ2VzdGlvbiBmZXRjaGluZyBvbiBkb2N1bWVudCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGNvbnN0IGZldGNoZXJQbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhcbiAgICAgICAgY2xhc3Mge1xuICAgICAgICAgICAgcHJpdmF0ZSBjdXJyZW50UmVxdWVzdElkID0gMDtcblxuICAgICAgICAgICAgYXN5bmMgdXBkYXRlKHVwZGF0ZTogVmlld1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdXBkYXRlLnN0YXRlO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgdHJpZ2dlciBmZXRjaCBpZiB0aGVyZSBpcyBubyBhY3RpdmUgc3VnZ2VzdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHN0YXRlLmZpZWxkKHN1Z2dlc3Rpb25TZXNzaW9uU3RhdGUpLnJlbWFpbmluZ1RleHQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9ICsrdGhpcy5jdXJyZW50UmVxdWVzdElkO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3Qgc3VnZ2VzdGlvbiBvZiB0aHJvdHRsZWRGZXRjaChzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHN0YWxlIHJlcXVlc3RzLlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdElkICE9PSB0aGlzLmN1cnJlbnRSZXF1ZXN0SWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlLnZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogU3VnZ2VzdGlvblVwZGF0ZUVmZmVjdC5vZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogc3VnZ2VzdGlvbi50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBzdGF0ZS5kb2MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yOiBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmZXRjaGVyUGx1Z2luLFxuICAgICAgICB0ZXJtaW5hdGU6ICgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZVJlcXVlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgVXNlciBJbnRlcmFjdGlvbiAoQWNjZXB0YW5jZSBIYW5kbGVyKVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBrZXkgYmluZGluZyB0aGF0IGFjY2VwdHMgdGhlIGN1cnJlbnQgc3VnZ2VzdGlvbi5cbiAqXG4gKiBAcGFyYW0gdGVybWluYXRlRmV0Y2ggLSBGdW5jdGlvbiB0byBzdG9wIGZ1cnRoZXIgZmV0Y2hpbmcuXG4gKiBAcGFyYW0gaG90a2V5IC0gVGhlIGtleSB0aGF0IHRyaWdnZXJzIGFjY2VwdGFuY2UuXG4gKiBAcGFyYW0gZ2V0T3B0aW9ucyAtIEZ1bmN0aW9uIHJldHVybmluZyBkeW5hbWljIG9wdGlvbnMgKGluY2x1ZGluZyBzcGxpdFN0cmF0ZWd5KS5cbiAqL1xuY29uc3QgY3JlYXRlQWNjZXB0YW5jZUhhbmRsZXIgPSAoXG4gICAgdGVybWluYXRlRmV0Y2g6ICgpID0+IHZvaWQsXG4gICAgaG90a2V5OiBzdHJpbmcsXG4gICAgZ2V0T3B0aW9uczogKCkgPT4geyBkZWxheU1zPzogbnVtYmVyOyBzcGxpdFN0cmF0ZWd5PzogU3BsaXRTdHJhdGVneSB9XG4pID0+XG4gICAgUHJlYy5oaWdoZXN0KFxuICAgICAgICBrZXltYXAub2YoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleTogaG90a2V5LFxuICAgICAgICAgICAgICAgIHJ1bjogKHZpZXc6IEVkaXRvclZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHZpZXcuc3RhdGUuZmllbGQoc3VnZ2VzdGlvblNlc3Npb25TdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbi5yZW1haW5pbmdUZXh0KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIG9idGFpbiB0aGUgY3VycmVudCBzcGxpdCBzdHJhdGVneSBmcm9tIGdldE9wdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNPcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50YXRpb25LZXkgPSBkeW5hbWljT3B0aW9ucy5zcGxpdFN0cmF0ZWd5ID8/ICd3b3JkJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhY2NlcHRlZCwgcmVtYWluaW5nIH0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgVGV4dFNwbGl0U3RyYXRlZ2llc1tzZWdtZW50YXRpb25LZXldKHNlc3Npb24ucmVtYWluaW5nVGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhY2NlcHRlZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgYWNjZXB0ZWQgc3VnZ2VzdGlvbiB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmluc2VydENvbXBsZXRpb24odmlldy5zdGF0ZSwgYWNjZXB0ZWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogU3VnZ2VzdGlvblVwZGF0ZUVmZmVjdC5vZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogcmVtYWluaW5nIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHJlbWFpbmluZyA/IHNlc3Npb24uYmFzZWxpbmVEb2N1bWVudCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yOiByZW1haW5pbmcgPyBzZXNzaW9uLmFuY2hvclBvc2l0aW9uISArIGFjY2VwdGVkLmxlbmd0aCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZW1haW5pbmcpIHRlcm1pbmF0ZUZldGNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKVxuICAgICk7XG5cbi8qKlxuICogSGVscGVyIHRvIGNyZWF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgaW5zZXJ0cyBjb21wbGV0aW9uIHRleHQuXG4gKi9cbmNvbnN0IGluc2VydENvbXBsZXRpb24gPSAoc3RhdGU6IEVkaXRvclN0YXRlLCB0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBjdXJzb3JQb3MgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLmNoYW5nZUJ5UmFuZ2UoKCkgPT4gKHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogY3Vyc29yUG9zLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGN1cnNvclBvcyArIHRleHQubGVuZ3RoKSxcbiAgICAgICAgfSkpLFxuICAgICAgICB1c2VyRXZlbnQ6ICdjb21wbGV0aW9uLmFjY2VwdCcsXG4gICAgfTtcbn07XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICBQdWJsaWMgQVBJXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKlxuICogVGhlIG1haW4gZXh0ZW5zaW9uIGZ1bmN0aW9uLiBJdCB3aXJlcyB1cCBzZXNzaW9uIHN0YXRlIG1hbmFnZW1lbnQsXG4gKiBzdWdnZXN0aW9uIGZldGNoaW5nLCByZW5kZXJpbmcsIGFuZCB1c2VyIGludGVyYWN0aW9uLlxuICpcbiAqIE5vdGljZSB0aGF0IHRoZSBzdWdnZXN0aW9uIG5vdyBvbmx5IGNvbnRhaW5zIHRleHQuXG4gKiBUaGUgc3BsaXQgc3RyYXRlZ3kgaXMgYWx3YXlzIG9idGFpbmVkIGR5bmFtaWNhbGx5IHZpYSBgZ2V0T3B0aW9ucygpYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlubGluZVN1Z2dlc3Rpb25zKGNvbmZpZzogSW5saW5lQ29tcGxldGlvbkNvbmZpZykge1xuICAgIGNvbnN0IHsgZmV0Y2hGdW5jLCBnZXRPcHRpb25zIH0gPSBjb25maWc7XG4gICAgLy8gVXNlIHRoZSBob3RrZXkgZnJvbSB0aGUgY29uZmlnIGlmIHByb3ZpZGVkOyBvdGhlcndpc2UsIGRlZmF1bHQgdG8gXCJUYWJcIi5cbiAgICBjb25zdCBzdGF0aWNIb3RrZXkgPSBjb25maWcuYWNjZXB0YW5jZUhvdGtleSB8fCAnVGFiJztcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgZmV0Y2ggZnVuY3Rpb24gdG8gYWx3YXlzIHJldHVybiBhbiBhc3luYyBnZW5lcmF0b3IuXG4gICAgY29uc3Qgbm9ybWFsaXplRmV0Y2ggPSBhc3luYyBmdW5jdGlvbiogKHN0YXRlOiBFZGl0b3JTdGF0ZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaEZ1bmMoc3RhdGUpO1xuICAgICAgICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICB5aWVsZCogcmVzdWx0IGFzIEFzeW5jR2VuZXJhdG9yPFN1Z2dlc3Rpb24+O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgcmVzdWx0IGFzIFN1Z2dlc3Rpb247XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVXNlIGdldE9wdGlvbnMoKSB0byBvYnRhaW4gdGhlIGN1cnJlbnQgZGVib3VuY2UgZGVsYXkuXG4gICAgY29uc3QgZ2V0RGVsYXkgPSAoKSA9PiBnZXRPcHRpb25zKCkuZGVsYXlNcyA/PyAzMDA7XG4gICAgY29uc3QgeyBmZXRjaGVyUGx1Z2luLCB0ZXJtaW5hdGUgfSA9IGNyZWF0ZURlYm91bmNlZEZldGNoZXIobm9ybWFsaXplRmV0Y2gsIGdldERlbGF5KTtcbiAgICBjb25zdCBhY2NlcHRhbmNlSGFuZGxlciA9IGNyZWF0ZUFjY2VwdGFuY2VIYW5kbGVyKHRlcm1pbmF0ZSwgc3RhdGljSG90a2V5LCBnZXRPcHRpb25zKTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIHN1Z2dlc3Rpb25TZXNzaW9uU3RhdGUsXG4gICAgICAgIGZldGNoZXJQbHVnaW4sXG4gICAgICAgIHN1Z2dlc3Rpb25SZW5kZXJlcixcbiAgICAgICAgYWNjZXB0YW5jZUhhbmRsZXIsXG4gICAgXTtcbn1cbiIsICJpbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBPcGVuQUlTZXR0aW5ncyB9IGZyb20gXCIuXCI7XG5cbmV4cG9ydCBjbGFzcyBPcGVuQUlQcm92aWRlciBpbXBsZW1lbnRzIFByb3ZpZGVyIHtcbiAgICBzZXR0aW5nczogT3BlbkFJU2V0dGluZ3NcbiAgICBtb2RlbHM6IHN0cmluZ1tdO1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzOiBPcGVuQUlTZXR0aW5ncykge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfVxuICAgIGdlbmVyYXRlOiAoZWRpdG9yOiBFZGl0b3IpID0+IEFzeW5jR2VuZXJhdG9yPHN0cmluZz47XG4gICAgYWJvcnQ6ICgpID0+IFByb21pc2U8dm9pZD47XG4gICAgdXBkYXRlTW9kZWxzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFtcImdwdC00XCIsIFwiZGF2aW5jaVwiXTtcbiAgICB9XG59IiwgImltcG9ydCBmcywgeyBwcm9taXNlcyB9IGZyb20gJ2ZzJztcbmltcG9ydCB7IHJlc29sdmUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IE9sbGFtYSBhcyBPbGxhbWEkMSB9IGZyb20gJy4vYnJvd3Nlci5tanMnO1xuaW1wb3J0ICd3aGF0d2ctZmV0Y2gnO1xuXG5jbGFzcyBPbGxhbWEgZXh0ZW5kcyBPbGxhbWEkMSB7XG4gIGFzeW5jIGVuY29kZUltYWdlKGltYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBpbWFnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGltYWdlKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKGltYWdlKSkge1xuICAgICAgICBjb25zdCBmaWxlQnVmZmVyID0gYXdhaXQgcHJvbWlzZXMucmVhZEZpbGUocmVzb2x2ZShpbWFnZSkpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oZmlsZUJ1ZmZlcikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxuICAvKipcbiAgICogY2hlY2tzIGlmIGEgZmlsZSBleGlzdHNcbiAgICogQHBhcmFtIHBhdGgge3N0cmluZ30gLSBUaGUgcGF0aCB0byB0aGUgZmlsZVxuICAgKiBAcHJpdmF0ZSBAaW50ZXJuYWxcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IC0gV2hldGhlciB0aGUgZmlsZSBleGlzdHMgb3Igbm90XG4gICAqL1xuICBhc3luYyBmaWxlRXhpc3RzKHBhdGgpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJvbWlzZXMuYWNjZXNzKHBhdGgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNyZWF0ZShyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QuZnJvbSAmJiBhd2FpdCB0aGlzLmZpbGVFeGlzdHMocmVzb2x2ZShyZXF1ZXN0LmZyb20pKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJDcmVhdGluZyB3aXRoIGEgbG9jYWwgcGF0aCBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBmcm9tIG9sbGFtYS1qc1wiKTtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3Quc3RyZWFtKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY3JlYXRlKHJlcXVlc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuY3JlYXRlKHJlcXVlc3QpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgaW5kZXggPSBuZXcgT2xsYW1hKCk7XG5cbmV4cG9ydCB7IE9sbGFtYSwgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xudmFyIGcgPVxuICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMpIHx8XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpIHx8XG4gIHt9XG5cbnZhciBzdXBwb3J0ID0ge1xuICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIGcsXG4gIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBnICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICBibG9iOlxuICAgICdGaWxlUmVhZGVyJyBpbiBnICYmXG4gICAgJ0Jsb2InIGluIGcgJiZcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIGcsXG4gIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIGdcbn1cblxuZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG59XG5cbmlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICBdXG5cbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gIH1cbiAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH4hXS9pLnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZTogXCInICsgbmFtZSArICdcIicpXG4gIH1cbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKVxuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3Jcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICB0aGlzLm1hcCA9IHt9XG5cbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICBpZiAoaGVhZGVyLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlcnMgY29uc3RydWN0b3I6IGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQnICsgaGVhZGVyLmxlbmd0aClcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICB9LCB0aGlzKVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdXG4gIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbkhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2gobmFtZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaXRlbXMucHVzaCh2YWx1ZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5pZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xufVxuXG5mdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gIGlmIChib2R5Ll9ub0JvZHkpIHJldHVyblxuICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgfVxuICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgfVxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHZhciBtYXRjaCA9IC9jaGFyc2V0PShbQS1aYS16MC05Xy1dKykvLmV4ZWMoYmxvYi50eXBlKVxuICB2YXIgZW5jb2RpbmcgPSBtYXRjaCA/IG1hdGNoWzFdIDogJ3V0Zi04J1xuICByZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZylcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgaWYgKGJ1Zi5zbGljZSkge1xuICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gIH1cbn1cblxuZnVuY3Rpb24gQm9keSgpIHtcbiAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgLypcbiAgICAgIGZldGNoLW1vY2sgd3JhcHMgdGhlIFJlc3BvbnNlIG9iamVjdCBpbiBhbiBFUzYgUHJveHkgdG9cbiAgICAgIHByb3ZpZGUgdXNlZnVsIHRlc3QgaGFybmVzcyBmZWF0dXJlcyBzdWNoIGFzIGZsdXNoLiBIb3dldmVyLCBvblxuICAgICAgRVM1IGJyb3dzZXJzIHdpdGhvdXQgZmV0Y2ggb3IgUHJveHkgc3VwcG9ydCBwb2xseWZpbGxzIG11c3QgYmUgdXNlZDtcbiAgICAgIHRoZSBwcm94eS1wb2xseWZpbGwgaXMgdW5hYmxlIHRvIHByb3h5IGFuIGF0dHJpYnV0ZSB1bmxlc3MgaXQgZXhpc3RzXG4gICAgICBvbiB0aGUgb2JqZWN0IGJlZm9yZSB0aGUgUHJveHkgaXMgY3JlYXRlZC4gVGhpcyBjaGFuZ2UgZW5zdXJlc1xuICAgICAgUmVzcG9uc2UuYm9keVVzZWQgZXhpc3RzIG9uIHRoZSBpbnN0YW5jZSwgd2hpbGUgbWFpbnRhaW5pbmcgdGhlXG4gICAgICBzZW1hbnRpYyBvZiBzZXR0aW5nIFJlcXVlc3QuYm9keVVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgX2luaXRCb2R5IGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIHRoaXMuYm9keVVzZWQgPSB0aGlzLmJvZHlVc2VkXG4gICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aGlzLl9ub0JvZHkgPSB0cnVlO1xuICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBpc0NvbnN1bWVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChpc0NvbnN1bWVkKSB7XG4gICAgICAgIHJldHVybiBpc0NvbnN1bWVkXG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQgKyB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBhcyBBcnJheUJ1ZmZlcicpXG4gICAgfVxuICB9XG5cbiAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3RlZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxudmFyIG1ldGhvZHMgPSBbJ0NPTk5FQ1QnLCAnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUEFUQ0gnLCAnUE9TVCcsICdQVVQnLCAnVFJBQ0UnXVxuXG5mdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgfVxuICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsXG4gICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpXG4gIH1cblxuICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbidcbiAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB9XG4gIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbCB8fCAoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnQWJvcnRDb250cm9sbGVyJyBpbiBnKSB7XG4gICAgICB2YXIgY3RybCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHJldHVybiBjdHJsLnNpZ25hbDtcbiAgICB9XG4gIH0oKSk7XG4gIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgfVxuICB0aGlzLl9pbml0Qm9keShib2R5KVxuXG4gIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgIGlmIChvcHRpb25zLmNhY2hlID09PSAnbm8tc3RvcmUnIHx8IG9wdGlvbnMuY2FjaGUgPT09ICduby1jYWNoZScpIHtcbiAgICAgIC8vIFNlYXJjaCBmb3IgYSAnXycgcGFyYW1ldGVyIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgIHZhciByZVBhcmFtU2VhcmNoID0gLyhbPyZdKV89W14mXSovXG4gICAgICBpZiAocmVQYXJhbVNlYXJjaC50ZXN0KHRoaXMudXJsKSkge1xuICAgICAgICAvLyBJZiBpdCBhbHJlYWR5IGV4aXN0cyB0aGVuIHNldCB0aGUgdmFsdWUgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHRoaXMudXJsID0gdGhpcy51cmwucmVwbGFjZShyZVBhcmFtU2VhcmNoLCAnJDFfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBhZGQgYSBuZXcgJ18nIHBhcmFtZXRlciB0byB0aGUgZW5kIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB2YXIgcmVRdWVyeVN0cmluZyA9IC9cXD8vXG4gICAgICAgIHRoaXMudXJsICs9IChyZVF1ZXJ5U3RyaW5nLnRlc3QodGhpcy51cmwpID8gJyYnIDogJz8nKSArICdfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBib2R5XG4gICAgLnRyaW0oKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBmb3JtXG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpXG4gIC8vIEF2b2lkaW5nIHNwbGl0IHZpYSByZWdleCB0byB3b3JrIGFyb3VuZCBhIGNvbW1vbiBJRTExIGJ1ZyB3aXRoIHRoZSBjb3JlLWpzIDMuNi4wIHJlZ2V4IHBvbHlmaWxsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvaXNzdWVzLzc0OFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNzUxXG4gIHByZVByb2Nlc3NlZEhlYWRlcnNcbiAgICAuc3BsaXQoJ1xccicpXG4gICAgLm1hcChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHJldHVybiBoZWFkZXIuaW5kZXhPZignXFxuJykgPT09IDAgPyBoZWFkZXIuc3Vic3RyKDEsIGhlYWRlci5sZW5ndGgpIDogaGVhZGVyXG4gICAgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Jlc3BvbnNlICcgKyBlcnJvci5tZXNzYWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG5leHBvcnQgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1c1xuICBpZiAodGhpcy5zdGF0dXMgPCAyMDAgfHwgdGhpcy5zdGF0dXMgPiA1OTkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Jlc3BvbnNlJzogVGhlIHN0YXR1cyBwcm92aWRlZCAoMCkgaXMgb3V0c2lkZSB0aGUgcmFuZ2UgWzIwMCwgNTk5XS5cIilcbiAgfVxuICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiAnJyArIG9wdGlvbnMuc3RhdHVzVGV4dFxuICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG59XG5cbkJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cblJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICB1cmw6IHRoaXMudXJsXG4gIH0pXG59XG5cblJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAyMDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgcmVzcG9uc2Uub2sgPSBmYWxzZVxuICByZXNwb25zZS5zdGF0dXMgPSAwXG4gIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gIHJldHVybiByZXNwb25zZVxufVxuXG52YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG59XG5cbmV4cG9ydCB2YXIgRE9NRXhjZXB0aW9uID0gZy5ET01FeGNlcHRpb25cbnRyeSB7XG4gIG5ldyBET01FeGNlcHRpb24oKVxufSBjYXRjaCAoZXJyKSB7XG4gIERPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpXG4gICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrXG4gIH1cbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuICBET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRE9NRXhjZXB0aW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgIH1cblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICB4aHIuYWJvcnQoKVxuICAgIH1cblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgY2hlY2sgaWYgc3BlY2lmaWNhbGx5IGZvciB3aGVuIGEgdXNlciBmZXRjaGVzIGEgZmlsZSBsb2NhbGx5IGZyb20gdGhlIGZpbGUgc3lzdGVtXG4gICAgICAvLyBPbmx5IGlmIHRoZSBzdGF0dXMgaXMgb3V0IG9mIGEgbm9ybWFsIHJhbmdlXG4gICAgICBpZiAocmVxdWVzdC51cmwuaW5kZXhPZignZmlsZTovLycpID09PSAwICYmICh4aHIuc3RhdHVzIDwgMjAwIHx8IHhoci5zdGF0dXMgPiA1OTkpKSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0gMjAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCB0aW1lZCBvdXQnKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4VXJsKHVybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVybCA9PT0gJycgJiYgZy5sb2NhdGlvbi5ocmVmID8gZy5sb2NhdGlvbi5ocmVmIDogdXJsXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1cmxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgZml4VXJsKHJlcXVlc3QudXJsKSwgdHJ1ZSlcblxuICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpIHtcbiAgICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgc3VwcG9ydC5hcnJheUJ1ZmZlclxuICAgICAgKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaXQgJiYgdHlwZW9mIGluaXQuaGVhZGVycyA9PT0gJ29iamVjdCcgJiYgIShpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzIHx8IChnLkhlYWRlcnMgJiYgaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgZy5IZWFkZXJzKSkpIHtcbiAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5pdC5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZXMucHVzaChub3JtYWxpemVOYW1lKG5hbWUpKVxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBub3JtYWxpemVWYWx1ZShpbml0LmhlYWRlcnNbbmFtZV0pKVxuICAgICAgfSlcbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsKSB7XG4gICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gIH0pXG59XG5cbmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxuXG5pZiAoIWcuZmV0Y2gpIHtcbiAgZy5mZXRjaCA9IGZldGNoXG4gIGcuSGVhZGVycyA9IEhlYWRlcnNcbiAgZy5SZXF1ZXN0ID0gUmVxdWVzdFxuICBnLlJlc3BvbnNlID0gUmVzcG9uc2Vcbn1cbiIsICJpbXBvcnQgJ3doYXR3Zy1mZXRjaCc7XG5cbmNvbnN0IHZlcnNpb24gPSBcIjAuNS4xMlwiO1xuXG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgUmVzcG9uc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3IsIHN0YXR1c19jb2RlKSB7XG4gICAgc3VwZXIoZXJyb3IpO1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLnN0YXR1c19jb2RlID0gc3RhdHVzX2NvZGU7XG4gICAgdGhpcy5uYW1lID0gXCJSZXNwb25zZUVycm9yXCI7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXNwb25zZUVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFib3J0YWJsZUFzeW5jSXRlcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihhYm9ydENvbnRyb2xsZXIsIGl0ciwgZG9uZUNhbGxiYWNrKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiYWJvcnRDb250cm9sbGVyXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIml0clwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJkb25lQ2FsbGJhY2tcIik7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgdGhpcy5pdHIgPSBpdHI7XG4gICAgdGhpcy5kb25lQ2FsbGJhY2sgPSBkb25lQ2FsbGJhY2s7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IG1lc3NhZ2Ugb2YgdGhpcy5pdHIpIHtcbiAgICAgIGlmIChcImVycm9yXCIgaW4gbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgICB9XG4gICAgICB5aWVsZCBtZXNzYWdlO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9uZSB8fCBtZXNzYWdlLnN0YXR1cyA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgdGhpcy5kb25lQ2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWQgbm90IHJlY2VpdmUgZG9uZSBvciBzdWNjZXNzIHJlc3BvbnNlIGluIHN0cmVhbS5cIik7XG4gIH1cbn1cbmNvbnN0IGNoZWNrT2sgPSBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBtZXNzYWdlID0gYEVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XG4gIGxldCBlcnJvckRhdGEgPSBudWxsO1xuICBpZiAocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik/LmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgIHRyeSB7XG4gICAgICBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBtZXNzYWdlID0gZXJyb3JEYXRhLmVycm9yIHx8IG1lc3NhZ2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIHBhcnNlIGVycm9yIHJlc3BvbnNlIGFzIEpTT05cIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkdldHRpbmcgdGV4dCBmcm9tIHJlc3BvbnNlXCIpO1xuICAgICAgY29uc3QgdGV4dFJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgbWVzc2FnZSA9IHRleHRSZXNwb25zZSB8fCBtZXNzYWdlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBnZXQgdGV4dCBmcm9tIGVycm9yIHJlc3BvbnNlXCIpO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgUmVzcG9uc2VFcnJvcihtZXNzYWdlLCByZXNwb25zZS5zdGF0dXMpO1xufTtcbmZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIGAke3dpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0udG9Mb3dlckNhc2UoKX0gQnJvd3Nlci8ke25hdmlnYXRvci51c2VyQWdlbnR9O2A7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gYCR7cHJvY2Vzcy5hcmNofSAke3Byb2Nlc3MucGxhdGZvcm19IE5vZGUuanMvJHtwcm9jZXNzLnZlcnNpb259YDtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmNvbnN0IGZldGNoV2l0aEhlYWRlcnMgPSBhc3luYyAoZmV0Y2gsIHVybCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGRlZmF1bHRIZWFkZXJzID0ge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgXCJVc2VyLUFnZW50XCI6IGBvbGxhbWEtanMvJHt2ZXJzaW9ufSAoJHtnZXRQbGF0Zm9ybSgpfSlgXG4gIH07XG4gIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgb3B0aW9ucy5oZWFkZXJzID0ge307XG4gIH1cbiAgY29uc3QgY3VzdG9tSGVhZGVycyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhvcHRpb25zLmhlYWRlcnMpLmZpbHRlcigoW2tleV0pID0+ICFPYmplY3Qua2V5cyhkZWZhdWx0SGVhZGVycykuc29tZSgoZGVmYXVsdEtleSkgPT4gZGVmYXVsdEtleS50b0xvd2VyQ2FzZSgpID09PSBrZXkudG9Mb3dlckNhc2UoKSkpXG4gICk7XG4gIG9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAuLi5kZWZhdWx0SGVhZGVycyxcbiAgICAuLi5jdXN0b21IZWFkZXJzXG4gIH07XG4gIHJldHVybiBmZXRjaCh1cmwsIG9wdGlvbnMpO1xufTtcbmNvbnN0IGdldCA9IGFzeW5jIChmZXRjaCwgaG9zdCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aEhlYWRlcnMoZmV0Y2gsIGhvc3QsIHtcbiAgICBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzXG4gIH0pO1xuICBhd2FpdCBjaGVja09rKHJlc3BvbnNlKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbmNvbnN0IHBvc3QgPSBhc3luYyAoZmV0Y2gsIGhvc3QsIGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgaXNSZWNvcmQgPSAoaW5wdXQpID0+IHtcbiAgICByZXR1cm4gaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGlucHV0KTtcbiAgfTtcbiAgY29uc3QgZm9ybWF0dGVkRGF0YSA9IGlzUmVjb3JkKGRhdGEpID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiBkYXRhO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aEhlYWRlcnMoZmV0Y2gsIGhvc3QsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGZvcm1hdHRlZERhdGEsXG4gICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwsXG4gICAgaGVhZGVyczogb3B0aW9ucz8uaGVhZGVyc1xuICB9KTtcbiAgYXdhaXQgY2hlY2tPayhyZXNwb25zZSk7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG5jb25zdCBkZWwgPSBhc3luYyAoZmV0Y2gsIGhvc3QsIGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhIZWFkZXJzKGZldGNoLCBob3N0LCB7XG4gICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnNcbiAgfSk7XG4gIGF3YWl0IGNoZWNrT2socmVzcG9uc2UpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuY29uc3QgcGFyc2VKU09OID0gYXN5bmMgZnVuY3Rpb24qIChpdHIpIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgY29uc3QgcmVhZGVyID0gaXRyLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSwgdmFsdWU6IGNodW5rIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYnVmZmVyICs9IGRlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICBjb25zdCBwYXJ0cyA9IGJ1ZmZlci5zcGxpdChcIlxcblwiKTtcbiAgICBidWZmZXIgPSBwYXJ0cy5wb3AoKSA/PyBcIlwiO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgSlNPTi5wYXJzZShwYXJ0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcImludmFsaWQganNvbjogXCIsIHBhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHBhcnQgb2YgYnVmZmVyLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigocCkgPT4gcCAhPT0gXCJcIikpIHtcbiAgICB0cnkge1xuICAgICAgeWllbGQgSlNPTi5wYXJzZShwYXJ0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiaW52YWxpZCBqc29uOiBcIiwgcGFydCk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgZm9ybWF0SG9zdCA9IChob3N0KSA9PiB7XG4gIGlmICghaG9zdCkge1xuICAgIHJldHVybiBcImh0dHA6Ly8xMjcuMC4wLjE6MTE0MzRcIjtcbiAgfVxuICBsZXQgaXNFeHBsaWNpdFByb3RvY29sID0gaG9zdC5pbmNsdWRlcyhcIjovL1wiKTtcbiAgaWYgKGhvc3Quc3RhcnRzV2l0aChcIjpcIikpIHtcbiAgICBob3N0ID0gYGh0dHA6Ly8xMjcuMC4wLjEke2hvc3R9YDtcbiAgICBpc0V4cGxpY2l0UHJvdG9jb2wgPSB0cnVlO1xuICB9XG4gIGlmICghaXNFeHBsaWNpdFByb3RvY29sKSB7XG4gICAgaG9zdCA9IGBodHRwOi8vJHtob3N0fWA7XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTChob3N0KTtcbiAgbGV0IHBvcnQgPSB1cmwucG9ydDtcbiAgaWYgKCFwb3J0KSB7XG4gICAgaWYgKCFpc0V4cGxpY2l0UHJvdG9jb2wpIHtcbiAgICAgIHBvcnQgPSBcIjExNDM0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcnQgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIjQ0M1wiIDogXCI4MFwiO1xuICAgIH1cbiAgfVxuICBsZXQgZm9ybWF0dGVkSG9zdCA9IGAke3VybC5wcm90b2NvbH0vLyR7dXJsLmhvc3RuYW1lfToke3BvcnR9JHt1cmwucGF0aG5hbWV9YDtcbiAgaWYgKGZvcm1hdHRlZEhvc3QuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgZm9ybWF0dGVkSG9zdCA9IGZvcm1hdHRlZEhvc3Quc2xpY2UoMCwgLTEpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZWRIb3N0O1xufTtcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xubGV0IE9sbGFtYSQxID0gY2xhc3MgT2xsYW1hIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbmZpZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmV0Y2hcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzXCIsIFtdKTtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGhvc3Q6IFwiXCIsXG4gICAgICBoZWFkZXJzOiBjb25maWc/LmhlYWRlcnNcbiAgICB9O1xuICAgIGlmICghY29uZmlnPy5wcm94eSkge1xuICAgICAgdGhpcy5jb25maWcuaG9zdCA9IGZvcm1hdEhvc3QoY29uZmlnPy5ob3N0ID8/IFwiaHR0cDovLzEyNy4wLjAuMToxMTQzNFwiKTtcbiAgICB9XG4gICAgdGhpcy5mZXRjaCA9IGNvbmZpZz8uZmV0Y2ggPz8gZmV0Y2g7XG4gIH1cbiAgLy8gQWJvcnQgYW55IG9uZ29pbmcgc3RyZWFtZWQgcmVxdWVzdHMgdG8gT2xsYW1hXG4gIGFib3J0KCkge1xuICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICAvKipcbiAgICogUHJvY2Vzc2VzIGEgcmVxdWVzdCB0byB0aGUgT2xsYW1hIHNlcnZlci4gSWYgdGhlIHJlcXVlc3QgaXMgc3RyZWFtYWJsZSwgaXQgd2lsbCByZXR1cm4gYVxuICAgKiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHRoZSByZXNwb25zZSBtZXNzYWdlcy4gT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgcmVzcG9uc2VcbiAgICogb2JqZWN0LlxuICAgKiBAcGFyYW0gZW5kcG9pbnQge3N0cmluZ30gLSBUaGUgZW5kcG9pbnQgdG8gc2VuZCB0aGUgcmVxdWVzdCB0by5cbiAgICogQHBhcmFtIHJlcXVlc3Qge29iamVjdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QgdG8gc2VuZCB0byB0aGUgZW5kcG9pbnQuXG4gICAqIEBwcm90ZWN0ZWQge1QgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFQ+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYSBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzXG4gICAqIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgcmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nIG9yIGlmIHRoZSByZXNwb25zZSBpcyBhbiBlcnJvci5cbiAgICogQHJldHVybnMge1Byb21pc2U8VCB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8VD4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYSBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHRoZSBzdHJlYW1lZCByZXNwb25zZS5cbiAgICovXG4gIGFzeW5jIHByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChlbmRwb2ludCwgcmVxdWVzdCkge1xuICAgIHJlcXVlc3Quc3RyZWFtID0gcmVxdWVzdC5zdHJlYW0gPz8gZmFsc2U7XG4gICAgY29uc3QgaG9zdCA9IGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS8ke2VuZHBvaW50fWA7XG4gICAgaWYgKHJlcXVlc3Quc3RyZWFtKSB7XG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGhvc3QsIHJlcXVlc3QsIHtcbiAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2UyLmJvZHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBib2R5XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRyID0gcGFyc2VKU09OKHJlc3BvbnNlMi5ib2R5KTtcbiAgICAgIGNvbnN0IGFib3J0YWJsZUFzeW5jSXRlcmF0b3IgPSBuZXcgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcihcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLFxuICAgICAgICBpdHIsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cy5pbmRleE9mKGFib3J0YWJsZUFzeW5jSXRlcmF0b3IpO1xuICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMucHVzaChhYm9ydGFibGVBc3luY0l0ZXJhdG9yKTtcbiAgICAgIHJldHVybiBhYm9ydGFibGVBc3luY0l0ZXJhdG9yO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgaG9zdCwgcmVxdWVzdCwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuY29kZXMgYW4gaW1hZ2UgdG8gYmFzZTY0IGlmIGl0IGlzIGEgVWludDhBcnJheS5cbiAgICogQHBhcmFtIGltYWdlIHtVaW50OEFycmF5IHwgc3RyaW5nfSAtIFRoZSBpbWFnZSB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gVGhlIGJhc2U2NCBlbmNvZGVkIGltYWdlLlxuICAgKi9cbiAgYXN5bmMgZW5jb2RlSW1hZ2UoaW1hZ2UpIHtcbiAgICBpZiAodHlwZW9mIGltYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaW1hZ2UpO1xuICAgICAgbGV0IGJ5dGVTdHJpbmcgPSBcIlwiO1xuICAgICAgY29uc3QgbGVuID0gdWludDhBcnJheS5ieXRlTGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBieXRlU3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhBcnJheVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnRvYShieXRlU3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSByZXNwb25zZSBmcm9tIGEgdGV4dCBwcm9tcHQuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtHZW5lcmF0ZVJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZW5lcmF0ZVJlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxHZW5lcmF0ZVJlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvclxuICAgKiBhbiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGUocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0LmltYWdlcykge1xuICAgICAgcmVxdWVzdC5pbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0LmltYWdlcy5tYXAodGhpcy5lbmNvZGVJbWFnZS5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcImdlbmVyYXRlXCIsIHJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBDaGF0cyB3aXRoIHRoZSBtb2RlbC4gVGhlIHJlcXVlc3Qgb2JqZWN0IGNhbiBjb250YWluIG1lc3NhZ2VzIHdpdGggaW1hZ2VzIHRoYXQgYXJlIGVpdGhlclxuICAgKiBVaW50OEFycmF5cyBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzLiBUaGUgaW1hZ2VzIHdpbGwgYmUgYmFzZTY0IGVuY29kZWQgYmVmb3JlIHNlbmRpbmcgdGhlXG4gICAqIHJlcXVlc3QuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtDaGF0UmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENoYXRSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8Q2hhdFJlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvciBhblxuICAgKiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgY2hhdChyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QubWVzc2FnZXMpIHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiByZXF1ZXN0Lm1lc3NhZ2VzKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmltYWdlcykge1xuICAgICAgICAgIG1lc3NhZ2UuaW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBtZXNzYWdlLmltYWdlcy5tYXAodGhpcy5lbmNvZGVJbWFnZS5iaW5kKHRoaXMpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwiY2hhdFwiLCByZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBtb2RlbCBmcm9tIGEgc3RyZWFtIG9mIGRhdGEuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtDcmVhdGVSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8UHJvZ3Jlc3NSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8UHJvZ3Jlc3NSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYSBzdHJlYW0gb2YgcHJvZ3Jlc3MgcmVzcG9uc2VzLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJjcmVhdGVcIiwge1xuICAgICAgLi4ucmVxdWVzdFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWxscyBhIG1vZGVsIGZyb20gdGhlIE9sbGFtYSByZWdpc3RyeS4gVGhlIHJlcXVlc3Qgb2JqZWN0IGNhbiBjb250YWluIGEgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlXG4gICAqIHJlc3BvbnNlIHNob3VsZCBiZSBzdHJlYW1lZC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge1B1bGxSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8UHJvZ3Jlc3NSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8UHJvZ3Jlc3NSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3JcbiAgICogYW4gQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIHB1bGwocmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcInB1bGxcIiwge1xuICAgICAgbmFtZTogcmVxdWVzdC5tb2RlbCxcbiAgICAgIHN0cmVhbTogcmVxdWVzdC5zdHJlYW0sXG4gICAgICBpbnNlY3VyZTogcmVxdWVzdC5pbnNlY3VyZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdXNoZXMgYSBtb2RlbCB0byB0aGUgT2xsYW1hIHJlZ2lzdHJ5LiBUaGUgcmVxdWVzdCBvYmplY3QgY2FuIGNvbnRhaW4gYSBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSBpZiB0aGVcbiAgICogcmVzcG9uc2Ugc2hvdWxkIGJlIHN0cmVhbWVkLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7UHVzaFJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm9ncmVzc1Jlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxQcm9ncmVzc1Jlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvclxuICAgKiBhbiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgcHVzaChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwicHVzaFwiLCB7XG4gICAgICBuYW1lOiByZXF1ZXN0Lm1vZGVsLFxuICAgICAgc3RyZWFtOiByZXF1ZXN0LnN0cmVhbSxcbiAgICAgIGluc2VjdXJlOiByZXF1ZXN0Lmluc2VjdXJlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBtb2RlbCBmcm9tIHRoZSBzZXJ2ZXIuIFRoZSByZXF1ZXN0IG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgbmFtZSBvZiB0aGUgbW9kZWwgdG9cbiAgICogZGVsZXRlLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7RGVsZXRlUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFN0YXR1c1Jlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlKHJlcXVlc3QpIHtcbiAgICBhd2FpdCBkZWwoXG4gICAgICB0aGlzLmZldGNoLFxuICAgICAgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2RlbGV0ZWAsXG4gICAgICB7IG5hbWU6IHJlcXVlc3QubW9kZWwgfSxcbiAgICAgIHsgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVycyB9XG4gICAgKTtcbiAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH07XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhIG1vZGVsIGZyb20gb25lIG5hbWUgdG8gYW5vdGhlci4gVGhlIHJlcXVlc3Qgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBuYW1lIG9mIHRoZVxuICAgKiBtb2RlbCB0byBjb3B5IGFuZCB0aGUgbmV3IG5hbWUuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtDb3B5UmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFN0YXR1c1Jlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgY29weShyZXF1ZXN0KSB7XG4gICAgYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvY29weWAsIHsgLi4ucmVxdWVzdCB9LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9O1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgbW9kZWxzIG9uIHRoZSBzZXJ2ZXIuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPExpc3RSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZy5cbiAgICovXG4gIGFzeW5jIGxpc3QoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL3RhZ3NgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgdGhlIG1ldGFkYXRhIG9mIGEgbW9kZWwuIFRoZSByZXF1ZXN0IG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgbmFtZSBvZiB0aGUgbW9kZWwuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtTaG93UmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNob3dSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIHNob3cocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvc2hvd2AsIHtcbiAgICAgIC4uLnJlcXVlc3RcbiAgICB9LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRW1iZWRzIHRleHQgaW5wdXQgaW50byB2ZWN0b3JzLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7RW1iZWRSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8RW1iZWRSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGVtYmVkKHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2VtYmVkYCwge1xuICAgICAgLi4ucmVxdWVzdFxuICAgIH0sIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBFbWJlZHMgYSB0ZXh0IHByb21wdCBpbnRvIGEgdmVjdG9yLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7RW1iZWRkaW5nc1JlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbWJlZGRpbmdzUmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBlbWJlZGRpbmdzKHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2VtYmVkZGluZ3NgLCB7XG4gICAgICAuLi5yZXF1ZXN0XG4gICAgfSwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIHRoZSBydW5uaW5nIG1vZGVscyBvbiB0aGUgc2VydmVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPExpc3RSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZy5cbiAgICovXG4gIGFzeW5jIHBzKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9wc2AsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG59O1xuY29uc3QgYnJvd3NlciA9IG5ldyBPbGxhbWEkMSgpO1xuXG5leHBvcnQgeyBPbGxhbWEkMSBhcyBPbGxhbWEsIGJyb3dzZXIgYXMgZGVmYXVsdCB9O1xuIiwgIi8qIVxuICogbXVzdGFjaGUuanMgLSBMb2dpYy1sZXNzIHt7bXVzdGFjaGV9fSB0ZW1wbGF0ZXMgd2l0aCBKYXZhU2NyaXB0XG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzXG4gKi9cblxudmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5UG9seWZpbGwgKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIE1vcmUgY29ycmVjdCB0eXBlb2Ygc3RyaW5nIGhhbmRsaW5nIGFycmF5XG4gKiB3aGljaCBub3JtYWxseSByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuICovXG5mdW5jdGlvbiB0eXBlU3RyIChvYmopIHtcbiAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdhcnJheScgOiB0eXBlb2Ygb2JqO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAgKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG59XG5cbi8qKlxuICogTnVsbCBzYWZlIHdheSBvZiBjaGVja2luZyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QsXG4gKiBpbmNsdWRpbmcgaXRzIHByb3RvdHlwZSwgaGFzIGEgZ2l2ZW4gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gaGFzUHJvcGVydHkgKG9iaiwgcHJvcE5hbWUpIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIChwcm9wTmFtZSBpbiBvYmopO1xufVxuXG4vKipcbiAqIFNhZmUgd2F5IG9mIGRldGVjdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gdGhpbmcgaXMgYSBwcmltaXRpdmUgYW5kXG4gKiB3aGV0aGVyIGl0IGhhcyB0aGUgZ2l2ZW4gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gcHJpbWl0aXZlSGFzT3duUHJvcGVydHkgKHByaW1pdGl2ZSwgcHJvcE5hbWUpIHtcbiAgcmV0dXJuIChcbiAgICBwcmltaXRpdmUgIT0gbnVsbFxuICAgICYmIHR5cGVvZiBwcmltaXRpdmUgIT09ICdvYmplY3QnXG4gICAgJiYgcHJpbWl0aXZlLmhhc093blByb3BlcnR5XG4gICAgJiYgcHJpbWl0aXZlLmhhc093blByb3BlcnR5KHByb3BOYW1lKVxuICApO1xufVxuXG4vLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2lzc3Vlcy5hcGFjaGUub3JnL2ppcmEvYnJvd3NlL0NPVUNIREItNTc3XG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4OVxudmFyIHJlZ0V4cFRlc3QgPSBSZWdFeHAucHJvdG90eXBlLnRlc3Q7XG5mdW5jdGlvbiB0ZXN0UmVnRXhwIChyZSwgc3RyaW5nKSB7XG4gIHJldHVybiByZWdFeHBUZXN0LmNhbGwocmUsIHN0cmluZyk7XG59XG5cbnZhciBub25TcGFjZVJlID0gL1xcUy87XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKHN0cmluZykge1xuICByZXR1cm4gIXRlc3RSZWdFeHAobm9uU3BhY2VSZSwgc3RyaW5nKTtcbn1cblxudmFyIGVudGl0eU1hcCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7JyxcbiAgJy8nOiAnJiN4MkY7JyxcbiAgJ2AnOiAnJiN4NjA7JyxcbiAgJz0nOiAnJiN4M0Q7J1xufTtcblxuZnVuY3Rpb24gZXNjYXBlSHRtbCAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC9bJjw+XCInYD1cXC9dL2csIGZ1bmN0aW9uIGZyb21FbnRpdHlNYXAgKHMpIHtcbiAgICByZXR1cm4gZW50aXR5TWFwW3NdO1xuICB9KTtcbn1cblxudmFyIHdoaXRlUmUgPSAvXFxzKi87XG52YXIgc3BhY2VSZSA9IC9cXHMrLztcbnZhciBlcXVhbHNSZSA9IC9cXHMqPS87XG52YXIgY3VybHlSZSA9IC9cXHMqXFx9LztcbnZhciB0YWdSZSA9IC8jfFxcXnxcXC98PnxcXHt8Jnw9fCEvO1xuXG4vKipcbiAqIEJyZWFrcyB1cCB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBzdHJpbmcgaW50byBhIHRyZWUgb2YgdG9rZW5zLiBJZiB0aGUgYHRhZ3NgXG4gKiBhcmd1bWVudCBpcyBnaXZlbiBoZXJlIGl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d28gc3RyaW5nIHZhbHVlczogdGhlXG4gKiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy4gWyBcIjwlXCIsIFwiJT5cIiBdKS4gT2ZcbiAqIGNvdXJzZSwgdGhlIGRlZmF1bHQgaXMgdG8gdXNlIG11c3RhY2hlcyAoaS5lLiBtdXN0YWNoZS50YWdzKS5cbiAqXG4gKiBBIHRva2VuIGlzIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgNCBlbGVtZW50cy4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlXG4gKiBtdXN0YWNoZSBzeW1ib2wgdGhhdCB3YXMgdXNlZCBpbnNpZGUgdGhlIHRhZywgZS5nLiBcIiNcIiBvciBcIiZcIi4gSWYgdGhlIHRhZ1xuICogZGlkIG5vdCBjb250YWluIGEgc3ltYm9sIChpLmUuIHt7bXlWYWx1ZX19KSB0aGlzIGVsZW1lbnQgaXMgXCJuYW1lXCIuIEZvclxuICogYWxsIHRleHQgdGhhdCBhcHBlYXJzIG91dHNpZGUgYSBzeW1ib2wgdGhpcyBlbGVtZW50IGlzIFwidGV4dFwiLlxuICpcbiAqIFRoZSBzZWNvbmQgZWxlbWVudCBvZiBhIHRva2VuIGlzIGl0cyBcInZhbHVlXCIuIEZvciBtdXN0YWNoZSB0YWdzIHRoaXMgaXNcbiAqIHdoYXRldmVyIGVsc2Ugd2FzIGluc2lkZSB0aGUgdGFnIGJlc2lkZXMgdGhlIG9wZW5pbmcgc3ltYm9sLiBGb3IgdGV4dCB0b2tlbnNcbiAqIHRoaXMgaXMgdGhlIHRleHQgaXRzZWxmLlxuICpcbiAqIFRoZSB0aGlyZCBhbmQgZm91cnRoIGVsZW1lbnRzIG9mIHRoZSB0b2tlbiBhcmUgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyxcbiAqIHJlc3BlY3RpdmVseSwgb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cbiAqXG4gKiBUb2tlbnMgdGhhdCBhcmUgdGhlIHJvb3Qgbm9kZSBvZiBhIHN1YnRyZWUgY29udGFpbiB0d28gbW9yZSBlbGVtZW50czogMSkgYW5cbiAqIGFycmF5IG9mIHRva2VucyBpbiB0aGUgc3VidHJlZSBhbmQgMikgdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBhdFxuICogd2hpY2ggdGhlIGNsb3NpbmcgdGFnIGZvciB0aGF0IHNlY3Rpb24gYmVnaW5zLlxuICpcbiAqIFRva2VucyBmb3IgcGFydGlhbHMgYWxzbyBjb250YWluIHR3byBtb3JlIGVsZW1lbnRzOiAxKSBhIHN0cmluZyB2YWx1ZSBvZlxuICogaW5kZW5kYXRpb24gcHJpb3IgdG8gdGhhdCB0YWcgYW5kIDIpIHRoZSBpbmRleCBvZiB0aGF0IHRhZyBvbiB0aGF0IGxpbmUgLVxuICogZWcgYSB2YWx1ZSBvZiAyIGluZGljYXRlcyB0aGUgcGFydGlhbCBpcyB0aGUgdGhpcmQgdGFnIG9uIHRoaXMgbGluZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgaWYgKCF0ZW1wbGF0ZSlcbiAgICByZXR1cm4gW107XG4gIHZhciBsaW5lSGFzTm9uU3BhY2UgPSBmYWxzZTtcbiAgdmFyIHNlY3Rpb25zID0gW107ICAgICAvLyBTdGFjayB0byBob2xkIHNlY3Rpb24gdG9rZW5zXG4gIHZhciB0b2tlbnMgPSBbXTsgICAgICAgLy8gQnVmZmVyIHRvIGhvbGQgdGhlIHRva2Vuc1xuICB2YXIgc3BhY2VzID0gW107ICAgICAgIC8vIEluZGljZXMgb2Ygd2hpdGVzcGFjZSB0b2tlbnMgb24gdGhlIGN1cnJlbnQgbGluZVxuICB2YXIgaGFzVGFnID0gZmFsc2U7ICAgIC8vIElzIHRoZXJlIGEge3t0YWd9fSBvbiB0aGUgY3VycmVudCBsaW5lP1xuICB2YXIgbm9uU3BhY2UgPSBmYWxzZTsgIC8vIElzIHRoZXJlIGEgbm9uLXNwYWNlIGNoYXIgb24gdGhlIGN1cnJlbnQgbGluZT9cbiAgdmFyIGluZGVudGF0aW9uID0gJyc7ICAvLyBUcmFja3MgaW5kZW50YXRpb24gZm9yIHRhZ3MgdGhhdCB1c2UgaXRcbiAgdmFyIHRhZ0luZGV4ID0gMDsgICAgICAvLyBTdG9yZXMgYSBjb3VudCBvZiBudW1iZXIgb2YgdGFncyBlbmNvdW50ZXJlZCBvbiBhIGxpbmVcblxuICAvLyBTdHJpcHMgYWxsIHdoaXRlc3BhY2UgdG9rZW5zIGFycmF5IGZvciB0aGUgY3VycmVudCBsaW5lXG4gIC8vIGlmIHRoZXJlIHdhcyBhIHt7I3RhZ319IG9uIGl0IGFuZCBvdGhlcndpc2Ugb25seSBzcGFjZS5cbiAgZnVuY3Rpb24gc3RyaXBTcGFjZSAoKSB7XG4gICAgaWYgKGhhc1RhZyAmJiAhbm9uU3BhY2UpIHtcbiAgICAgIHdoaWxlIChzcGFjZXMubGVuZ3RoKVxuICAgICAgICBkZWxldGUgdG9rZW5zW3NwYWNlcy5wb3AoKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNwYWNlcyA9IFtdO1xuICAgIH1cblxuICAgIGhhc1RhZyA9IGZhbHNlO1xuICAgIG5vblNwYWNlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgb3BlbmluZ1RhZ1JlLCBjbG9zaW5nVGFnUmUsIGNsb3NpbmdDdXJseVJlO1xuICBmdW5jdGlvbiBjb21waWxlVGFncyAodGFnc1RvQ29tcGlsZSkge1xuICAgIGlmICh0eXBlb2YgdGFnc1RvQ29tcGlsZSA9PT0gJ3N0cmluZycpXG4gICAgICB0YWdzVG9Db21waWxlID0gdGFnc1RvQ29tcGlsZS5zcGxpdChzcGFjZVJlLCAyKTtcblxuICAgIGlmICghaXNBcnJheSh0YWdzVG9Db21waWxlKSB8fCB0YWdzVG9Db21waWxlLmxlbmd0aCAhPT0gMilcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWdzOiAnICsgdGFnc1RvQ29tcGlsZSk7XG5cbiAgICBvcGVuaW5nVGFnUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzBdKSArICdcXFxccyonKTtcbiAgICBjbG9zaW5nVGFnUmUgPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMV0pKTtcbiAgICBjbG9zaW5nQ3VybHlSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAoJ30nICsgdGFnc1RvQ29tcGlsZVsxXSkpO1xuICB9XG5cbiAgY29tcGlsZVRhZ3ModGFncyB8fCBtdXN0YWNoZS50YWdzKTtcblxuICB2YXIgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRlbXBsYXRlKTtcblxuICB2YXIgc3RhcnQsIHR5cGUsIHZhbHVlLCBjaHIsIHRva2VuLCBvcGVuU2VjdGlvbjtcbiAgd2hpbGUgKCFzY2FubmVyLmVvcygpKSB7XG4gICAgc3RhcnQgPSBzY2FubmVyLnBvcztcblxuICAgIC8vIE1hdGNoIGFueSB0ZXh0IGJldHdlZW4gdGFncy5cbiAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKG9wZW5pbmdUYWdSZSk7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaSA8IHZhbHVlTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2hyID0gdmFsdWUuY2hhckF0KGkpO1xuXG4gICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2hyKSkge1xuICAgICAgICAgIHNwYWNlcy5wdXNoKHRva2Vucy5sZW5ndGgpO1xuICAgICAgICAgIGluZGVudGF0aW9uICs9IGNocjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgICAgICAgbGluZUhhc05vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICBpbmRlbnRhdGlvbiArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbnMucHVzaChbICd0ZXh0JywgY2hyLCBzdGFydCwgc3RhcnQgKyAxIF0pO1xuICAgICAgICBzdGFydCArPSAxO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciB3aGl0ZXNwYWNlIG9uIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAgIGlmIChjaHIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgc3RyaXBTcGFjZSgpO1xuICAgICAgICAgIGluZGVudGF0aW9uID0gJyc7XG4gICAgICAgICAgdGFnSW5kZXggPSAwO1xuICAgICAgICAgIGxpbmVIYXNOb25TcGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWF0Y2ggdGhlIG9wZW5pbmcgdGFnLlxuICAgIGlmICghc2Nhbm5lci5zY2FuKG9wZW5pbmdUYWdSZSkpXG4gICAgICBicmVhaztcblxuICAgIGhhc1RhZyA9IHRydWU7XG5cbiAgICAvLyBHZXQgdGhlIHRhZyB0eXBlLlxuICAgIHR5cGUgPSBzY2FubmVyLnNjYW4odGFnUmUpIHx8ICduYW1lJztcbiAgICBzY2FubmVyLnNjYW4od2hpdGVSZSk7XG5cbiAgICAvLyBHZXQgdGhlIHRhZyB2YWx1ZS5cbiAgICBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGVxdWFsc1JlKTtcbiAgICAgIHNjYW5uZXIuc2NhbihlcXVhbHNSZSk7XG4gICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3snKSB7XG4gICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdDdXJseVJlKTtcbiAgICAgIHNjYW5uZXIuc2NhbihjdXJseVJlKTtcbiAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICB0eXBlID0gJyYnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgfVxuXG4gICAgLy8gTWF0Y2ggdGhlIGNsb3NpbmcgdGFnLlxuICAgIGlmICghc2Nhbm5lci5zY2FuKGNsb3NpbmdUYWdSZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHRhZyBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgaWYgKHR5cGUgPT0gJz4nKSB7XG4gICAgICB0b2tlbiA9IFsgdHlwZSwgdmFsdWUsIHN0YXJ0LCBzY2FubmVyLnBvcywgaW5kZW50YXRpb24sIHRhZ0luZGV4LCBsaW5lSGFzTm9uU3BhY2UgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW4gPSBbIHR5cGUsIHZhbHVlLCBzdGFydCwgc2Nhbm5lci5wb3MgXTtcbiAgICB9XG4gICAgdGFnSW5kZXgrKztcbiAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cbiAgICBpZiAodHlwZSA9PT0gJyMnIHx8IHR5cGUgPT09ICdeJykge1xuICAgICAgc2VjdGlvbnMucHVzaCh0b2tlbik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnLycpIHtcbiAgICAgIC8vIENoZWNrIHNlY3Rpb24gbmVzdGluZy5cbiAgICAgIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgICAgIGlmICghb3BlblNlY3Rpb24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5vcGVuZWQgc2VjdGlvbiBcIicgKyB2YWx1ZSArICdcIiBhdCAnICsgc3RhcnQpO1xuXG4gICAgICBpZiAob3BlblNlY3Rpb25bMV0gIT09IHZhbHVlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHN0YXJ0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICduYW1lJyB8fCB0eXBlID09PSAneycgfHwgdHlwZSA9PT0gJyYnKSB7XG4gICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgIC8vIFNldCB0aGUgdGFncyBmb3IgdGhlIG5leHQgdGltZSBhcm91bmQuXG4gICAgICBjb21waWxlVGFncyh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc3RyaXBTcGFjZSgpO1xuXG4gIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gb3BlbiBzZWN0aW9ucyB3aGVuIHdlJ3JlIGRvbmUuXG4gIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgaWYgKG9wZW5TZWN0aW9uKVxuICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gIHJldHVybiBuZXN0VG9rZW5zKHNxdWFzaFRva2Vucyh0b2tlbnMpKTtcbn1cblxuLyoqXG4gKiBDb21iaW5lcyB0aGUgdmFsdWVzIG9mIGNvbnNlY3V0aXZlIHRleHQgdG9rZW5zIGluIHRoZSBnaXZlbiBgdG9rZW5zYCBhcnJheVxuICogdG8gYSBzaW5nbGUgdG9rZW4uXG4gKi9cbmZ1bmN0aW9uIHNxdWFzaFRva2VucyAodG9rZW5zKSB7XG4gIHZhciBzcXVhc2hlZFRva2VucyA9IFtdO1xuXG4gIHZhciB0b2tlbiwgbGFzdFRva2VuO1xuICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGlmICh0b2tlblswXSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbiAmJiBsYXN0VG9rZW5bMF0gPT09ICd0ZXh0Jykge1xuICAgICAgICBsYXN0VG9rZW5bMV0gKz0gdG9rZW5bMV07XG4gICAgICAgIGxhc3RUb2tlblszXSA9IHRva2VuWzNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3F1YXNoZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2VuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzcXVhc2hlZFRva2Vucztcbn1cblxuLyoqXG4gKiBGb3JtcyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgaW50byBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZSB3aGVyZVxuICogdG9rZW5zIHRoYXQgcmVwcmVzZW50IGEgc2VjdGlvbiBoYXZlIHR3byBhZGRpdGlvbmFsIGl0ZW1zOiAxKSBhbiBhcnJheSBvZlxuICogYWxsIHRva2VucyB0aGF0IGFwcGVhciBpbiB0aGF0IHNlY3Rpb24gYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWxcbiAqIHRlbXBsYXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoYXQgc2VjdGlvbi5cbiAqL1xuZnVuY3Rpb24gbmVzdFRva2VucyAodG9rZW5zKSB7XG4gIHZhciBuZXN0ZWRUb2tlbnMgPSBbXTtcbiAgdmFyIGNvbGxlY3RvciA9IG5lc3RlZFRva2VucztcbiAgdmFyIHNlY3Rpb25zID0gW107XG5cbiAgdmFyIHRva2VuLCBzZWN0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICBjYXNlICcjJzpcbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgICBjb2xsZWN0b3IgPSB0b2tlbls0XSA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICBzZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG4gICAgICAgIHNlY3Rpb25bNV0gPSB0b2tlblsyXTtcbiAgICAgICAgY29sbGVjdG9yID0gc2VjdGlvbnMubGVuZ3RoID4gMCA/IHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdWzRdIDogbmVzdGVkVG9rZW5zO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVzdGVkVG9rZW5zO1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIHN0cmluZyBzY2FubmVyIHRoYXQgaXMgdXNlZCBieSB0aGUgdGVtcGxhdGUgcGFyc2VyIHRvIGZpbmRcbiAqIHRva2VucyBpbiB0ZW1wbGF0ZSBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBTY2FubmVyIChzdHJpbmcpIHtcbiAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gIHRoaXMudGFpbCA9IHN0cmluZztcbiAgdGhpcy5wb3MgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB0YWlsIGlzIGVtcHR5IChlbmQgb2Ygc3RyaW5nKS5cbiAqL1xuU2Nhbm5lci5wcm90b3R5cGUuZW9zID0gZnVuY3Rpb24gZW9zICgpIHtcbiAgcmV0dXJuIHRoaXMudGFpbCA9PT0gJyc7XG59O1xuXG4vKipcbiAqIFRyaWVzIHRvIG1hdGNoIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gKiBSZXR1cm5zIHRoZSBtYXRjaGVkIHRleHQgaWYgaXQgY2FuIG1hdGNoLCB0aGUgZW1wdHkgc3RyaW5nIG90aGVyd2lzZS5cbiAqL1xuU2Nhbm5lci5wcm90b3R5cGUuc2NhbiA9IGZ1bmN0aW9uIHNjYW4gKHJlKSB7XG4gIHZhciBtYXRjaCA9IHRoaXMudGFpbC5tYXRjaChyZSk7XG5cbiAgaWYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCAhPT0gMClcbiAgICByZXR1cm4gJyc7XG5cbiAgdmFyIHN0cmluZyA9IG1hdGNoWzBdO1xuXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCk7XG4gIHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG5cbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbi8qKlxuICogU2tpcHMgYWxsIHRleHQgdW50aWwgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBjYW4gYmUgbWF0Y2hlZC4gUmV0dXJuc1xuICogdGhlIHNraXBwZWQgc3RyaW5nLCB3aGljaCBpcyB0aGUgZW50aXJlIHRhaWwgaWYgbm8gbWF0Y2ggY2FuIGJlIG1hZGUuXG4gKi9cblNjYW5uZXIucHJvdG90eXBlLnNjYW5VbnRpbCA9IGZ1bmN0aW9uIHNjYW5VbnRpbCAocmUpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy50YWlsLnNlYXJjaChyZSksIG1hdGNoO1xuXG4gIHN3aXRjaCAoaW5kZXgpIHtcbiAgICBjYXNlIC0xOlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWw7XG4gICAgICB0aGlzLnRhaWwgPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMDpcbiAgICAgIG1hdGNoID0gJyc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWwuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoaW5kZXgpO1xuICB9XG5cbiAgdGhpcy5wb3MgKz0gbWF0Y2gubGVuZ3RoO1xuXG4gIHJldHVybiBtYXRjaDtcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJlbmRlcmluZyBjb250ZXh0IGJ5IHdyYXBwaW5nIGEgdmlldyBvYmplY3QgYW5kXG4gKiBtYWludGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIENvbnRleHQgKHZpZXcsIHBhcmVudENvbnRleHQpIHtcbiAgdGhpcy52aWV3ID0gdmlldztcbiAgdGhpcy5jYWNoZSA9IHsgJy4nOiB0aGlzLnZpZXcgfTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnRDb250ZXh0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY29udGV4dCB1c2luZyB0aGUgZ2l2ZW4gdmlldyB3aXRoIHRoaXMgY29udGV4dFxuICogYXMgdGhlIHBhcmVudC5cbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKHZpZXcpIHtcbiAgcmV0dXJuIG5ldyBDb250ZXh0KHZpZXcsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGlzIGNvbnRleHQsIHRyYXZlcnNpbmdcbiAqIHVwIHRoZSBjb250ZXh0IGhpZXJhcmNoeSBpZiB0aGUgdmFsdWUgaXMgYWJzZW50IGluIHRoaXMgY29udGV4dCdzIHZpZXcuXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cCAobmFtZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG4gIHZhciB2YWx1ZTtcbiAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgdmFsdWUgPSBjYWNoZVtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsIGludGVybWVkaWF0ZVZhbHVlLCBuYW1lcywgaW5kZXgsIGxvb2t1cEhpdCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgICAgaW50ZXJtZWRpYXRlVmFsdWUgPSBjb250ZXh0LnZpZXc7XG4gICAgICAgIG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzaW5nIHRoZSBkb3Qgbm90aW9uIHBhdGggaW4gYG5hbWVgLCB3ZSBkZXNjZW5kIHRocm91Z2ggdGhlXG4gICAgICAgICAqIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBiZSBjZXJ0YWluIHRoYXQgdGhlIGxvb2t1cCBoYXMgYmVlbiBzdWNjZXNzZnVsLCB3ZSBoYXZlIHRvXG4gICAgICAgICAqIGNoZWNrIGlmIHRoZSBsYXN0IG9iamVjdCBpbiB0aGUgcGF0aCBhY3R1YWxseSBoYXMgdGhlIHByb3BlcnR5XG4gICAgICAgICAqIHdlIGFyZSBsb29raW5nIGZvci4gV2Ugc3RvcmUgdGhlIHJlc3VsdCBpbiBgbG9va3VwSGl0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBzcGVjaWFsbHkgbmVjZXNzYXJ5IGZvciB3aGVuIHRoZSB2YWx1ZSBoYXMgYmVlbiBzZXQgdG9cbiAgICAgICAgICogYHVuZGVmaW5lZGAgYW5kIHdlIHdhbnQgdG8gYXZvaWQgbG9va2luZyB1cCBwYXJlbnQgY29udGV4dHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIGRvdCBub3RhdGlvbiBpcyB1c2VkLCB3ZSBjb25zaWRlciB0aGUgbG9va3VwXG4gICAgICAgICAqIHRvIGJlIHN1Y2Nlc3NmdWwgZXZlbiBpZiB0aGUgbGFzdCBcIm9iamVjdFwiIGluIHRoZSBwYXRoIGlzXG4gICAgICAgICAqIG5vdCBhY3R1YWxseSBhbiBvYmplY3QgYnV0IGEgcHJpbWl0aXZlIChlLmcuLCBhIHN0cmluZywgb3IgYW5cbiAgICAgICAgICogaW50ZWdlciksIGJlY2F1c2UgaXQgaXMgc29tZXRpbWVzIHVzZWZ1bCB0byBhY2Nlc3MgYSBwcm9wZXJ0eVxuICAgICAgICAgKiBvZiBhbiBhdXRvYm94ZWQgcHJpbWl0aXZlLCBzdWNoIGFzIHRoZSBsZW5ndGggb2YgYSBzdHJpbmcuXG4gICAgICAgICAqKi9cbiAgICAgICAgd2hpbGUgKGludGVybWVkaWF0ZVZhbHVlICE9IG51bGwgJiYgaW5kZXggPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IG5hbWVzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICBsb29rdXBIaXQgPSAoXG4gICAgICAgICAgICAgIGhhc1Byb3BlcnR5KGludGVybWVkaWF0ZVZhbHVlLCBuYW1lc1tpbmRleF0pXG4gICAgICAgICAgICAgIHx8IHByaW1pdGl2ZUhhc093blByb3BlcnR5KGludGVybWVkaWF0ZVZhbHVlLCBuYW1lc1tpbmRleF0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgaW50ZXJtZWRpYXRlVmFsdWUgPSBpbnRlcm1lZGlhdGVWYWx1ZVtuYW1lc1tpbmRleCsrXV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybWVkaWF0ZVZhbHVlID0gY29udGV4dC52aWV3W25hbWVdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IGNoZWNraW5nIGFnYWluc3QgYGhhc1Byb3BlcnR5YCwgd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYCBpZlxuICAgICAgICAgKiBgY29udGV4dC52aWV3YCBpcyBub3QgYW4gb2JqZWN0LiBEZWxpYmVyYXRlbHkgb21pdHRpbmcgdGhlIGNoZWNrXG4gICAgICAgICAqIGFnYWluc3QgYHByaW1pdGl2ZUhhc093blByb3BlcnR5YCBpZiBkb3Qgbm90YXRpb24gaXMgbm90IHVzZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbnNpZGVyIHRoaXMgZXhhbXBsZTpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIE11c3RhY2hlLnJlbmRlcihcIlRoZSBsZW5ndGggb2YgYSBmb290YmFsbCBmaWVsZCBpcyB7eyNsZW5ndGh9fXt7bGVuZ3RofX17ey9sZW5ndGh9fS5cIiwge2xlbmd0aDogXCIxMDAgeWFyZHNcIn0pXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB3ZSB3ZXJlIHRvIGNoZWNrIGFsc28gYWdhaW5zdCBgcHJpbWl0aXZlSGFzT3duUHJvcGVydHlgLCBhcyB3ZSBkb1xuICAgICAgICAgKiBpbiB0aGUgZG90IG5vdGF0aW9uIGNhc2UsIHRoZW4gcmVuZGVyIGNhbGwgd291bGQgcmV0dXJuOlxuICAgICAgICAgKlxuICAgICAgICAgKiBcIlRoZSBsZW5ndGggb2YgYSBmb290YmFsbCBmaWVsZCBpcyA5LlwiXG4gICAgICAgICAqXG4gICAgICAgICAqIHJhdGhlciB0aGFuIHRoZSBleHBlY3RlZDpcbiAgICAgICAgICpcbiAgICAgICAgICogXCJUaGUgbGVuZ3RoIG9mIGEgZm9vdGJhbGwgZmllbGQgaXMgMTAwIHlhcmRzLlwiXG4gICAgICAgICAqKi9cbiAgICAgICAgbG9va3VwSGl0ID0gaGFzUHJvcGVydHkoY29udGV4dC52aWV3LCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvb2t1cEhpdCkge1xuICAgICAgICB2YWx1ZSA9IGludGVybWVkaWF0ZVZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50O1xuICAgIH1cblxuICAgIGNhY2hlW25hbWVdID0gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpXG4gICAgdmFsdWUgPSB2YWx1ZS5jYWxsKHRoaXMudmlldyk7XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBBIFdyaXRlciBrbm93cyBob3cgdG8gdGFrZSBhIHN0cmVhbSBvZiB0b2tlbnMgYW5kIHJlbmRlciB0aGVtIHRvIGFcbiAqIHN0cmluZywgZ2l2ZW4gYSBjb250ZXh0LiBJdCBhbHNvIG1haW50YWlucyBhIGNhY2hlIG9mIHRlbXBsYXRlcyB0b1xuICogYXZvaWQgdGhlIG5lZWQgdG8gcGFyc2UgdGhlIHNhbWUgdGVtcGxhdGUgdHdpY2UuXG4gKi9cbmZ1bmN0aW9uIFdyaXRlciAoKSB7XG4gIHRoaXMudGVtcGxhdGVDYWNoZSA9IHtcbiAgICBfY2FjaGU6IHt9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0IChrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLl9jYWNoZVtrZXldID0gdmFsdWU7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVba2V5XTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhpcyB3cml0ZXIuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICBpZiAodHlwZW9mIHRoaXMudGVtcGxhdGVDYWNoZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnRlbXBsYXRlQ2FjaGUuY2xlYXIoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQYXJzZXMgYW5kIGNhY2hlcyB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGB0YWdzYCBvclxuICogYG11c3RhY2hlLnRhZ3NgIGlmIGB0YWdzYCBpcyBvbWl0dGVkLCAgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHRva2Vuc1xuICogdGhhdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcGFyc2UuXG4gKi9cbldyaXRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy50ZW1wbGF0ZUNhY2hlO1xuICB2YXIgY2FjaGVLZXkgPSB0ZW1wbGF0ZSArICc6JyArICh0YWdzIHx8IG11c3RhY2hlLnRhZ3MpLmpvaW4oJzonKTtcbiAgdmFyIGlzQ2FjaGVFbmFibGVkID0gdHlwZW9mIGNhY2hlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIHRva2VucyA9IGlzQ2FjaGVFbmFibGVkID8gY2FjaGUuZ2V0KGNhY2hlS2V5KSA6IHVuZGVmaW5lZDtcblxuICBpZiAodG9rZW5zID09IHVuZGVmaW5lZCkge1xuICAgIHRva2VucyA9IHBhcnNlVGVtcGxhdGUodGVtcGxhdGUsIHRhZ3MpO1xuICAgIGlzQ2FjaGVFbmFibGVkICYmIGNhY2hlLnNldChjYWNoZUtleSwgdG9rZW5zKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zO1xufTtcblxuLyoqXG4gKiBIaWdoLWxldmVsIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHdpdGhcbiAqIHRoZSBnaXZlbiBgdmlld2AuXG4gKlxuICogVGhlIG9wdGlvbmFsIGBwYXJ0aWFsc2AgYXJndW1lbnQgbWF5IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICogbmFtZXMgYW5kIHRlbXBsYXRlcyBvZiBwYXJ0aWFscyB0aGF0IGFyZSB1c2VkIGluIHRoZSB0ZW1wbGF0ZS4gSXQgbWF5XG4gKiBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGxvYWQgcGFydGlhbCB0ZW1wbGF0ZXMgb24gdGhlIGZseVxuICogdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudDogdGhlIG5hbWUgb2YgdGhlIHBhcnRpYWwuXG4gKlxuICogSWYgdGhlIG9wdGlvbmFsIGBjb25maWdgIGFyZ3VtZW50IGlzIGdpdmVuIGhlcmUsIHRoZW4gaXQgc2hvdWxkIGJlIGFuXG4gKiBvYmplY3Qgd2l0aCBhIGB0YWdzYCBhdHRyaWJ1dGUgb3IgYW4gYGVzY2FwZWAgYXR0cmlidXRlIG9yIGJvdGguXG4gKiBJZiBhbiBhcnJheSBpcyBwYXNzZWQsIHRoZW4gaXQgd2lsbCBiZSBpbnRlcnByZXRlZCB0aGUgc2FtZSB3YXkgYXNcbiAqIGEgYHRhZ3NgIGF0dHJpYnV0ZSBvbiBhIGBjb25maWdgIG9iamVjdC5cbiAqXG4gKiBUaGUgYHRhZ3NgIGF0dHJpYnV0ZSBvZiBhIGBjb25maWdgIG9iamVjdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvXG4gKiBzdHJpbmcgdmFsdWVzOiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIChlLmcuXG4gKiBbIFwiPCVcIiwgXCIlPlwiIF0pLiBUaGUgZGVmYXVsdCBpcyB0byBtdXN0YWNoZS50YWdzLlxuICpcbiAqIFRoZSBgZXNjYXBlYCBhdHRyaWJ1dGUgb2YgYSBgY29uZmlnYCBvYmplY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIHdoaWNoXG4gKiBhY2NlcHRzIGEgc3RyaW5nIGFzIGlucHV0IGFuZCBvdXRwdXRzIGEgc2FmZWx5IGVzY2FwZWQgc3RyaW5nLlxuICogSWYgYW4gYGVzY2FwZWAgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCB0aGVuIGFuIEhUTUwtc2FmZSBzdHJpbmdcbiAqIGVzY2FwaW5nIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGRlZmF1bHQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIGNvbmZpZykge1xuICB2YXIgdGFncyA9IHRoaXMuZ2V0Q29uZmlnVGFncyhjb25maWcpO1xuICB2YXIgdG9rZW5zID0gdGhpcy5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG4gIHZhciBjb250ZXh0ID0gKHZpZXcgaW5zdGFuY2VvZiBDb250ZXh0KSA/IHZpZXcgOiBuZXcgQ29udGV4dCh2aWV3LCB1bmRlZmluZWQpO1xuICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgdGVtcGxhdGUsIGNvbmZpZyk7XG59O1xuXG4vKipcbiAqIExvdy1sZXZlbCBtZXRob2QgdGhhdCByZW5kZXJzIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCB1c2luZ1xuICogdGhlIGdpdmVuIGBjb250ZXh0YCBhbmQgYHBhcnRpYWxzYC5cbiAqXG4gKiBOb3RlOiBUaGUgYG9yaWdpbmFsVGVtcGxhdGVgIGlzIG9ubHkgZXZlciB1c2VkIHRvIGV4dHJhY3QgdGhlIHBvcnRpb25cbiAqIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHdhcyBjb250YWluZWQgaW4gYSBoaWdoZXItb3JkZXIgc2VjdGlvbi5cbiAqIElmIHRoZSB0ZW1wbGF0ZSBkb2Vzbid0IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMsIHRoaXMgYXJndW1lbnQgbWF5XG4gKiBiZSBvbWl0dGVkLlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlbmRlclRva2VucyA9IGZ1bmN0aW9uIHJlbmRlclRva2VucyAodG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKSB7XG4gIHZhciBidWZmZXIgPSAnJztcblxuICB2YXIgdG9rZW4sIHN5bWJvbCwgdmFsdWU7XG4gIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBzeW1ib2wgPSB0b2tlblswXTtcblxuICAgIGlmIChzeW1ib2wgPT09ICcjJykgdmFsdWUgPSB0aGlzLnJlbmRlclNlY3Rpb24odG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xuICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ14nKSB2YWx1ZSA9IHRoaXMucmVuZGVySW52ZXJ0ZWQodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xuICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJz4nKSB2YWx1ZSA9IHRoaXMucmVuZGVyUGFydGlhbCh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIGNvbmZpZyk7XG4gICAgZWxzZSBpZiAoc3ltYm9sID09PSAnJicpIHZhbHVlID0gdGhpcy51bmVzY2FwZWRWYWx1ZSh0b2tlbiwgY29udGV4dCk7XG4gICAgZWxzZSBpZiAoc3ltYm9sID09PSAnbmFtZScpIHZhbHVlID0gdGhpcy5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQsIGNvbmZpZyk7XG4gICAgZWxzZSBpZiAoc3ltYm9sID09PSAndGV4dCcpIHZhbHVlID0gdGhpcy5yYXdWYWx1ZSh0b2tlbik7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiByZW5kZXJTZWN0aW9uICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBidWZmZXIgPSAnJztcbiAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZW5kZXIgYW4gYXJiaXRyYXJ5IHRlbXBsYXRlXG4gIC8vIGluIHRoZSBjdXJyZW50IGNvbnRleHQgYnkgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLlxuICBmdW5jdGlvbiBzdWJSZW5kZXIgKHRlbXBsYXRlKSB7XG4gICAgcmV0dXJuIHNlbGYucmVuZGVyKHRlbXBsYXRlLCBjb250ZXh0LCBwYXJ0aWFscywgY29uZmlnKTtcbiAgfVxuXG4gIGlmICghdmFsdWUpIHJldHVybjtcblxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBqID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGogPCB2YWx1ZUxlbmd0aDsgKytqKSB7XG4gICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZVtqXSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsVGVtcGxhdGUgIT09ICdzdHJpbmcnKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucyB3aXRob3V0IHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZScpO1xuXG4gICAgLy8gRXh0cmFjdCB0aGUgcG9ydGlvbiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB0aGUgc2VjdGlvbiBjb250YWlucy5cbiAgICB2YWx1ZSA9IHZhbHVlLmNhbGwoY29udGV4dC52aWV3LCBvcmlnaW5hbFRlbXBsYXRlLnNsaWNlKHRva2VuWzNdLCB0b2tlbls1XSksIHN1YlJlbmRlcik7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLnJlbmRlckludmVydGVkID0gZnVuY3Rpb24gcmVuZGVySW52ZXJ0ZWQgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKSB7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAvLyBVc2UgSmF2YVNjcmlwdCdzIGRlZmluaXRpb24gb2YgZmFsc3kuIEluY2x1ZGUgZW1wdHkgYXJyYXlzLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4NlxuICBpZiAoIXZhbHVlIHx8IChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKVxuICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLmluZGVudFBhcnRpYWwgPSBmdW5jdGlvbiBpbmRlbnRQYXJ0aWFsIChwYXJ0aWFsLCBpbmRlbnRhdGlvbiwgbGluZUhhc05vblNwYWNlKSB7XG4gIHZhciBmaWx0ZXJlZEluZGVudGF0aW9uID0gaW5kZW50YXRpb24ucmVwbGFjZSgvW14gXFx0XS9nLCAnJyk7XG4gIHZhciBwYXJ0aWFsQnlObCA9IHBhcnRpYWwuc3BsaXQoJ1xcbicpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRpYWxCeU5sLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnRpYWxCeU5sW2ldLmxlbmd0aCAmJiAoaSA+IDAgfHwgIWxpbmVIYXNOb25TcGFjZSkpIHtcbiAgICAgIHBhcnRpYWxCeU5sW2ldID0gZmlsdGVyZWRJbmRlbnRhdGlvbiArIHBhcnRpYWxCeU5sW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydGlhbEJ5Tmwuam9pbignXFxuJyk7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLnJlbmRlclBhcnRpYWwgPSBmdW5jdGlvbiByZW5kZXJQYXJ0aWFsICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIGNvbmZpZykge1xuICBpZiAoIXBhcnRpYWxzKSByZXR1cm47XG4gIHZhciB0YWdzID0gdGhpcy5nZXRDb25maWdUYWdzKGNvbmZpZyk7XG5cbiAgdmFyIHZhbHVlID0gaXNGdW5jdGlvbihwYXJ0aWFscykgPyBwYXJ0aWFscyh0b2tlblsxXSkgOiBwYXJ0aWFsc1t0b2tlblsxXV07XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdmFyIGxpbmVIYXNOb25TcGFjZSA9IHRva2VuWzZdO1xuICAgIHZhciB0YWdJbmRleCA9IHRva2VuWzVdO1xuICAgIHZhciBpbmRlbnRhdGlvbiA9IHRva2VuWzRdO1xuICAgIHZhciBpbmRlbnRlZFZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHRhZ0luZGV4ID09IDAgJiYgaW5kZW50YXRpb24pIHtcbiAgICAgIGluZGVudGVkVmFsdWUgPSB0aGlzLmluZGVudFBhcnRpYWwodmFsdWUsIGluZGVudGF0aW9uLCBsaW5lSGFzTm9uU3BhY2UpO1xuICAgIH1cbiAgICB2YXIgdG9rZW5zID0gdGhpcy5wYXJzZShpbmRlbnRlZFZhbHVlLCB0YWdzKTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50ZWRWYWx1ZSwgY29uZmlnKTtcbiAgfVxufTtcblxuV3JpdGVyLnByb3RvdHlwZS51bmVzY2FwZWRWYWx1ZSA9IGZ1bmN0aW9uIHVuZXNjYXBlZFZhbHVlICh0b2tlbiwgY29udGV4dCkge1xuICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbldyaXRlci5wcm90b3R5cGUuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gZXNjYXBlZFZhbHVlICh0b2tlbiwgY29udGV4dCwgY29uZmlnKSB7XG4gIHZhciBlc2NhcGUgPSB0aGlzLmdldENvbmZpZ0VzY2FwZShjb25maWcpIHx8IG11c3RhY2hlLmVzY2FwZTtcbiAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgZXNjYXBlID09PSBtdXN0YWNoZS5lc2NhcGUpID8gU3RyaW5nKHZhbHVlKSA6IGVzY2FwZSh2YWx1ZSk7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLnJhd1ZhbHVlID0gZnVuY3Rpb24gcmF3VmFsdWUgKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblsxXTtcbn07XG5cbldyaXRlci5wcm90b3R5cGUuZ2V0Q29uZmlnVGFncyA9IGZ1bmN0aW9uIGdldENvbmZpZ1RhZ3MgKGNvbmZpZykge1xuICBpZiAoaXNBcnJheShjb25maWcpKSB7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBlbHNlIGlmIChjb25maWcgJiYgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gY29uZmlnLnRhZ3M7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuV3JpdGVyLnByb3RvdHlwZS5nZXRDb25maWdFc2NhcGUgPSBmdW5jdGlvbiBnZXRDb25maWdFc2NhcGUgKGNvbmZpZykge1xuICBpZiAoY29uZmlnICYmIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmICFpc0FycmF5KGNvbmZpZykpIHtcbiAgICByZXR1cm4gY29uZmlnLmVzY2FwZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG52YXIgbXVzdGFjaGUgPSB7XG4gIG5hbWU6ICdtdXN0YWNoZS5qcycsXG4gIHZlcnNpb246ICc0LjIuMCcsXG4gIHRhZ3M6IFsgJ3t7JywgJ319JyBdLFxuICBjbGVhckNhY2hlOiB1bmRlZmluZWQsXG4gIGVzY2FwZTogdW5kZWZpbmVkLFxuICBwYXJzZTogdW5kZWZpbmVkLFxuICByZW5kZXI6IHVuZGVmaW5lZCxcbiAgU2Nhbm5lcjogdW5kZWZpbmVkLFxuICBDb250ZXh0OiB1bmRlZmluZWQsXG4gIFdyaXRlcjogdW5kZWZpbmVkLFxuICAvKipcbiAgICogQWxsb3dzIGEgdXNlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBjYWNoaW5nIHN0cmF0ZWd5LCBieSBwcm92aWRpbmcgYW5cbiAgICogb2JqZWN0IHdpdGggc2V0LCBnZXQgYW5kIGNsZWFyIG1ldGhvZHMuIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBkaXNhYmxlXG4gICAqIHRoZSBjYWNoZSBieSBzZXR0aW5nIGl0IHRvIHRoZSBsaXRlcmFsIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgc2V0IHRlbXBsYXRlQ2FjaGUgKGNhY2hlKSB7XG4gICAgZGVmYXVsdFdyaXRlci50ZW1wbGF0ZUNhY2hlID0gY2FjaGU7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkZWZhdWx0IG9yIG92ZXJyaWRkZW4gY2FjaGluZyBvYmplY3QgZnJvbSB0aGUgZGVmYXVsdCB3cml0ZXIuXG4gICAqL1xuICBnZXQgdGVtcGxhdGVDYWNoZSAoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIudGVtcGxhdGVDYWNoZTtcbiAgfVxufTtcblxuLy8gQWxsIGhpZ2gtbGV2ZWwgbXVzdGFjaGUuKiBmdW5jdGlvbnMgdXNlIHRoaXMgd3JpdGVyLlxudmFyIGRlZmF1bHRXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG5cbi8qKlxuICogQ2xlYXJzIGFsbCBjYWNoZWQgdGVtcGxhdGVzIGluIHRoZSBkZWZhdWx0IHdyaXRlci5cbiAqL1xubXVzdGFjaGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICByZXR1cm4gZGVmYXVsdFdyaXRlci5jbGVhckNhY2hlKCk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiB0ZW1wbGF0ZSBpbiB0aGUgZGVmYXVsdCB3cml0ZXIgYW5kIHJldHVybnMgdGhlXG4gKiBhcnJheSBvZiB0b2tlbnMgaXQgY29udGFpbnMuIERvaW5nIHRoaXMgYWhlYWQgb2YgdGltZSBhdm9pZHMgdGhlIG5lZWQgdG9cbiAqIHBhcnNlIHRlbXBsYXRlcyBvbiB0aGUgZmx5IGFzIHRoZXkgYXJlIHJlbmRlcmVkLlxuICovXG5tdXN0YWNoZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICh0ZW1wbGF0ZSwgdGFncykge1xuICByZXR1cm4gZGVmYXVsdFdyaXRlci5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGB0ZW1wbGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHZpZXdgLCBgcGFydGlhbHNgLCBhbmQgYGNvbmZpZ2BcbiAqIHVzaW5nIHRoZSBkZWZhdWx0IHdyaXRlci5cbiAqL1xubXVzdGFjaGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIGNvbmZpZykge1xuICBpZiAodHlwZW9mIHRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUhIFRlbXBsYXRlIHNob3VsZCBiZSBhIFwic3RyaW5nXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV0IFwiJyArIHR5cGVTdHIodGVtcGxhdGUpICsgJ1wiIHdhcyBnaXZlbiBhcyB0aGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnQgZm9yIG11c3RhY2hlI3JlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpJyk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFdyaXRlci5yZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzLCBjb25maWcpO1xufTtcblxuLy8gRXhwb3J0IHRoZSBlc2NhcGluZyBmdW5jdGlvbiBzbyB0aGF0IHRoZSB1c2VyIG1heSBvdmVycmlkZSBpdC5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMjQ0XG5tdXN0YWNoZS5lc2NhcGUgPSBlc2NhcGVIdG1sO1xuXG4vLyBFeHBvcnQgdGhlc2UgbWFpbmx5IGZvciB0ZXN0aW5nLCBidXQgYWxzbyBmb3IgYWR2YW5jZWQgdXNhZ2UuXG5tdXN0YWNoZS5TY2FubmVyID0gU2Nhbm5lcjtcbm11c3RhY2hlLkNvbnRleHQgPSBDb250ZXh0O1xubXVzdGFjaGUuV3JpdGVyID0gV3JpdGVyO1xuXG5leHBvcnQgZGVmYXVsdCBtdXN0YWNoZTtcbiIsICJpbXBvcnQgTXVzdGFjaGUgZnJvbSAnbXVzdGFjaGUnO1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5leHBvcnQgY29uc3QgVEVNUExBVEVfVkFSSUFCTEVTID0gYHt7cHJlX2N1cnNvcn19XFxue3twb3N0X2N1cnNvcn19IFxcbnt7YWN0aXZlX3NlbnRlbmNlfX0gXFxue3tsYXN0X2xpbmV9fWA7XG5cbmludGVyZmFjZSBUZW1wbGF0ZUFyZ3Mge1xuICAgIHByZV9jdXJzb3I6IHN0cmluZztcbiAgICBwb3N0X2N1cnNvcjogc3RyaW5nO1xuICAgIGFjdGl2ZV9zZW50ZW5jZTogc3RyaW5nO1xuICAgIGxhc3RfbGluZTogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRQcm9tcHQodGVtcGxhdGU6IHN0cmluZywgYXJnczogVGVtcGxhdGVBcmdzKTogc3RyaW5nIHtcbiAgICByZXR1cm4gTXVzdGFjaGUucmVuZGVyKHRlbXBsYXRlLCBhcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVQcm9tcHQoZWRpdG9yOiBFZGl0b3IsIHRlbXBsYXRlOiBzdHJpbmcgPSBURU1QTEFURV9WQVJJQUJMRVMpOiBzdHJpbmcge1xuICAgIGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICBjb25zdCBwcmVDdXJzb3IgPSBlZGl0b3IuZ2V0UmFuZ2UoeyBsaW5lOiAwLCBjaDogMCB9LCBjdXJzb3IpO1xuICAgIGNvbnN0IHBvc3RDdXJzb3IgPSBlZGl0b3IuZ2V0UmFuZ2UoY3Vyc29yLCB7IGxpbmU6IGVkaXRvci5sYXN0TGluZSgpLCBjaDogZWRpdG9yLmdldExpbmUoZWRpdG9yLmxhc3RMaW5lKCkpLmxlbmd0aCB9KTtcbiAgICBjb25zdCBhY3RpdmVTZW50ZW5jZSA9IHNlbnRlbmNlQXRDdXJzb3IoZWRpdG9yKTtcbiAgICBjb25zdCBsYXN0TGluZSA9IGVkaXRvci5nZXRMaW5lKGVkaXRvci5sYXN0TGluZSgpKTtcblxuICAgIHJldHVybiBidWlsZFByb21wdCh0ZW1wbGF0ZSwge1xuICAgICAgICBwcmVfY3Vyc29yOiBwcmVDdXJzb3IsXG4gICAgICAgIHBvc3RfY3Vyc29yOiBwb3N0Q3Vyc29yLFxuICAgICAgICBhY3RpdmVfc2VudGVuY2U6IGFjdGl2ZVNlbnRlbmNlLFxuICAgICAgICBsYXN0X2xpbmU6IGxhc3RMaW5lXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlbnRlbmNlQXRDdXJzb3IoZWRpdG9yOiBFZGl0b3IpOiBzdHJpbmcge1xuICAgIGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICBsZXQgY3VycmVudExpbmUgPSBjdXJzb3IubGluZTtcbiAgICBsZXQgc2VudGVuY2VMaW5lcyA9IFtlZGl0b3IuZ2V0TGluZShjdXJyZW50TGluZSldO1xuXG4gICAgLy8gU2VhcmNoIGJhY2t3YXJkcyB1bnRpbCBzZW50ZW5jZSBzdGFydCBmb3VuZFxuICAgIHdoaWxlIChjdXJyZW50TGluZSA+IDApIHtcbiAgICAgICAgY3VycmVudExpbmUtLTtcbiAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGN1cnJlbnRMaW5lKTtcblxuICAgICAgICAvLyBDaGVjayBpZiBwcmV2aW91cyBsaW5lIGVuZHMgd2l0aCBzZW50ZW5jZSBlbmRpbmdcbiAgICAgICAgaWYgKC9bLiE/XVxccyokLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbnRlbmNlTGluZXMudW5zaGlmdChsaW5lKTtcbiAgICB9XG5cbiAgICAvLyBKb2luIGxpbmVzIGFuZCBjbGVhbiB1cCB3aGl0ZXNwYWNlXG4gICAgcmV0dXJuIHNlbnRlbmNlTGluZXNcbiAgICAgICAgLmpvaW4oJyAnKVxuICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgICAgIC50cmltKCk7XG59IiwgImltcG9ydCB7IE1vZGVsUmVzcG9uc2UsIE9sbGFtYSB9IGZyb20gXCJvbGxhbWFcIjtcbmltcG9ydCB7IE9sbGFtYVNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSBcIi4uXCI7XG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IHByZXBhcmVQcm9tcHQgfSBmcm9tIFwic3JjL3Byb21wdC9wcm9tcHRcIjtcbmltcG9ydCB7IENvbXBsZXRpb25PcHRpb25zIH0gZnJvbSBcInNyYy9zZXR0aW5ncy9zZXR0aW5nc1wiO1xuXG5leHBvcnQgY2xhc3MgT2xsYW1hUHJvdmlkZXIgaW1wbGVtZW50cyBQcm92aWRlciB7XG4gICAgY2xpZW50OiBPbGxhbWFcbiAgICBzZXR0aW5nczogT2xsYW1hU2V0dGluZ3M7XG4gICAgYWJvcnRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3Ioc2V0dGluczogT2xsYW1hU2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbnM7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3IE9sbGFtYSh7IGhvc3Q6IHRoaXMuc2V0dGluZ3MuaG9zdCB9KTtcbiAgICB9XG5cbiAgICBhc3luYyAqZ2VuZXJhdGUoZWRpdG9yOiBFZGl0b3IsIG9wdGlvbnM6IENvbXBsZXRpb25PcHRpb25zKTogQXN5bmNHZW5lcmF0b3I8c3RyaW5nPiB7XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwcm9tcHQgPSBwcmVwYXJlUHJvbXB0KGVkaXRvciwgb3B0aW9ucy51c2VyUHJvbXB0KTtcblxuICAgICAgICBjb25zdCBjb21wbGV0aW9uSXRlcmF0b3IgPSBhd2FpdCB0aGlzLmNsaWVudC5nZW5lcmF0ZSh7XG4gICAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICAgIHByb21wdDogcHJvbXB0LFxuICAgICAgICAgICAgc3lzdGVtOiBvcHRpb25zLnN5c3RlbVByb21wdCxcbiAgICAgICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgaW5pdGlhbFBvc2l0aW9uID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICBsZXQgY29tcGxldGlvbiA9IFwiXCI7XG4gICAgICAgIGZvciBhd2FpdCAobGV0IHJlc3BvbnNlIG9mIGNvbXBsZXRpb25JdGVyYXRvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UG9zaXRpb24ubGluZSAhPT0gaW5pdGlhbFBvc2l0aW9uLmxpbmUgfHwgY3VycmVudFBvc2l0aW9uLmNoICE9PSBpbml0aWFsUG9zaXRpb24uY2gpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImN1cnNvciBtb3ZlZCwgYWJvcnRpbmcgY29tcGxldGlvblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcGxldGlvbiArPSByZXNwb25zZS5yZXNwb25zZTtcbiAgICAgICAgICAgIHlpZWxkIGNvbXBsZXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLmNsaWVudC5hYm9ydCgpO1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmxvZyhcImFib3J0ZWQgY29tcGxldGlvblwiKTtcbiAgICB9XG5cbiAgICBhc3luYyB1cGRhdGVNb2RlbHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50Lmxpc3QoKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5tb2RlbHMgPSByZXNwb25zZS5tb2RlbHMubWFwKChtb2RlbDogTW9kZWxSZXNwb25zZSkgPT4gbW9kZWwubmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MubW9kZWxzO1xuICAgIH1cbn1cblxuXG4iLCAiaW1wb3J0IHsgU2V0dGluZ3MgfSBmcm9tIFwic3JjL3NldHRpbmdzL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBPcGVuQUlQcm92aWRlciB9IGZyb20gXCIuL29wZW5haVwiO1xuaW1wb3J0IHsgT2xsYW1hUHJvdmlkZXIgfSBmcm9tIFwiLi9vbGxhbWFcIjtcblxuZXhwb3J0ICogZnJvbSBcIi4vcHJvdmlkZXJcIjtcblxuZXhwb3J0IGVudW0gUHJvdmlkZXJUeXBlIHtcbiAgICBPTExBTUEgPSBcIm9sbGFtYVwiLFxuICAgIE9QRU5BSSA9IFwib3BlbmFpXCIsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvdmlkZXJzIHtcbiAgICBbUHJvdmlkZXJUeXBlLk9MTEFNQV06IE9sbGFtYVByb3ZpZGVyLFxuICAgIFtQcm92aWRlclR5cGUuT1BFTkFJXTogT3BlbkFJUHJvdmlkZXIsXG59XG5cbmV4cG9ydCBjb25zdCBidWlsZFByb3ZpZGVycyA9IChzZXR0aW5nczogU2V0dGluZ3MpOiBQcm92aWRlcnMgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtQcm92aWRlclR5cGUuT0xMQU1BXTogbmV3IE9sbGFtYVByb3ZpZGVyKHNldHRpbmdzLnByb3ZpZGVycy5vbGxhbWEpLFxuICAgICAgICBbUHJvdmlkZXJUeXBlLk9QRU5BSV06IG5ldyBPcGVuQUlQcm92aWRlcihzZXR0aW5ncy5wcm92aWRlcnMub3BlbmFpKSxcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgUHJvdmlkZXJUeXBlIH0gZnJvbSBcInNyYy9wcm92aWRlcnNcIjtcbmltcG9ydCB7IFNwbGl0U3RyYXRlZ3kgfSBmcm9tIFwic3JjL2V4dGVuc2lvblwiO1xuaW1wb3J0IHsgT2xsYW1hU2V0dGluZ3MgfSBmcm9tIFwic3JjL3Byb3ZpZGVycy9vbGxhbWFcIjtcbmltcG9ydCB7IE9wZW5BSVNldHRpbmdzIH0gZnJvbSBcInNyYy9wcm92aWRlcnMvb3BlbmFpXCI7XG5cbi8vIENvbXBsZXRpb24gb3B0aW9ucyBmb3IgYSBwcm9maWxlXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25PcHRpb25zIHtcbiAgICBtb2RlbDogc3RyaW5nLFxuICAgIHVzZXJQcm9tcHQ6IHN0cmluZyxcbiAgICBzeXN0ZW1Qcm9tcHQ6IHN0cmluZyxcbiAgICB0ZW1wZXJhdHVyZTogbnVtYmVyXG59XG5cbi8vIFByb2ZpbGUgc2V0dGluZ3NcbmV4cG9ydCBpbnRlcmZhY2UgUHJvZmlsZSB7XG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHByb3ZpZGVyOiBQcm92aWRlclR5cGUsXG4gICAgZGVsYXlNczogbnVtYmVyLFxuICAgIHNwbGl0U3RyYXRlZ3k6IFNwbGl0U3RyYXRlZ3lcbiAgICBjb21wbGV0aW9uT3B0aW9uczogQ29tcGxldGlvbk9wdGlvbnMsXG59XG5cbmV4cG9ydCB0eXBlIFByb2ZpbGVOYW1lID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgUHJvZmlsZXMgPSBSZWNvcmQ8UHJvZmlsZU5hbWUsIFByb2ZpbGU+XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0dGluZ3Mge1xuICAgIC8vIGF2YWlsYWJsZSBwcm92aWRlcnNcbiAgICBwcm92aWRlcnM6IHtcbiAgICAgICAgb2xsYW1hOiBPbGxhbWFTZXR0aW5ncyxcbiAgICAgICAgb3BlbmFpOiBPcGVuQUlTZXR0aW5ncyxcbiAgICB9LFxuICAgIC8vIHByb2ZpbGVzXG4gICAgcHJvZmlsZXM6IFByb2ZpbGVzLFxuICAgIC8vIHBhdGggdG8gcHJvZmlsZSBtYXBwaW5nc1xuICAgIHBhdGhfcHJvZmlsZV9tYXBwaW5nczogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUFJPRklMRTogUHJvZmlsZU5hbWUgPSBcImRlZmF1bHRcIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBTZXR0aW5ncyA9IHtcbiAgICBwcm92aWRlcnM6IHtcbiAgICAgICAgb3BlbmFpOiB7XG4gICAgICAgICAgICBpbnRlZ3JhdGlvbjogUHJvdmlkZXJUeXBlLk9QRU5BSSxcbiAgICAgICAgICAgIG5hbWU6IFwiT3BlbiBBSVwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVXNlIE9wZW5BSSBBUElzIHRvIGdlbmVyYXRlIHRleHQuXCIsXG4gICAgICAgICAgICBhcGlLZXk6IFwiXCIsXG4gICAgICAgICAgICBtb2RlbDogXCJncHQtNG9cIixcbiAgICAgICAgICAgIG1vZGVsczogW1wiZ3B0LTRcIiwgXCJncHQtMy41LXR1cmJvXCIsIFwiZ3B0LTMuNVwiLCBcImdwdC0zXCIsIFwiZ3B0LTJcIiwgXCJncHQtMVwiXSxcbiAgICAgICAgICAgIGNvbmZpZ3VyZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBvbGxhbWE6IHtcbiAgICAgICAgICAgIGludGVncmF0aW9uOiBQcm92aWRlclR5cGUuT0xMQU1BLFxuICAgICAgICAgICAgbmFtZTogXCJPbGxhbWFcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlVzZSB5b3VyIG93biBPbGxhbWEgaW5zdGFuY2UgdG8gZ2VuZXJhdGUgdGV4dC5cIixcbiAgICAgICAgICAgIGhvc3Q6IFwiaHR0cDovL2xvY2FsaG9zdDoxMTQzNFwiLFxuICAgICAgICAgICAgbW9kZWxzOiBbXCJsbGFtYTMuMjpsYXRlc3RcIiwgXCJtaXN0cmFsLW5lbW9cIl0sXG4gICAgICAgICAgICBjb25maWd1cmVkOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgcHJvZmlsZXM6IHtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbmFtZTogXCJEZWZhdWx0IFByb2ZpbGVcIixcbiAgICAgICAgICAgIHByb3ZpZGVyOiBQcm92aWRlclR5cGUuT0xMQU1BLFxuICAgICAgICAgICAgZGVsYXlNczogNTAwLFxuICAgICAgICAgICAgc3BsaXRTdHJhdGVneTogXCJ3b3JkXCIsXG4gICAgICAgICAgICBjb21wbGV0aW9uT3B0aW9uczoge1xuICAgICAgICAgICAgICAgIG1vZGVsOiBcIm1pc3RyYWwtbmVtb1wiLFxuICAgICAgICAgICAgICAgIHVzZXJQcm9tcHQ6ICdDb21wbGV0ZSBmb2xsb3dpbmcgdGV4dDpcXG4ge3twcmVfY3Vyc29yfX19JyxcbiAgICAgICAgICAgICAgICBzeXN0ZW1Qcm9tcHQ6IFwiWW91IGFyZSBhbiBoZWxwZnVsIEFJIGNvbXBsZXRlci4gRm9sbG93IGluc3RydWN0aW9uc1wiLFxuICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiAwLjUsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBwYXRoX3Byb2ZpbGVfbWFwcGluZ3M6IHtcbiAgICAgICAgXCIvXCI6IERFRkFVTFRfUFJPRklMRSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5ld1Byb2ZpbGUocHJvZmlsZXM6IFByb2ZpbGVzKTogc3RyaW5nIHtcbiAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA2KTtcblxuICAgIC8vIGdlbmVyYXRlIGEgbmV3IHByb2ZpbGUgbmFtZVxuICAgIGxldCBuYW1lID0gXCJOZXcgUHJvZmlsZVwiO1xuICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgcHJvZmlsZXMgdG8gbWFrZSBzdXJlIHRoZSBuYW1lIGlzIHVuaXF1ZVxuICAgIGxldCBpID0gMTtcbiAgICBPYmplY3QuZW50cmllcyhwcm9maWxlcykuZm9yRWFjaCgoWywgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gYE5ldyBQcm9maWxlICR7aX1gO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBjb3B5IHRoZSBkZWZhdWx0IHByb2ZpbGVcbiAgICBjb25zdCBkZWZhdWx0UHJvZmlsZSA9IHByb2ZpbGVzW0RFRkFVTFRfUFJPRklMRV07XG4gICAgY29uc3QgcHJvZmlsZSA9IHtcbiAgICAgICAgLi4uZGVmYXVsdFByb2ZpbGUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgfTtcblxuICAgIC8vIGFkZCB0aGUgbmV3IHByb2ZpbGVcbiAgICBwcm9maWxlc1tpZF0gPSBwcm9maWxlO1xuXG4gICAgcmV0dXJuIGlkO1xufVxuIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgQnV0dG9uQ29tcG9uZW50LCBFeHRyYUJ1dHRvbkNvbXBvbmVudCwgRHJvcGRvd25Db21wb25lbnQgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IFRFTVBMQVRFX1ZBUklBQkxFUyB9IGZyb20gXCJzcmMvcHJvbXB0L3Byb21wdFwiO1xuaW1wb3J0IHsgU3BsaXRTdHJhdGVneSB9IGZyb20gXCJzcmMvZXh0ZW5zaW9uXCI7XG5pbXBvcnQgSW5zY3JpYmUgZnJvbSBcInNyYy9tYWluXCI7XG5pbXBvcnQgeyBQcm92aWRlclR5cGUgfSBmcm9tIFwic3JjL3Byb3ZpZGVyc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9QUk9GSUxFLCBuZXdQcm9maWxlLCBQcm9maWxlIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmltcG9ydCB7IFByb3ZpZGVyU2V0dGluZ3NNb2RhbCB9IGZyb20gXCIuL3Byb3ZpZGVyLW1vZGFsXCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBNYWluIFNldHRpbmdzIFRhYlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnNjcmliZVNldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgcHJpdmF0ZSBwcm92aWRlcnNTZWN0aW9uOiBQcm92aWRlcnNTZWN0aW9uO1xuICAgIHByaXZhdGUgcHJvZmlsZXNTZWN0aW9uOiBQcm9maWxlc1NlY3Rpb247XG4gICAgcHJpdmF0ZSBwYXRoTWFwcGluZ3NTZWN0aW9uOiBQYXRoTWFwcGluZ3NTZWN0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHByaXZhdGUgcGx1Z2luOiBJbnNjcmliZSkge1xuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzcGxheSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgICAgIC8vIFByb3ZpZGVycyBTZWN0aW9uXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuYXBwZW5kQ2hpbGQocHJvdmlkZXJzQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnNTZWN0aW9uID0gbmV3IFByb3ZpZGVyc1NlY3Rpb24ocHJvdmlkZXJzQ29udGFpbmVyLCB0aGlzLmFwcCwgdGhpcy5wbHVnaW4pO1xuICAgICAgICBhd2FpdCB0aGlzLnByb3ZpZGVyc1NlY3Rpb24ucmVuZGVyKCk7XG5cbiAgICAgICAgLy8gUHJvZmlsZXMgU2VjdGlvblxuICAgICAgICBjb25zdCBwcm9maWxlc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuYXBwZW5kQ2hpbGQocHJvZmlsZXNDb250YWluZXIpO1xuICAgICAgICB0aGlzLnByb2ZpbGVzU2VjdGlvbiA9IG5ldyBQcm9maWxlc1NlY3Rpb24ocHJvZmlsZXNDb250YWluZXIsIHRoaXMucGx1Z2luKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9maWxlc1NlY3Rpb24ucmVuZGVyKCk7XG5cbiAgICAgICAgLy8gUGF0aCBNYXBwaW5ncyBTZWN0aW9uXG4gICAgICAgIGNvbnN0IHBhdGhNYXBwaW5nc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuYXBwZW5kQ2hpbGQocGF0aE1hcHBpbmdzQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5wYXRoTWFwcGluZ3NTZWN0aW9uID0gbmV3IFBhdGhNYXBwaW5nc1NlY3Rpb24ocGF0aE1hcHBpbmdzQ29udGFpbmVyLCB0aGlzLnBsdWdpbik7XG4gICAgICAgIGF3YWl0IHRoaXMucGF0aE1hcHBpbmdzU2VjdGlvbi5yZW5kZXIoKTtcbiAgICB9XG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBQcm92aWRlcnMgU2VjdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5jbGFzcyBQcm92aWRlcnNTZWN0aW9uIHtcbiAgICBwcml2YXRlIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBwbHVnaW46IEluc2NyaWJlO1xuICAgIHByaXZhdGUgYXBwOiBBcHA7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxFbGVtZW50LCBhcHA6IEFwcCwgcGx1Z2luOiBJbnNjcmliZSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgYXN5bmMgcmVuZGVyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5lbXB0eSgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJQcm92aWRlcnNcIiB9KTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRWwoXCJwXCIsIHtcbiAgICAgICAgICAgIHRleHQ6IFwiQ29uZmlndXJlIHRoZSBBSSBwcm92aWRlcnMgeW91IHdhbnQgdG8gdXNlIGZvciBjb21wbGV0aW9uc1wiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE9sbGFtYSBQcm92aWRlclxuICAgICAgICBuZXcgU2V0dGluZyh0aGlzLmNvbnRhaW5lcilcbiAgICAgICAgICAgIC5zZXROYW1lKFwiT2xsYW1hXCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkxvY2FsIEFJIHByb3ZpZGVyIHJ1bm5pbmcgb24geW91ciBtYWNoaW5lXCIpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKChidXR0b246IEJ1dHRvbkNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChcIkNvbmZpZ3VyZVwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkNvbmZpZ3VyZSBPbGxhbWFcIilcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4gdGhpcy5vcGVuUHJvdmlkZXJNb2RhbChQcm92aWRlclR5cGUuT0xMQU1BKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBPcGVuQUkgUHJvdmlkZXJcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5jb250YWluZXIpXG4gICAgICAgICAgICAuc2V0TmFtZShcIk9wZW5BSVwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJPcGVuQUkgQVBJIHByb3ZpZGVyXCIpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKChidXR0b246IEJ1dHRvbkNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChcIkNvbmZpZ3VyZVwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkNvbmZpZ3VyZSBPcGVuQUlcIilcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4gdGhpcy5vcGVuUHJvdmlkZXJNb2RhbChQcm92aWRlclR5cGUuT1BFTkFJKSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9wZW5Qcm92aWRlck1vZGFsKHR5cGU6IFByb3ZpZGVyVHlwZSk6IHZvaWQge1xuICAgICAgICBuZXcgUHJvdmlkZXJTZXR0aW5nc01vZGFsKHRoaXMuYXBwLCB0aGlzLnBsdWdpbiwgdHlwZSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfSkub3BlbigpO1xuICAgIH1cbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFByb2ZpbGVzIFNlY3Rpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuY2xhc3MgUHJvZmlsZXNTZWN0aW9uIHtcbiAgICBwcml2YXRlIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBwbHVnaW46IEluc2NyaWJlO1xuICAgIHByaXZhdGUgZGlzcGxheWVkUHJvZmlsZUlkOiBzdHJpbmcgPSBERUZBVUxUX1BST0ZJTEU7XG4gICAgcHJpdmF0ZSBzZWxlY3Rpb25Db250YWluZXI6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgcHJvZmlsZUNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxFbGVtZW50LCBwbHVnaW46IEluc2NyaWJlKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGNvbnRhaW5lcnMgb25jZVxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMucHJvZmlsZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgLy8gQXBwZW5kIHRoZW0gaW5pdGlhbGx5XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc2VsZWN0aW9uQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5wcm9maWxlQ29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBhc3luYyByZW5kZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIC8vIENsZWFyIG1haW4gY29udGFpbmVyIGFuZCByZS1hcHBlbmQgc3ViLWNvbnRhaW5lcnNcbiAgICAgICAgdGhpcy5jb250YWluZXIuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IFwiUHJvZmlsZXNcIiB9KTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRWwoXCJwXCIsIHtcbiAgICAgICAgICAgIHRleHQ6IFwiQ29uZmlndXJlIHRoZSBzZXR0aW5ncyBmb3IgZWFjaCBwcm9maWxlLiBBIHByb2ZpbGUgY2FuIGJlIGFzc2lnbmVkIHRvIHBhdGhzLiBUaGUgZGVmYXVsdCBwcm9maWxlIGlzIHVzZWQgd2hlbiBubyBwcm9maWxlIGlzIGFzc2lnbmVkLlwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdGlvbkNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucHJvZmlsZUNvbnRhaW5lcik7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJQcm9maWxlU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgY29uc3QgZGlzcGxheWVkUHJvZmlsZSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2ZpbGVzW3RoaXMuZGlzcGxheWVkUHJvZmlsZUlkXTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJQcm9maWxlU2V0dGluZ3MoZGlzcGxheWVkUHJvZmlsZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyByZW5kZXJQcm9maWxlU2VsZWN0aW9uKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbnRhaW5lci5lbXB0eSgpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbnRhaW5lci5jcmVhdGVFbChcImJyXCIpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKHRoaXMuc2VsZWN0aW9uQ29udGFpbmVyKVxuICAgICAgICAgICAgLnNldEhlYWRpbmcoKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJNYW5hZ2UgcHJvZmlsZVwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJTZWxlY3QgYSBwcm9maWxlIHRvIGNvbmZpZ3VyZSBpdHMgc2V0dGluZ3NcIilcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd246IERyb3Bkb3duQ29tcG9uZW50KSA9PiB0aGlzLmNyZWF0ZVByb2ZpbGVEcm9wZG93bihkcm9wZG93bikpXG4gICAgICAgICAgICAuYWRkRXh0cmFCdXR0b24oKGJ1dHRvbjogRXh0cmFCdXR0b25Db21wb25lbnQpID0+IHRoaXMuY3JlYXRlTmV3UHJvZmlsZUJ1dHRvbihidXR0b24pKVxuICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKChidXR0b246IEV4dHJhQnV0dG9uQ29tcG9uZW50KSA9PiB0aGlzLmNyZWF0ZURlbGV0ZVByb2ZpbGVCdXR0b24oYnV0dG9uKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVQcm9maWxlRHJvcGRvd24oZHJvcGRvd246IERyb3Bkb3duQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2ZpbGVzKS5mb3JFYWNoKChbaWQsIHByb2ZpbGVdKSA9PiB7XG4gICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24oaWQsIHByb2ZpbGUubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuZGlzcGxheWVkUHJvZmlsZUlkKVxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkUHJvZmlsZUlkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJQcm9maWxlU2V0dGluZ3ModGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvZmlsZXNbdmFsdWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlTmV3UHJvZmlsZUJ1dHRvbihidXR0b246IEV4dHJhQnV0dG9uQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgLnNldEljb24oXCJwbHVzXCIpXG4gICAgICAgICAgICAuc2V0VG9vbHRpcChcIkNyZWF0ZSBuZXcgcHJvZmlsZVwiKVxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkUHJvZmlsZUlkID0gbmV3UHJvZmlsZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9maWxlcyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlRGVsZXRlUHJvZmlsZUJ1dHRvbihidXR0b246IEV4dHJhQnV0dG9uQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGlzRGVmYXVsdCA9IHRoaXMuZGlzcGxheWVkUHJvZmlsZUlkID09PSBERUZBVUxUX1BST0ZJTEU7XG4gICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgLnNldERpc2FibGVkKGlzRGVmYXVsdClcbiAgICAgICAgICAgIC5zZXRJY29uKFwidHJhc2hcIilcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKGlzRGVmYXVsdCA/IFwiQ2Fubm90IGRlbGV0ZSBkZWZhdWx0IHByb2ZpbGVcIiA6IFwiRGVsZXRlIHByb2ZpbGVcIilcbiAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvZmlsZXNbdGhpcy5kaXNwbGF5ZWRQcm9maWxlSWRdO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkUHJvZmlsZUlkID0gREVGQVVMVF9QUk9GSUxFO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlbmRlclByb2ZpbGVTZXR0aW5ncyhwcm9maWxlOiBQcm9maWxlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMucHJvZmlsZUNvbnRhaW5lci5lbXB0eSgpO1xuXG4gICAgICAgIC8vIFByb2ZpbGUgTmFtZVxuICAgICAgICBuZXcgU2V0dGluZyh0aGlzLnByb2ZpbGVDb250YWluZXIpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlByb2ZpbGUgTmFtZVwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJOYW1lIG9mIHRoZSBwcm9maWxlXCIpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0VmFsdWUocHJvZmlsZS5uYW1lKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZmlsZS5uYW1lID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJvdmlkZXIgU2VsZWN0aW9uXG4gICAgICAgIG5ldyBTZXR0aW5nKHRoaXMucHJvZmlsZUNvbnRhaW5lcilcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQUkgUHJvdmlkZXJcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiQ2hvb3NlIHlvdXIgcHJlZmVycmVkIEFJIHByb3ZpZGVyXCIpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oKGRyb3Bkb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbihQcm92aWRlclR5cGUuT0xMQU1BLCBcIk9sbGFtYVwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFByb3ZpZGVyVHlwZS5PUEVOQUksIFwiT3BlbkFJXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShwcm9maWxlLnByb3ZpZGVyKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBQcm92aWRlclR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGUucHJvdmlkZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1vZGVsIFNlbGVjdGlvblxuICAgICAgICBuZXcgU2V0dGluZyh0aGlzLnByb2ZpbGVDb250YWluZXIpXG4gICAgICAgICAgICAuc2V0TmFtZShcIk1vZGVsXCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIlNlbGVjdCB0aGUgbW9kZWwgdG8gdXNlIGZvciBjb21wbGV0aW9uc1wiKVxuICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKChidXR0b24pID0+IHtcbiAgICAgICAgICAgICAgICBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgLnNldEljb24oXCJyZWZyZXNoLWNjd1wiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIlVwZGF0ZSBtb2RlbCBsaXN0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnByb3ZpZGVyTWFuYWdlci51cGRhdGVNb2RlbHMocHJvZmlsZS5wcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyUHJvZmlsZVNldHRpbmdzKHByb2ZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oYXN5bmMgKGRyb3Bkb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXJzW3Byb2ZpbGUucHJvdmlkZXJdLm1vZGVscztcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9ucyhPYmplY3QuZnJvbUVudHJpZXMobW9kZWxzLm1hcCgobW9kZWwpID0+IFttb2RlbCwgbW9kZWxdKSkpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShwcm9maWxlLmNvbXBsZXRpb25PcHRpb25zLm1vZGVsKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9maWxlLmNvbXBsZXRpb25PcHRpb25zLm1vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRlbXBlcmF0dXJlIFNldHRpbmdcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5wcm9maWxlQ29udGFpbmVyKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJUZW1wZXJhdHVyZVwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJDb250cm9sIHRoZSByYW5kb21uZXNzIG9mIGNvbXBsZXRpb25zICgwID0gZGV0ZXJtaW5pc3RpYywgMSA9IGNyZWF0aXZlKVwiKVxuICAgICAgICAgICAgLmFkZFNsaWRlcigoc2xpZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRMaW1pdHMoMCwgMSwgMC4xKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocHJvZmlsZS5jb21wbGV0aW9uT3B0aW9ucy50ZW1wZXJhdHVyZSlcbiAgICAgICAgICAgICAgICAgICAgLnNldER5bmFtaWNUb29sdGlwKClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZS5jb21wbGV0aW9uT3B0aW9ucy50ZW1wZXJhdHVyZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3VnZ2VzdGlvbiBEZWxheVxuICAgICAgICBuZXcgU2V0dGluZyh0aGlzLnByb2ZpbGVDb250YWluZXIpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlN1Z2dlc3Rpb24gRGVsYXlcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiRGVsYXkgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSBmZXRjaGluZyBzdWdnZXN0aW9uc1wiKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0QXR0cihcInR5cGVcIiwgXCJudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCIxMDAwXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShTdHJpbmcocHJvZmlsZS5kZWxheU1zKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZS5kZWxheU1zID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3BsaXQgU3RyYXRlZ3lcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5wcm9maWxlQ29udGFpbmVyKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJDb21wbGV0aW9uIFN0cmF0ZWd5XCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkNob29zZSBob3cgY29tcGxldGlvbnMgc2hvdWxkIGJlIHNwbGl0IGFuZCBhY2NlcHRlZFwiKVxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKChkcm9wZG93bikgPT4ge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oXCJ3b3JkXCIsIFwiV29yZCBieSBXb3JkXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oXCJzZW50ZW5jZVwiLCBcIlNlbnRlbmNlIGJ5IFNlbnRlbmNlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oXCJwYXJhZ3JhcGhcIiwgXCJQYXJhZ3JhcGggYnkgUGFyYWdyYXBoXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oXCJmdWxsXCIsIFwiRnVsbCBDb21wbGV0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShwcm9maWxlLnNwbGl0U3RyYXRlZ3kpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IFNwbGl0U3RyYXRlZ3kpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGUuc3BsaXRTdHJhdGVneSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3lzdGVtIFByb21wdFxuICAgICAgICBuZXcgU2V0dGluZyh0aGlzLnByb2ZpbGVDb250YWluZXIpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlN5c3RlbSBQcm9tcHRcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiU2V0IHN5c3RlbSBwcm9tcHRcIilcbiAgICAgICAgICAgIC5hZGRUZXh0QXJlYSgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5yb3dzID0gMztcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0Q3NzU3R5bGVzKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICByZXNpemU6IFwidmVydGljYWxcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRleHQuc2V0VmFsdWUocHJvZmlsZS5jb21wbGV0aW9uT3B0aW9ucy5zeXN0ZW1Qcm9tcHQpLm9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGUuY29tcGxldGlvbk9wdGlvbnMuc3lzdGVtUHJvbXB0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBVc2VyIFByb21wdFxuICAgICAgICBuZXcgU2V0dGluZyh0aGlzLnByb2ZpbGVDb250YWluZXIpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlVzZXIgUHJvbXB0XCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIlVzZXIgcHJvbXB0IHRlbXBsYXRlXCIpXG4gICAgICAgICAgICAuYWRkRXh0cmFCdXR0b24oKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbihcImxpc3RcIilcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJJbnNlcnQgbXVzdGFjaGUgdGVtcGxhdGUgdmFyaWFibGVzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGUuY29tcGxldGlvbk9wdGlvbnMudXNlclByb21wdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVEVNUExBVEVfVkFSSUFCTEVTO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZS5jb21wbGV0aW9uT3B0aW9ucy51c2VyUHJvbXB0ID0gdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJQcm9maWxlU2V0dGluZ3MocHJvZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hZGRUZXh0QXJlYSgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5yb3dzID0gMztcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0Q3NzU3R5bGVzKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICByZXNpemU6IFwidmVydGljYWxcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRleHQuc2V0VmFsdWUocHJvZmlsZS5jb21wbGV0aW9uT3B0aW9ucy51c2VyUHJvbXB0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9maWxlLmNvbXBsZXRpb25PcHRpb25zLnVzZXJQcm9tcHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFBhdGggTWFwcGluZ3MgU2VjdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5jbGFzcyBQYXRoTWFwcGluZ3NTZWN0aW9uIHtcbiAgICBwcml2YXRlIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBwbHVnaW46IEluc2NyaWJlO1xuICAgIHByaXZhdGUgdGFibGVDb250YWluZXI6IEhUTUxFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgcGx1Z2luOiBJbnNjcmliZSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIHRoaXMudGFibGVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIH1cblxuICAgIGFzeW5jIHJlbmRlcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IFwiRHluYW1pYyBQcm9maWxlIE1hcHBpbmdcIiB9KTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRWwoXCJwXCIsIHtcbiAgICAgICAgICAgIHRleHQ6IFwiWW91IGNhbiBhc3NpZ24gcHJvZmlsZXMgdG8gcGF0aHMuIFBhdGhzIGFyZSBtYXRjaGVkIGJ5IHByZWZpeCwgd2l0aCBsb25nZXIgcGF0aHMgdGFraW5nIHByZWNlZGVuY2UuIEZvciBleGFtcGxlLCAnL0RhaWx5JyB3aWxsIG1hdGNoIGFsbCBmaWxlcyBpbiB0aGUgRGFpbHkgZm9sZGVyLlwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jcmVhdGVFbChcImJyXCIpO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudGFibGVDb250YWluZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlck1hcHBpbmdzVGFibGUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlbmRlck1hcHBpbmdzVGFibGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMudGFibGVDb250YWluZXIuZW1wdHkoKTtcblxuICAgICAgICBjb25zdCB0YWJsZSA9IHRoaXMudGFibGVDb250YWluZXIuY3JlYXRlRWwoXCJ0YWJsZVwiLCB7IGNsczogXCJtYXBwaW5nLXRhYmxlXCIgfSk7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHRhYmxlLmNyZWF0ZUVsKFwidHJcIik7XG4gICAgICAgIGhlYWRlci5jcmVhdGVFbChcInRoXCIsIHsgdGV4dDogXCJQYXRoXCIgfSk7XG4gICAgICAgIGhlYWRlci5jcmVhdGVFbChcInRoXCIsIHsgdGV4dDogXCJQcm9maWxlXCIgfSk7XG4gICAgICAgIGhlYWRlci5jcmVhdGVFbChcInRoXCIsIHsgdGV4dDogXCJcIiB9KTtcblxuICAgICAgICAvLyBBZGQgTmV3IE1hcHBpbmcgUm93XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IHRhYmxlLmNyZWF0ZUVsKFwidHJcIiwgeyBjbHM6IFwibmV3LW1hcHBpbmctcm93XCIgfSk7XG4gICAgICAgIGxldCBwYXRoSW5wdXQgPSBcIlwiO1xuICAgICAgICBsZXQgc2VsZWN0ZWRQcm9maWxlID0gREVGQVVMVF9QUk9GSUxFO1xuXG4gICAgICAgIC8vIFBhdGggaW5wdXQgY2VsbFxuICAgICAgICBjb25zdCBwYXRoQ2VsbCA9IG5ld1Jvdy5jcmVhdGVFbChcInRkXCIpO1xuICAgICAgICBjb25zdCBwYXRoSW5wdXRFbCA9IHBhdGhDZWxsLmNyZWF0ZUVsKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJFbnRlciBwYXRoIChlLmcuLCBEYWlseS9Xb3JrKVwiLFxuICAgICAgICAgICAgY2xzOiBcInBhdGgtaW5wdXRcIlxuICAgICAgICB9KTtcbiAgICAgICAgcGF0aElucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIChlKSA9PiB7XG4gICAgICAgICAgICBwYXRoSW5wdXQgPSAoZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFByb2ZpbGUgZHJvcGRvd24gY2VsbFxuICAgICAgICBjb25zdCBwcm9maWxlQ2VsbCA9IG5ld1Jvdy5jcmVhdGVFbChcInRkXCIpO1xuICAgICAgICBjb25zdCBwcm9maWxlRHJvcGRvd24gPSBuZXcgRHJvcGRvd25Db21wb25lbnQocHJvZmlsZUNlbGwpXG4gICAgICAgICAgICAuc2V0VmFsdWUoc2VsZWN0ZWRQcm9maWxlKTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9maWxlcykuZm9yRWFjaCgoW2lkLCBwcm9maWxlXSkgPT4ge1xuICAgICAgICAgICAgcHJvZmlsZURyb3Bkb3duLmFkZE9wdGlvbihpZCwgcHJvZmlsZS5uYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvZmlsZURyb3Bkb3duLm9uQ2hhbmdlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQcm9maWxlID0gdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBidXR0b24gY2VsbFxuICAgICAgICBjb25zdCBhY3Rpb25DZWxsID0gbmV3Um93LmNyZWF0ZUVsKFwidGRcIik7XG4gICAgICAgIGNvbnN0IGFkZEJ1dHRvbiA9IG5ldyBFeHRyYUJ1dHRvbkNvbXBvbmVudChhY3Rpb25DZWxsKVxuICAgICAgICAgICAgLnNldEljb24oXCJwbHVzXCIpXG4gICAgICAgICAgICAuc2V0VG9vbHRpcChcIkFkZCBwcm9maWxlIG1hcHBpbmdcIilcbiAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXRoX3Byb2ZpbGVfbWFwcGluZ3NbcGF0aElucHV0XSA9IHNlbGVjdGVkUHJvZmlsZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRXhpc3RpbmcgTWFwcGluZ3NcbiAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5wbHVnaW4uc2V0dGluZ3MucGF0aF9wcm9maWxlX21hcHBpbmdzKS5mb3JFYWNoKChbcGF0aCwgcHJvZmlsZUlkXSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gdGFibGUuY3JlYXRlRWwoXCJ0clwiKTtcbiAgICAgICAgICAgIHJvdy5jcmVhdGVFbChcInRkXCIsIHsgdGV4dDogcGF0aCB8fCBcIlJvb3RcIiB9KTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHByb2ZpbGUgY2VsbCB3aXRoIGRyb3Bkb3duXG4gICAgICAgICAgICBjb25zdCBpc0RlZmF1bHRNYXBwaW5nID0gcGF0aCA9PT0gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IHByb2ZpbGVDZWxsID0gcm93LmNyZWF0ZUVsKFwidGRcIik7XG5cbiAgICAgICAgICAgIC8vIEZvciBvdGhlciBtYXBwaW5ncywgc2hvdyBlZGl0YWJsZSBkcm9wZG93blxuICAgICAgICAgICAgY29uc3QgcHJvZmlsZURyb3Bkb3duID0gbmV3IERyb3Bkb3duQ29tcG9uZW50KHByb2ZpbGVDZWxsKVxuICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZChpc0RlZmF1bHRNYXBwaW5nKTtcblxuICAgICAgICAgICAgLy8gQWRkIHByb2ZpbGUgb3B0aW9uc1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvZmlsZXMpLmZvckVhY2goKFtpZCwgcHJvZmlsZV0pID0+IHtcbiAgICAgICAgICAgICAgICBwcm9maWxlRHJvcGRvd24uYWRkT3B0aW9uKGlkLCBwcm9maWxlLm5hbWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHByb2ZpbGVEcm9wZG93bi5zZXRWYWx1ZShwcm9maWxlSWQpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgcHJvZmlsZSBjaGFuZ2VcbiAgICAgICAgICAgIHByb2ZpbGVEcm9wZG93bi5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXRoX3Byb2ZpbGVfbWFwcGluZ3NbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnNDZWxsID0gcm93LmNyZWF0ZUVsKFwidGRcIik7XG4gICAgICAgICAgICBuZXcgRXh0cmFCdXR0b25Db21wb25lbnQoYWN0aW9uc0NlbGwpXG4gICAgICAgICAgICAgICAgLnNldEljb24oXCJ0cmFzaFwiKVxuICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZChpc0RlZmF1bHRNYXBwaW5nKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiRGVsZXRlIG1hcHBpbmdcIilcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXRoX3Byb2ZpbGVfbWFwcGluZ3NbcGF0aF07XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBNb2RhbCwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgUHJvdmlkZXJUeXBlIH0gZnJvbSBcInNyYy9wcm92aWRlcnNcIjtcbmltcG9ydCBJbnNjcmliZSBmcm9tIFwic3JjL21haW5cIjtcblxuZXhwb3J0IGNsYXNzIFByb3ZpZGVyU2V0dGluZ3NNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgYXBwOiBBcHAsXG4gICAgICAgIHByaXZhdGUgcGx1Z2luOiBJbnNjcmliZSxcbiAgICAgICAgcHJpdmF0ZSBwcm92aWRlclR5cGU6IFByb3ZpZGVyVHlwZSxcbiAgICAgICAgcHJpdmF0ZSBvblNhdmU6ICgpID0+IHZvaWRcbiAgICApIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICB9XG5cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuXG4gICAgICAgIC8vIEFwcGx5IGN1c3RvbSBtb2RhbCBzdHlsZXNcbiAgICAgICAgdGhpcy5tb2RhbEVsLmFkZENsYXNzKCdpbnNjcmliZS1wcm92aWRlci1tb2RhbCcpO1xuICAgICAgICB0aGlzLm1vZGFsRWwuc3R5bGUud2lkdGggPSAnNjB2dyc7XG4gICAgICAgIHRoaXMubW9kYWxFbC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgY29udGFpbmVyIGZvciBiZXR0ZXIgc3R5bGluZ1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAnaW5zY3JpYmUtbW9kYWwtY29udGFpbmVyJyB9KTtcblxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJUeXBlID09PSBQcm92aWRlclR5cGUuT0xMQU1BID9cbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVycy5vbGxhbWEgOlxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXJzLm9wZW5haTtcblxuICAgICAgICAvLyBIZWFkZXIgc2VjdGlvblxuICAgICAgICBjb25zdCBoZWFkZXIgPSBjb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAnaW5zY3JpYmUtbW9kYWwtaGVhZGVyJyB9KTtcbiAgICAgICAgaGVhZGVyLmNyZWF0ZUVsKFwiaDJcIiwge1xuICAgICAgICAgICAgdGV4dDogYENvbmZpZ3VyZSAke3Byb3ZpZGVyLm5hbWV9YCxcbiAgICAgICAgICAgIGNsczogJ2luc2NyaWJlLW1vZGFsLXRpdGxlJ1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb250ZW50IHNlY3Rpb25cbiAgICAgICAgY29uc3QgY29udGVudCA9IGNvbnRhaW5lci5jcmVhdGVEaXYoeyBjbHM6ICdpbnNjcmliZS1tb2RhbC1jb250ZW50JyB9KTtcblxuICAgICAgICBpZiAodGhpcy5wcm92aWRlclR5cGUgPT09IFByb3ZpZGVyVHlwZS5PTExBTUEpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sbGFtYVByb3ZpZGVyID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvdmlkZXJzLm9sbGFtYTtcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnQpXG4gICAgICAgICAgICAgICAgLnNldENsYXNzKCdpbnNjcmliZS1tb2RhbC1zZXR0aW5nJylcbiAgICAgICAgICAgICAgICAuc2V0TmFtZShcIkhvc3RcIilcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhcIllvdXIgT2xsYW1hIGluc3RhbmNlIFVSTFwiKVxuICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcImh0dHA6Ly9sb2NhbGhvc3Q6MTE0MzRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShvbGxhbWFQcm92aWRlci5ob3N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sbGFtYVByb3ZpZGVyLmhvc3QgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuYWRkQ2xhc3MoJ2luc2NyaWJlLW1vZGFsLWlucHV0Jyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvcGVuYWlQcm92aWRlciA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVycy5vcGVuYWk7XG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50KVxuICAgICAgICAgICAgICAgIC5zZXRDbGFzcygnaW5zY3JpYmUtbW9kYWwtc2V0dGluZycpXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoXCJBUEkgS2V5XCIpXG4gICAgICAgICAgICAgICAgLnNldERlc2MoXCJZb3VyIE9wZW5BSSBBUEkga2V5XCIpXG4gICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwic2stLi4uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUob3BlbmFpUHJvdmlkZXIuYXBpS2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5haVByb3ZpZGVyLmFwaUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5hZGRDbGFzcygnaW5zY3JpYmUtbW9kYWwtaW5wdXQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG92ZXJyaWRlIG9uQ2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgICAgICAvLyBSZW1vdmUgY3VzdG9tIHN0eWxlc1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnNjcmliZS1tb2RhbC1zdHlsZXMnKTtcbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5vblNhdmUoKTtcbiAgICB9XG59ICIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgSW5saW5lQ29tcGxldGlvbk9wdGlvbnMsIFN1Z2dlc3Rpb24gfSBmcm9tIFwic3JjL2V4dGVuc2lvblwiO1xuaW1wb3J0IHsgYnVpbGRQcm92aWRlcnMsIFByb3ZpZGVyLCBQcm92aWRlcnMsIFByb3ZpZGVyVHlwZSB9IGZyb20gXCJzcmMvcHJvdmlkZXJzXCI7XG5pbXBvcnQgeyBTZXR0aW5ncywgQ29tcGxldGlvbk9wdGlvbnMsIERFRkFVTFRfUFJPRklMRSwgUHJvZmlsZSB9IGZyb20gXCJzcmMvc2V0dGluZ3Mvc2V0dGluZ3NcIjtcblxuZXhwb3J0IGNsYXNzIFByb3ZpZGVyTWFuYWdlciB7XG4gICAgcHJpdmF0ZSBhcHA6IEFwcDtcbiAgICBwcml2YXRlIHNldHRpbmdzOiBTZXR0aW5ncztcbiAgICBwcml2YXRlIHByb3ZpZGVyczogUHJvdmlkZXJzO1xuICAgIHByaXZhdGUgaW5saW5lU3VnZ2VzdGlvbk9wdGlvbnM6IElubGluZUNvbXBsZXRpb25PcHRpb25zID0geyBkZWxheU1zOiAzMDAsIHNwbGl0U3RyYXRlZ3k6IFwic2VudGVuY2VcIiB9O1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHNldHRpbmdzOiBTZXR0aW5ncykge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IGJ1aWxkUHJvdmlkZXJzKHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBhc3luYyAqIGZldGNoU3VnZ2VzdGlvbnMoKTogQXN5bmNHZW5lcmF0b3I8U3VnZ2VzdGlvbj4ge1xuICAgICAgICBjb25zdCBhY3RpdmVFZGl0b3IgPSB0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlRWRpdG9yO1xuICAgICAgICBpZiAoIWFjdGl2ZUVkaXRvcikgcmV0dXJuO1xuICAgICAgICBpZiAoIWFjdGl2ZUVkaXRvci5lZGl0b3IpIHJldHVybjtcblxuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGFjdGl2ZUVkaXRvci5maWxlPy5wYXRoIHx8ICcnO1xuXG4gICAgICAgIGNvbnN0IFtwcm92aWRlciwgcHJvZmlsZV0gPSB0aGlzLnJlc29sdmVQcm9maWxlKGZpbGVQYXRoKTtcblxuICAgICAgICB0aGlzLmlubGluZVN1Z2dlc3Rpb25PcHRpb25zID0geyBkZWxheU1zOiBwcm9maWxlLmRlbGF5TXMsIHNwbGl0U3RyYXRlZ3k6IHByb2ZpbGUuc3BsaXRTdHJhdGVneSB9O1xuXG4gICAgICAgIHlpZWxkKiB0aGlzLmdlbmVyYXRlQ29tcGxldGlvbihhY3RpdmVFZGl0b3IuZWRpdG9yLCBwcm92aWRlciwgcHJvZmlsZS5jb21wbGV0aW9uT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZ2V0T3B0aW9ucygpOiBJbmxpbmVDb21wbGV0aW9uT3B0aW9ucyB7XG4gICAgICAgIHJldHVybiB0aGlzLmlubGluZVN1Z2dlc3Rpb25PcHRpb25zO1xuICAgIH1cblxuICAgIGxvYWRQcm92aWRlcnMoKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gYnVpbGRQcm92aWRlcnModGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyAqIGdlbmVyYXRlQ29tcGxldGlvbihlZGl0b3I6IEVkaXRvciwgcHJvdmlkZXI6IFByb3ZpZGVyLCBvcHRpb25zOiBDb21wbGV0aW9uT3B0aW9ucyk6IEFzeW5jR2VuZXJhdG9yPFN1Z2dlc3Rpb24+IHtcbiAgICAgICAgYXdhaXQgcHJvdmlkZXIuYWJvcnQoKTtcbiAgICAgICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICBjb25zdCBjdXJyZW50TGluZSA9IGVkaXRvci5nZXRMaW5lKGN1cnNvci5saW5lKTtcbiAgICAgICAgaWYgKCFjdXJyZW50TGluZS5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgY29uc3QgbGFzdENoYXIgPSBjdXJyZW50TGluZVtjdXJzb3IuY2ggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RDaGFyICE9PSBcIiBcIikgcmV0dXJuO1xuXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdGV4dCBvZiBwcm92aWRlci5nZW5lcmF0ZShlZGl0b3IsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHRleHQgfTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXNvbHZlUHJvZmlsZShmaWxlUGF0aDogc3RyaW5nKTogW1Byb3ZpZGVyLCBQcm9maWxlXSB7XG4gICAgICAgIGNvbnN0IHByb2ZpbGVOYW1lID0gdGhpcy5yZXNvbHZlUHJvZmlsZUZyb21QYXRoKGZpbGVQYXRoKTtcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IHRoaXMuc2V0dGluZ3MucHJvZmlsZXNbcHJvZmlsZU5hbWVdO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJzW3Byb2ZpbGUucHJvdmlkZXJdO1xuICAgICAgICByZXR1cm4gW3Byb3ZpZGVyLCBwcm9maWxlXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlc29sdmVQcm9maWxlRnJvbVBhdGgoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5wYXRoX3Byb2ZpbGVfbWFwcGluZ3MgfHwgT2JqZWN0LmtleXModGhpcy5zZXR0aW5ncy5wYXRoX3Byb2ZpbGVfbWFwcGluZ3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfUFJPRklMRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gZmlsZVBhdGgucmVwbGFjZSgvXlxcLyt8XFwvKyQvZywgJycpO1xuICAgICAgICBsZXQgbG9uZ2VzdE1hdGNoID0gJyc7XG4gICAgICAgIGxldCBtYXRjaGVkUHJvZmlsZSA9IERFRkFVTFRfUFJPRklMRTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLnNldHRpbmdzLnBhdGhfcHJvZmlsZV9tYXBwaW5ncykuZm9yRWFjaCgoW3BhdGgsIHByb2ZpbGVdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkTWFwcGluZ1BhdGggPSBwYXRoLnJlcGxhY2UoL15cXC8rfFxcLyskL2csICcnKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkUGF0aC5zdGFydHNXaXRoKG5vcm1hbGl6ZWRNYXBwaW5nUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZE1hcHBpbmdQYXRoLmxlbmd0aCA+IGxvbmdlc3RNYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9uZ2VzdE1hdGNoID0gbm9ybWFsaXplZE1hcHBpbmdQYXRoO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkUHJvZmlsZSA9IHByb2ZpbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWF0Y2hlZFByb2ZpbGU7XG4gICAgfVxuXG4gICAgYXN5bmMgdXBkYXRlTW9kZWxzKHByb3ZpZGVyOiBQcm92aWRlclR5cGUpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyc1twcm92aWRlcl0udXBkYXRlTW9kZWxzKCk7XG4gICAgfVxufSAiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLG1CQUF1Qjs7O0FDVXZCLGtCQU9PO0FBQ1AsbUJBUU87QUFxRFAsSUFBTSxzQkFBc0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS3hCLE1BQU0sQ0FBQyxTQUFpQjtBQUNwQixVQUFNLFlBQVksS0FBSyxRQUFRLEdBQUc7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QSxFQUVBLE1BQU0sc0JBQXNCO0FBQzNCLFNBQUssa0JBQWtCLElBQUksZ0JBQWdCLEtBQUssS0FBSyxLQUFLLFFBQVE7QUFBQSxFQUNuRTtBQUFBLEVBRUEsTUFBTSxpQkFBaUI7QUFDdEIsVUFBTSxZQUFZLGtCQUFrQjtBQUFBLE1BQ25DLFdBQVcsTUFBTSxLQUFLLGdCQUFnQixpQkFBaUI7QUFBQSxNQUN2RCxZQUFZLE1BQU0sS0FBSyxnQkFBZ0IsV0FBVztBQUFBLElBQ25ELENBQUM7QUFDRCxTQUFLLHdCQUF3QixTQUFTO0FBQUEsRUFDdkM7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNwQixTQUFLLFdBQVcsT0FBTztBQUFBLE1BQ3RCLENBQUM7QUFBQSxNQUNEO0FBQUEsTUFDQSxNQUFNLEtBQUssU0FBUztBQUFBLElBQ3JCO0FBQUEsRUFDRDtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUNqQyxTQUFLLGdCQUFnQixjQUFjO0FBQUEsRUFDcEM7QUFDRDsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgImZldGNoIiwgInJlc29sdmUiLCAicmVzb2x2ZSIsICJmZXRjaCIsICJmZXRjaCIsICJfX2RlZlByb3AiLCAiT2xsYW1hIiwgImZzIiwgImluZGV4IiwgImdldCIsICJzZWxmIiwgImNsZWFyQ2FjaGUiLCAicGFyc2UiLCAicmVuZGVyIiwgIk9sbGFtYSIsICJpbXBvcnRfb2JzaWRpYW4iLCAicHJvZmlsZUNlbGwiLCAicHJvZmlsZURyb3Bkb3duIl0KfQo=
